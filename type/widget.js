(function(envVars,easyXDM,Tess2,jQuery,Handlebars,THREE,UAParser,CSG,$,TWEEN) {

	var exports = {};


//header.js
/**
@author Brandon Cole / https://twitter.com/Technitary / https://tinkercad.com/users/2hKbKjgO7A3
*/

/**
The Autodesk Creative Platform Runtime provies low level runtime capabilities that all 
Autodesk Creative Platform Libraries inherit.  The library can also be included directly 
on the client side and used to download and execute libraries in the browser.
@module 1jiw9epElcK
**/
(function(Host){

	"use strict";

	// This list of methods is taken from the following URL
	// https://developer.mozilla.org/en-US/docs/Web/API/console
	var console = {
		dir: function() { },
		error: function() { },
		group: function() { },
		groupCollapsed: function() { },
		groupEnd: function() { },
		info: function() { },
		log: function() { },
		time: function() { },
		timeEnd: function() { },
		trace: function() { },
		warn: function() { }
	};

	// Define the Object.defineProperty for IE 8.
	(function () {
		var supportDefineProperty = Object.defineProperty && (function () {
		    try {
		        Object.defineProperty({}, 'x', {});
		        return true;
		    } catch (e) { /* this is ES3 */
		        return false;
		    }
		}());

		if (!supportDefineProperty) {
		    hasOwnProp = Object.prototype.hasOwnProperty;
		   
		    if (hasOwnProp) {
	            Object.defineProperty = function (obj, prop, descriptor) {
	            	if (typeof obj !== 'object') { // all arguments required
	                    throw new TypeError("Object.defineProperty called in non-object");
	                }
	                if (typeof descriptor !== 'object') { // all arguments required
	                    throw new TypeError("Property description must be an object: " + descriptor);
	                }
	                
	                if ((hasOwnProp.call(descriptor, "get") ||
                         hasOwnProp.call(descriptor, "set"))){
                        //throw new TypeError("The getter and setter are not supported.");
                    }
	               
	                prop += ""; // convert to string
	                obj[prop] = descriptor.value;
	           
	                return obj;
	            };
	        }
	    }
	}());

    var creativePlatformLibrary1jiw9epElcKrev0 = function(Environment, Library) {
//manifest.js
if (Library) {
	Library.name = "Autodesk Creative Platform Runtime Library";
	Library.description = "Implicit Capabilities and Client-Side Runtime";
	Library.resources = [
	];
}
//3rd.js
/**
easyXDM is a Javascript library that enables a developer to easily work around 
the limitation set in place by the Same Origin Policy, in turn making it easy to 
communicate and expose javascript API’s across domain boundaries.  This is used
to execute community-developed libraries in their own IFRAME so that the users
session is secure and the community developed libraries get executed in what is
essentially a secure sandbox.
@opensource easyXDM.js 2.4.19.3
@websiteurl http://easyxdm.net/wp/
@downloadurl https://github.com/oyvindkinsey/easyXDM/releases/download/2.4.19/easyXDM-2.4.19.3.zip
@licenseurl https://github.com/oyvindkinsey/easyXDM/blob/master/MIT-license.txt
@licensetext The MIT License

Copyright (c) 2009-2011 Øyvind Sean Kinsey, oyvind@kinsey.no

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
@source easyxdm-v2.4.19.3.js
@symbols easyXDM
**/

/**
UAParser.js - Lightweight JavaScript-based User-Agent string parser. Supports 
browser & node.js environment. Also available as jQuery/Zepto plugin, 
Component package, Bower package, & AMD module
@opensource UAParser.js 0.7.0
@websiteurl http://faisalman.github.io/ua-parser-js/
@downloadurl https://raw.githubusercontent.com/faisalman/ua-parser-js/master/src/ua-parser.min.js
@licenseurl http://faisalman.github.io/ua-parser-js/
@licensetext Dual licensed under GPLv2 & MIT

Copyright : 2012-2013 Faisalman <fyzlman@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
@source ua-parser.min.js
@symbols UAParser
**/
//documentation.js
/**
This version represents the initial debut of Autodesk's Creative Platform.
With the release several new features such as Text and Sketch debuted for the first time.
A good article summarizing this release is here: http://blog.tinkercad.com/2013/12/19/sketch-and-text/.
@version 1.0.0
@released 2013-12-17T00:00:00Z
@markdown
**/

/**
Added the ability to invoke a library on the client if it supports client execution so that
real time previews of Creative Libraries could happen.
@version 1.1.0
@released 2014-03-09T00:00:00Z
@markdown
**/

/**
Added additional APIs to support disconnected execution of libraries.
@version 1.2.0
@released 2014-04-10T00:00:00Z
@markdown
**/

/**
- Support for retina-display Macbooks added.
- Ability to enumerate resources at runtime added.
@version 1.3.0
@released 2014-05-13T00:00:00Z
@markdown
**/

/**
- Added the {Library.resourceFile} method
@version 1.4.0
@released 2014-08-26T00:00:00Z
@markdown
**/

/**
- Updated the way library scripts are requested to make client side tools behave better when debugging.
@version 1.5.0
@released 2014-10-13T00:00:00Z
@markdown
**/
//browser.js

/**
Encapsulate the inforamtion of the browser.
@class Browser
@private
**/
var Browser = function(name, version, os, helpInfo){
	this.name = name;
    this.version = version;
	this.os = os; // "ios|android|windows|linux|..."
	this.helpInfo = helpInfo;
};

// singleton
var uaparser = new UAParser();

/** 
@class BrowserDetector
@static
@private
**/
var BrowserDetector={
	/** 
	Detect the current user agent and populate a Browser object.
	@method detect
    @return {Browser} | undefined
    @private 
	**/
    detect: function(){
        var detectBrowser = function(ua){
            uaparser.setUA(ua);
            var b = uaparser.getBrowser();
            var browser;
            if(b){
                var os = uaparser.getOS();
                browser = new Browser(b.name.toLowerCase(), b.version, os.name.toLowerCase());
            }
            
            return browser;
        };
        // Returns >0 if a>b; <0 if a<b; 0 if a==b;
        var compareVersion = function(a, b) {
            var trailingZero = /(\.0)+[^\.]*$/;
            a = (a + '').replace(trailingZero, '').split('.');
            b = (b + '').replace(trailingZero, '').split('.');
            var cmp, len = Math.min(a.length, b.length);
            for( var i = 0; i < len; i++ ) {
                cmp = parseInt(a[i], 10) - parseInt(b[i], 10);
                if( cmp !== 0 ) {
                    return cmp;
                }
            }
            return a.length - b.length;
        }
         
        var browser;

        if(navigator && navigator.userAgent){
            var browserMap = {
                "ie": {
                    name: "IE",
                    downloadLink: "http://windows.microsoft.com/en-us/internet-explorer/download-ie"
                },
                "chrome": {
                    name: "Chrome",
                    downloadLink: "https://www.google.com/intl/en-US/chrome/browser/"
                },
                "firefox": {
                    name: "Firefox",
                    downloadLink: "https://www.mozilla.org/en-US/firefox/new/"
                },
                "safari": {
                    name: "Safari",
                    downloadLink: "http://support.apple.com/downloads/#internet"
                }
            };
            browser = detectBrowser(navigator.userAgent);

            var containerStyle = 'style="height: 100%; width: 100%; background-color: rgb(248, 248, 248); display: table;"';
            var contentStyle = 'style="display:table-cell; vertical-align: middle; text-align:center;"';
            var primaryStyle = 'style="font-size: 18px; font-weight: bold; color: #949494; padding: 5px 0;"';
            var secondaryStyle = 'style="font-size: 14px; color: #b8b8b8; padding: 2px 0;"';

            browser.helpInfo = '<div '+containerStyle+'>' + '<div '+contentStyle+'>' + '<div style="display:inline-block; text-align:left;">';
            if(browser.name){
                if(browser.os === 'ios'){
                    // ios device
                    browser.helpInfo += '<span ' + primaryStyle + '>Your device does not support WebGL.</span>' +
                    '<br/><span ' + secondaryStyle + '>To view this page, please visit us from a desktop WebGL-enabled browser.</span>';
                }
                else if(browser.os === 'android'){
                    // android device
                    browser.helpInfo += '<span ' + primaryStyle + '>To view this page, please install a WebGL compatiable browser (like Firefox) from your favorite app store.</span>';
                }
                else{
                    // pc
                    if(browser.name === 'safari' && compareVersion(browser.version, '6.0.4') > 0){
                        // The viewer only works on the version greater than 6.0.4.
                        browser.helpInfo += '<span ' + primaryStyle + '>To experience rich 3D contents, you need to enable WebGL.</span>' +
                        '<br/><span ' + secondaryStyle + '>To switch it on, enable the developer menu and check the "Enable WebGL" option.</span>';
                    }
                    else if(browser.name === 'chrome'){
                        browser.helpInfo += '<span ' + primaryStyle + '> To experience rich 3D contents, you need to have the latest '+browserMap[browser.name].name+' and WebGL enabled.</span>' +
                        '<br/><span ' + secondaryStyle + '>1. Please take a moment to <a href="'+browserMap[browser.name].downloadLink+'" target="_blank" style="color: #4cb1e6;" >install</a>  the latest version.</span>' +
                        '<br/><span ' + secondaryStyle + '>2. Type "chrome://flags/" into the address bar, look for "Disable WebGL" option, make sure it is disabled and relaunch the browser.</span>';
                    }
                    else if(browser.name === 'firefox'){
                        browser.helpInfo += '<span ' + primaryStyle + '> To experience rich 3D contents, you need to have the latest '+browserMap[browser.name].name+' and WebGL enabled.</span>' +
                        '<br/><span ' + secondaryStyle + '>1. Please take a moment to <a href="'+browserMap[browser.name].downloadLink+'" target="_blank" style="color: #4cb1e6;" >install</a>  the latest version.</span>' +
                        '<br/><span ' + secondaryStyle + '>2. Type "about:config" into the address bar, and set the "webgl.disabled" variable to False.</span>';
                    }
                    else if(browser.name === 'ie' && compareVersion(browser.version, '10') < 0){ // ie < 10.0
                        browser.helpInfo +='<div style="text-align:center;"><span ' + primaryStyle + '> To experience rich 3D contents, you need to have the latest '+browserMap[browser.name].name+'.</span>' +
                        '<br/><span ' + secondaryStyle + '>Please take a moment to <a href="'+browserMap[browser.name].downloadLink+'" target="_blank" style="color: #4cb1e6;" >install</a>  the latest version.</span></div>';
                    }
                    else if(browser.name === 'ie' || browser.name === 'safari'){ // ie>=10.0 / safari <= 6.0.4
                        browser.helpInfo +='<span ' + primaryStyle + '> To experience rich 3D contents, you need to have the latest '+browserMap[browser.name].name+'.</span>' +
                        '<br/><span ' + secondaryStyle + '>Please take a moment to <a href="'+browserMap[browser.name].downloadLink+'" target="_blank" style="color: #4cb1e6;" >install</a>  the latest version.</span>';
                    }
                    else{
                        // other browser
                        browser.helpInfo +='<span ' + primaryStyle + '>To experience rich 3D contents, you need to have a WebGL compatiable browser.</span>' +
                        '<br/><span ' + secondaryStyle + '>Please take a moment to install one like <a href="'+browserMap['chrome'].downloadLink+'" target="_blank" style="color: #4cb1e6;" >Google Chrome</a>.</span>';
                    }
                }
            }
            else{ // other browsers
                browser.helpInfo +='<span ' + primaryStyle + '>To experience rich 3D contents, you need to have a WebGL compatiable browser.</span>' +
                '<br/><span ' + secondaryStyle + '>Please take a moment to install one like <a href="'+browserMap['chrome'].downloadLink+'" target="_blank" style="color: #4cb1e6;" >Google Chrome</a>.</span>';
            }
            browser.helpInfo += '</div></div></div>';
        }

        return browser;
    }
}
//environment.js
/**
Internal implementation of the Environment.
@class _Environment
@private
**/
var _Environment = function() {

    /**
    @property libraries
    @type {Object[String, Library]}
    @private
    **/
    this.libraries = {};

    /**
    Hierarchichal dictionary of key-value pairs.
    @property variables
    @type {Object}
    @private
    **/
    this.variables = {};
};

_Environment.prototype = {

    loadLibrary: function(outer, library) {
        try {
        
            // Try to call the entry point (i.e. DLLMain)
            var entryPoint = 'creativePlatformLibrary' + library.id + 'rev' + library.version;                    
            if(!Host[entryPoint])
                return false;                
            Host[entryPoint](outer, library);

            this.secureLibrary(library);
        
            // Okay that seems to have worked so lets index it...
            var revisions = this.libraries[library.id];
            if(undefined == revisions){
                revisions = {};
                this.libraries[library.id] = revisions;
            }
            revisions[library.version] = library;

            console.log("Runtime: Loaded Library: " + library.id);

        } catch (e) {
            console.error("Runtime: Exception while loading a library (" + library.id + "): " + e);
            return false;
        }

        return true;
    }, 


    /**
    Secure the library by setting proper access permission to its propeties.
    @method securelibrary
    @param {Library} library
    @private 
    **/
    secureLibrary: function(library) {

        // Secure locked properties...
        var securedItems = [
            { key: 'name', value: '' },
            { key: 'description', value: '' },
            { key: 'resources', value: [] }
        ];
        for (var i = 0; i < securedItems.length; i++) {
            var item = securedItems[i];
            var itemValue = library[item.key] || item.value;
            delete library[item.key];
            Object.defineProperty(library, item.key, {
                writable: false,
                enumerable: true,
                configurable: false,
                value: itemValue
            });
        }
        
    }
};

/** 
The Runtime's Environment is where variables can be configured that affect the execution of Libraries that have been loaded.
The runtime is accessible on the client via the {Runtime} using {Runtime#environment}.
A partial listing of some of the variables that are in use today are described in greater depth below.
1. `'callbacks'`
    * `'panic'` : {Function(String)} - A callback function that can be configured to handle panic notifications from `Plugin.panic` statements.
2. `'disconnected'`
    * `'enabled'` : {Boolean} - `True` if the libraries are running disconnected from https://api.tinkercad.com, which happens when a disconnected version is downloaded and run offline, otherwise `False`.
3. `'host'`
    * `'elementId'` : {String} - The ID of the {HTMLElement} where the runtime can display error messages.
4. `'outcomes'`
    * `'logs'` : {Array[String\*]} - An array of diagnostic log statements collected from `Debug.log` statements in client code.
    * `'warnings'` : {Array[String\*]} - An array of diagnostic warnings collected from `Debug.warning` statements in client code.
    * `'points'` : {Array[Array[Number\*]\*]} - An array of arrays, containing diagnostic points collected from `Debug.point` statements in client code.
    * `'lines'` : {Array[Array[Number\*]\*} - An array of arrays, containing diagnostic lines collected from `Debug.line` statements in client code.
5. `'parameters'` :  Configuration information for parameters
6. `'process'`
    * `'id'` : {String} - An identifier for the process that the code is running in.
7. `'proxies'`
    * `'shapeGenerator'` : {Function(Object)} - A function that instantiates a Proxy object for the object returned from a client's `shapeGenerator` export.
    * `'shapeConfigurator'` : {Function(Object)} - A function that instantiates a Proxy object for the object returned from a client's `shapeConfigurator` export.
    * `'shapeModifier'` : {Function(Object)} - A function that instantiates a Proxy object for the object returned from a client's `shapeModifier` export.
8. `'resources'`
    * `'root'` : {String} - A root path that can be altered to indicate where the resources are when running in disconnected mode.
    * `'map'` : {Object[String,String]} - When a disconnected version is deployed to a CDN, the resources may get different URLs altogether so this allows the original resource names to be configured to the new locations.
    * `'minified'` : {Boolean} - Indicates whether minified resources should be used.  The default is `True` if unspecified, otherwise `False` can be configured.
9. `'urls'`
    * `'api'` : {String} - The URL to the API server - i.e. 'https://api.tinkercad.com'.
@class Environment
@static
@since 1.0.0
@markdown
**/
var Environment = function() {

    /**
     * Create the IMPL such that clients can't see it. Reference to the internal class.
     * @private 
     * @property {_Environment} _impl
     */
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Environment()
    });

    // Configure the default panic callback...
    var defaultPanicHandler = (function(env) {
        return function(str) {
            var elementId = env.getVariable(['host', 'elementId']);
            if (elementId) {
                var element = document.getElementById(elementId);
                if (element) {
                    var browser = BrowserDetector.detect();

                    if(browser){
                        element.innerHTML = browser.helpInfo;
                    }
                }
            }
            throw new Error(str);
        }
    })(this)
    this.setVariable(['callbacks', 'panic'], defaultPanicHandler);
};

Environment.prototype = {

    /** 
    Internal use only.  Not intended for use by clients.
    @method library
    @param {String} id
    @param {Number} version
    @private
    **/
    library: function(id, version){
        return this._impl.libraries[id] ? this._impl.libraries[id][version] : undefined;
    },

    /** 
    Internal use only.  Not intended for use by clients.
    @method libraryExports
    @param {String} id The unique identifier of the library.
    @param {Number} version The version of the library.
    @private
    **/
    libraryExports : function (id, version){
        var library = this.library(id, version);
        return library ? library.exports : undefined;
    },

    /** 
    Internal use only.  Not intended for use by clients.
    @method loadLibrary
    @private
    **/
    loadLibrary : function (library) {
        return this._impl.loadLibrary(this, library);
    },
    
    /**
    Searches through the existing libraries that are loaded for a particular library based 
    on some search criteria.
    @method findLibrary
    @param {Object} criteria Search criteria for the library to find. The fields are mutually exclusive
      @param {String} criteria.exportedSymbol The name of an exported symbol to look for - i.e. 'shapeGeneratorEvaluate'
    @return {Library}
    @private
    **/
    findLibrary: function(criteria){

        // Only support crteria.exportedSymbol match now
        var matchCriteria = function(exports, criteria) {

            if (criteria.exportedSymbol) {
                return exports.hasOwnProperty(criteria.exportedSymbol);
            }

            // Extend here for other criteria in future
            
            return false;
        }

        var candidates = [];

        for (var id in this._impl.libraries) {
 
            var revisions = this._impl.libraries[id];
            var revKeys = Object.keys(revisions);
            for (var i = 0; i < revKeys.length; i++) {

                // For each version
                var library = revisions[revKeys[i]];
                var exports = library.exports;

                if (matchCriteria(exports, criteria)) {
                    candidates.push(library);
                }

            }
        }

        if (candidates.length > 1) {
            console.error("Runtime: More than one library is found by findLibrary");
        } 
 
        if (candidates.length > 0) {
            // Return the first found library.
            return candidates[0];
        }

        return undefined;
    }, 

    /** 
    Internal use only.  Not intended for use by clients.
    @method module
    @private
    **/
    module : function (id) {
        return undefined;
    },

    /**
     Gets a previously defined variable given a location.
     @method getVariable
     @param {Array[String*]} keys An array of string identifiers indicating where the variable is stored at.
     @param {Object} [defaultValue] If there is currently no value set, this default value is set then returned.
     @return {Object|undefined} 
     @example
     var host = env.getVariable(['urls', 'api']);
     @example
     var someCustomVariableValue = env.getVariable(['somenamespace', 'someotherkey', 'somevariablename']);
     @since 1.0.0
     **/
    getVariable: function(keys, defaultValue) {
        var o = this._impl.variables[keys[0]];
        for (var i = 1; i < keys.length && o; i++) {
            o = o[keys[i]];
        }
        if ((undefined === o) && (undefined !== defaultValue)) {
            o = defaultValue;
            this.setVariable(keys, defaultValue);
        }
        return o;
    },

    /**
     Sets a variable given a location.  The implementation ultimately
     builds up an object so it's possible to erase multiple things based
     on structure.
     @method setVariable
     @param {Array[String*]} keys An array of string identifiers indicating where the variable is stored at.
     @param {Object} value Any value to set.  If the value is undefined, it removes the last altogether.
     @example
     env.setVariable(['urls', 'api'], 'https://api.tinkercad.com');
     @example
     env.setVariable(['somenamespace', 'someotherkey', 'somevariablename'], 'Variable Value');
     @since 1.0.0
     **/
    setVariable: function(keys, value) {
        var o = this._impl.variables;        
        for (var i = 0; i < keys.length - 1; i++) {
            var k = keys[i];
            var p = o[k];
            if (!p) {
                p = {};
                o[k] = p;
            }
            o = p;
        }
        if (undefined !== value) {
            o[keys[keys.length-1]] = value;
        } else {
            delete o[keys[keys.length-1]];
        }
    }
};
//library.js
var _Library = function(environment) {
	this.environment = environment;
};

/**
Information about a single resource included in a Library.
@json LibraryResourceJSON
@since 1.3.0
**/

    /**
    The unique identifier of the resource.  For example: 0bJDoIDggiy, bYyVFrCXD5e, vju4U4Sk30Y, etc.
    @property id
    @type {String}
    @readOnly
    **/

    /**
    The name of the resource.  For example: icon.png, styles.css, content.obj, etc.
    @property name
    @type {String}
    @readOnly
    **/

/**
A static object that represents the runtime instance of a Library, and provides some informational
and configuration capabilities to the Library developer.
@class Library
@static
@since 1.0.0
**/
var Library = function(environment, id, version) {

    /**
    The unique identifier of the library.
    @property id
    @type {String}
    @readOnly
    **/
    Object.defineProperty(this, 'id', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: id
    });

    /**
    The version of the library.  The initial version is 0.  Each time the library is published, the version is incremented by 1.
    @property version
    @type {Number}
    @readOnly
    **/
    Object.defineProperty(this, 'version', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: version
    });

    /**
    The name of the library.
    @property name
    @type {String}
    @readOnly
    @since 1.2.0
    **/

    /**
    The description of the library.
    @property description
    @type {String}
    @readOnly
    @since 1.2.0
    **/

    /**
    Information about the resources that are included in the library.
    @property resources
    @type {Array[LibraryResourceJSON]}
    @readOnly
    @since 1.3.0
    **/

    /**
    The exported functionality the library provides its clients.  A library developer can
    export functionality using this member.  This is the object a user receives
    as the Alias reference when referencing another library, or on the client side when using the
    require function on the Runtime.
    @property exports
    @type {Object[String,Object]}
    @readOnly
    @example
    var InternalObject = function() {
        // Class Implementation
    };
    Library.exports.ExportedObject = InternalObject;
    @see Runtime#require
    **/
    Object.defineProperty(this, 'exports', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: {}
    });

    /**
    @property {_Library} _impl
    @private
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Library(environment)
    });

};

Library.prototype = {

    /**
    Allows a library author to get a {File} instance of a resource file. 
    @method resourceFile
    @param {String} resourceId An Item ID (i.e. '1vxKXGNaLtr') or a Resource Filename (i.e. 'custom.css')
    @return {File} Instance of a File object
    @since 1.4.0
    @example
    var file = Library.resourceFile('custom.css');
    **/
    resourceFile: function(resourceId){

        var url = this.resourceURL(resourceId);
        var name = url.substring(url.lastIndexOf('/') + 1);
        return new File({url:url, name:name});
    },

    /**
    Allows a library author to get a public web-addressable URL for an item in the library.  If resourceId is not
    provided, then the base URL is returned, which can then be used to concatenate the Item ID or Resource Name
    onto at a later time when there are 2+ items to retrieve.  If the developer is trying to load an image, then
    it is suggested that they use {Library#imageURL} which handles a browser's devicePixelRatio properly.
    @method resourceURL
    @param {String} [resourceId] An Item ID (i.e. '1vxKXGNaLtr') or a Resource Filename (i.e. 'custom.css')
    @return {String} Public URL to the resource
    @since 1.0.0
    @see Library#imageURL
    @example
    var urlToCss = Library.resourceURL('custom.css');
    **/
    resourceURL: function(resourceId){

        var disconnected = this._impl.environment.getVariable(['disconnected', 'enabled']);

        // Check if this library supports disconnected mode.
        if(true === disconnected){
            var disconnectedLibraries = this._impl.environment.getVariable(['runtime', 'libraries'])||[];
            disconnected = false;
            for(var i=0; i<disconnectedLibraries.length; i++){
                if(disconnectedLibraries[i].id === this.id && disconnectedLibraries[i].version === this.version){
                    disconnected = true;
                    break;
                }
            }
        }

        if (true === disconnected) {

            var resourceName = this.id + '_' + this.version + '_' + resourceId;

            // First option is to check resource map
            var resourcesMap = this._impl.environment.getVariable(['resources', 'map']);
            if (resourcesMap) {
                var url = resourcesMap[resourceId] || resourcesMap[resourceName];
                if (url) {
                    return url;
                }
            }

            // Second option is to use the root path as the prefix to generate the url
            var root = this._impl.environment.getVariable(['resources', 'root']);
            return root + resourceName;

        } else {

            var apiurl = this._impl.environment.getVariable(['urls', 'api']);
            return apiurl + '/libraries/' + this.id + '/' + this.version + '/item/' + resourceId;

        }
    },

    /**
    This is a specialized version of {Library#resourceURL} which accomodates the browser's devicePixelRatio
    properly when used correctly.  For this API, the developer must name their resources such that the suffix
    corresponds to the file size.  For example:

    * thumbnail-32x32.jpg
    * thumbnail-64x64.jpg
    * icon16x16.png
    * icon32x32.png

    In this example, the method will do the following things:

    * First it will determine the browser's devicePixelRatio.  If it's 1:1 it will return the original filename, otherwise continue.
    * Next it will parse out the size from the resource - such as 32 (Width) by 32 (Height) from thumbnail-32x32.jpg
    * If the ratio is 2:1 for example, then it will check to see whether a 64 x 64 version of the image exists.
    * In this case it will find thumbnail-64x64.jpg and return the URL for it instead of thumbnail-32x32.jpg

    This responsive behavior is to accomodate devices such as the Retina Display Macbook.  The only naming requirement
    when using this API is that the filename must conform to this format: <anything><width>x<height>.<extension>
    @markdown
    @method imageURL
    @param {String} [resourceId] An Item ID (i.e. '1vxKXGNaLtr') or a Resource Filename (i.e. 'thumbnail-32x32.jpg')
    @return {String} Public URL to the resource
    @since 1.3.0
    @see Library#resourceURL
    @example
    var urlToImage = Library.imageURL('thumbnail-32x32.jpg');
    @example
    var urlToImage = Library.imageURL('icon16x16.png');
    **/
    imageURL: function(resourceId) {
        if(typeof resourceId !== 'string'){
            return undefined;
        }

        var dpr = 1;
        if(window && typeof window.devicePixelRatio === 'number'){
            dpr = window.devicePixelRatio;
        }
        if(dpr > 1){
            var regExp= /(([0-9]+)x([0-9]+))(\.[^.]+$)/;
            var match = regExp.exec(resourceId);
            if(match){
                var w = parseInt(match[2])*dpr;
                var h = parseInt(match[3])*dpr;
                var highResolutionResourceId=resourceId.replace(new RegExp(match[0]+'$'), w.toString()+'x'+h.toString()+match[4]);

                // Check resource map firstly
                var resourcesMap = this._impl.environment.getVariable(['resources', 'map']);
                if (resourcesMap) {
                    var resourceName = this.id + '_' + this.version + '_' + highResolutionResourceId;
                    var url = resourcesMap[highResolutionResourceId] || resourcesMap[resourceName];
                    if (url) {
                        // found, return it directly
                        return url;
                    }
                }

                // Then check the library resource manifest
                var resources = this.resources || [];
                for(var i = 0, tot = resources.length; i<tot; i++){
                    if(highResolutionResourceId === resources[i].name){
                        // found
                        resourceId=highResolutionResourceId;
                        break;
                    }
                }
            }
        }

        return this.resourceURL(resourceId);
    },

    /**
    Allows a library author to access the content of a resource as text, given the id of the resource.
    @method resourceText
    @param {String} resourceId An Item ID (i.e. '1vxKXGNaLtr') or a Resource Filename (i.e. 'custom.css')
    @param {Function(String)} callback A function that is called with the content of the resource once loaded.
    @since 1.0.0
    @async
    @example
    function shapeGeneratorEvaluate(params, callback) {
        Library.resourceText('Circle.svg', function(resourceContent) {
            var sketch = Conversions.toSketch2DFromSVG(resourceContent);
            var solid = Solid.extrude(sketch, 10.0);
            callback(solid);
        });
    }
    **/
    resourceText: function(resourceId, callback) {

        var onSuccess = function(response, textStatus, jqXHR) {
            callback(response);
        };

        var onError = function(response, textStatus, jqXHR) {
            callback(undefined);
        };

        var url = this.resourceURL(resourceId);

        if(!Host['creativePlatformRuntime']){
            callback(undefined);
            return;
        }

        Host['creativePlatformRuntime']._impl._ajax({
            url: url,
            type: "GET",
            dataType: "text",
            success: onSuccess,
            error: onError
        }
        );

    },

    /**
    Allows a library author to access the content of a resource as binary, given the id of the resource.
    @method resourceDataView
    @param {String} resourceId An Item ID (i.e. '1vxKXGNaLtr') or a Resource Filename (i.e. 'custom.css')
    @param {Function(DataView)} callback A function that is called with a view of the resource once loaded.
    @since 1.1.0
    @async
    @example
    function shapeGeneratorEvaluate(params, callback) {
        Library.resourceDataView('dolphin-binary.stl', function(dataView) {
            var mesh = Conversions.toMesh3DFromSTL(dataView);
            var solid = Solid.make(mesh);
            callback(solid);
        });
    }
    **/
    resourceDataView: function(resourceId, callback) {

        var onSuccess = function(response, textStatus, jqXHR) {
            if (response) {
                var dataView = new DataView(response);
                callback(dataView);
            }
        };

        var onError = function(response, textStatus, jqXHR) {
            callback(undefined);
        };

        if(!Host['creativePlatformRuntime']){
            callback(undefined);
            return;
        }

        var url = this.resourceURL(resourceId);
        Host['creativePlatformRuntime']._impl._ajax({
            url: url,
            type: "GET",
            dataType: "binary",
            success: onSuccess,
            error: onError
        }
        );
    }

};
//runtime.js
var LIBRARY_READY = 0;
var LIBRARY_RESOLVING_DEPENDENCIES = 1;
var LIBRARY_DOWNLOADING_SCRIPTS = 2;
var LIBRARY_READY_TO_LOAD = 3;
var LIBRARY_FAILED = 4;

var _Runtime = function() {

  this._creativePlatformEnvironment = new Environment();
  this._libraryStates = {};
  this._libraryDependencies = {};
  this._pendingCallbacks = [];
  this._creativePlatformEnvironment.setVariable(['urls', 'api'], 'https://api.tinkercad.com');

};

_Runtime.prototype = {

  _libraryKey: function(library) {
    return library.id + '-' + library.version;
  },

  _ajax: function (url, opts) {
    var req = null, options = {};
      if (typeof url === "object" ) {
        options = url;
        url = undefined;
      } else if(opts) {
        options = opts;
      }

      options.url = options.url || url;
      options.type = (options.type || 'GET').toUpperCase();
      options.dataType = options.dataType || 'text';
      if(options.success)
        options.success = options.success;
      if(options.error)
        options.error = options.error;
      options.retryOnError = options.retryOnError || false;
      options.retryDelay = options.retryDelay || 1000; //time in milliseconds
      options.retryTimeout = options.retryTimeout || 60000; //time in milliseconds

      if (options.dataType === 'script') {
          var se = document.createElement('script');
          se.setAttribute('type', 'text/javascript');
          se.async=true;
          se.src=options.url;
          if (options.success) { se.onload = options.success; }
          if (options.error) { se.onerror = options.error; }
          document.getElementsByTagName('head')[0].appendChild(se);
          return;
      }

      if (window.XMLHttpRequest) {
          req = new XMLHttpRequest();
      } else {
          req = new ActiveXObject("Microsoft.XMLHTTP");
      };

      if(options.headers) { //set custom headers if any
        for (var i = 0; i < options.headers.length; i++) {
          req.setRequestHeader(options.headers[i].header, options.headers[i].value);
        };
      }

      //setup the readystatechange listener
      req.onreadystatechange = function() {
          if (req.readyState === 4) { //got response from server
            var isSuccess = req.status >= 200 && req.status < 300 || req.status === 304, response = '';

              if(isSuccess) {
                if (req.status === 204) { //no content received from server
                  response = "nocontent";
                } else if (req.status === 304 ) { //not modified
                  response = "notmodified";
                } else {
                  var parse = {
                    'json': function () { //parse json
                      if (window.JSON && window.JSON.parse) {
                        return window.JSON.parse(this.responseText);
                      } else {
                        var responseTxt = this.responseText.replace(/^\s+|\s+$/g, '');
                        if (responseTxt) {
                          // Make sure the incoming data is actual JSON
                          // Logic borrowed from http://json.org/json2.js
                          if ( /^[\],:{}\s]*$/.test( responseTxt.replace(/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g, "@")
                            .replace(/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g, "]")
                            .replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
                            return (new Function("return " + responseTxt ))();
                          }
                        }
                        return {};
                      }
                    },
                    'xml': function () { //parse xml: implement
                      return this.responseText;
                    },
                    'text': function () { //raw text response
                      return this.responseText;
                    },
                    'binary': function() {
                      return this.response;
                    }
                  }

                  response = parse[options.dataType].apply(this, []);
                }
                options.success(response, req.status, req);
              } else {
                response = 'error';
                var retryTimeout = function () {
                  if(!options._retryStarttime) return false;
                  return (Date.now() - new Date(options._retryStarttime))/1000 >= (options.retryTimeout/1000) ? true : false;
                }
                if(options.retryOnError && req.status === 503 && !retryTimeout()) { //service unavailable
                   window.setTimeout(function() {
                    if(!options._retryStarttime) options._retryStarttime = Date.now(); //set on first retry
                    ajaxRequest(options);
                   }, options.retryDelay);
                } else options.error(req, req.status, response);
              }
          };
      };

      req.open(options.type,options.url,true);
      if (options.dataType == 'binary') {
          req.responseType = "arraybuffer";
      }
      req.send(options.data); //send post data if any
  },

  addPendingDependency: function(libraries, callbackOnSuccess, callbackOnFailure) {

    var callback = {
      libraries: libraries,
      onsuccess: callbackOnSuccess,
      onerror: callbackOnFailure,
      notified: false
    };
    this._pendingCallbacks.push(callback);

  },

  resolveLibrary: function(state) {

    // If it's failed or ready then no reason to recurse...
    if (state.status === LIBRARY_READY ||
        state.status === LIBRARY_FAILED) {
      return state.status;
    }

    // Figure out if we can load, which is true if
    // there are no children or all the children
    // have been loaded...
    var canLoad = (state.status === LIBRARY_READY_TO_LOAD);
    for (var i = 0; i < state.dependencies.length && canLoad; i++) {
      var library = state.dependencies[i];
      var key = this._libraryKey(library);
      var childState = this._libraryStates[key];
      var childStatus = this.resolveLibrary(childState);
      if (childStatus === LIBRARY_FAILED) {
        state.status = LIBRARY_FAILED;
        return state.status;
      } else if (childStatus !== LIBRARY_READY) {
        // Don't return though so we can keep loading any
        // libraries that are ready now...
        canLoad = false;
      }
    }

    // If we can load it then do so...
    if (canLoad) {
      var ssl = new Library(this._creativePlatformEnvironment,
                                       state.library.id,
                                       state.library.version);
      if (this._creativePlatformEnvironment.loadLibrary(ssl)) {
        state.status = LIBRARY_READY;
        state.exports = this._creativePlatformEnvironment.libraryExports(state.library.id, state.library.version);
      } else {
        state.status = LIBRARY_FAILED;
      }

    }
    return state.status;

  },

  resolveLibraries: function() {
    for (var k in this._libraryStates) {
      var state = this._libraryStates[k];
      this.resolveLibrary(state);
    }
  },

  evaluatePendingDependencies: function() {

    // First resolve the libraries so that the top-level
    // library status is correct and sufficient...
    this.resolveLibraries();

    // Now loop over the pending callbacks and see whether
    // we can notify them with a success or failure callback
    var inconclusiveCallbacks = [];
    for (var c = 0; c < this._pendingCallbacks.length; c++) {
      var callback = this._pendingCallbacks[c];
      var libraries = callback.libraries;
      var conclusive = true;
      var libraryExports = [];
      for (var l = 0; l < libraries.length; l++) {
        var library = libraries[l];
        var state = this._libraryStates[this._libraryKey(library)];
        if (undefined === state) {
          conclusive = false;
        } else if (state.status === LIBRARY_FAILED) {
          if (callback.onerror) {
            console.error('Runtime: Notifying client of require failure.')

            var panic = this._creativePlatformEnvironment.getVariable(['callbacks','panic']);
            if(panic){
              panic('Failed to load library (' + library.id + ') version (' + library.version + ')!');
            }

            callback.onerror();
          }
          callback.notified = true;
          break;
        } else if (state.status === LIBRARY_READY) {
          libraryExports.push(state.exports);
        } else {
          conclusive = false;
        }
      }
      if (conclusive) {
        if (!callback.notified) {
          if (callback.onsuccess) {
            console.log('Runtime: Notifying client of require success.')
            callback.onsuccess.apply(window, libraryExports);
          }
          callback.notified = true;
        }
      } else {
        inconclusiveCallbacks.push(callback);
      }
    }
    this._pendingCallbacks = inconclusiveCallbacks;
    return this._pendingCallbacks.length;

  },

  requestLibrary: function(library) {

    var key = this._libraryKey(library);
    var state = this._libraryStates[key];
    if (undefined === state) {

      // Mark the state...
      var state = {
        status: LIBRARY_RESOLVING_DEPENDENCIES,
        dependencies: [],
        library: library
      };
      this._libraryStates[key] = state;

      // Dependencies error handler...
      var ondependencieserror = (function (library, runtime) {
        return function(jqXHR, textStatus, error) {
          console.error('Runtime: Failed to download library dependencies for (' + library.id + ') version (' + library.version + ')');
          runtime._libraryStates[runtime._libraryKey(library)].status = LIBRARY_FAILED;
          runtime.evaluatePendingDependencies();
        };
      })(library, this);

      // Dependencies success handler...
      var ondependenciessuccess = (function (library, runtime) {
        return function(response, textStatus, jqXHR) {

          console.log('Runtime: Received dependencies for (' + library.id + ') version (' + library.version + ')');

          // Record the dependencies...
          var key = runtime._libraryKey(library);
          runtime._libraryStates[key].dependencies = response['libraries'];
          runtime._libraryStates[key].status = LIBRARY_DOWNLOADING_SCRIPTS;

          // Download all the dependent libraries...
          for (var i = 0; i < response['libraries'].length; i++) {
            var dependentLibrary = response['libraries'][i]
            runtime.requestLibrary(dependentLibrary);
          }

          // Library error handler...
          var onlibraryerror = (function (library, runtime) {
            return function(response, textStatus, jqXHR) {
              console.error('Runtime: Failed to download library script for (' + library.id + ') version (' + library.version + ')');
              runtime._libraryStates[runtime._libraryKey(library)].status = LIBRARY_FAILED;
              runtime.evaluatePendingDependencies();
            };
          })(library, runtime);

          // Library success handler...
          var onlibrarysuccess = (function (library, runtime) {
            return function(response, textStatus, jqXHR) {
              console.log('Runtime: Received library script for (' + library.id + ') version (' + library.version + ')');
              runtime._libraryStates[runtime._libraryKey(library)].status = LIBRARY_READY_TO_LOAD;
              runtime.evaluatePendingDependencies();
            };
          })(library, runtime);

          // Download the script for this library...
          var target = runtime._creativePlatformEnvironment.getVariable(['target']);
          var useMinified = runtime._creativePlatformEnvironment.getVariable(['resources', 'minified'], true);
          var endpoint = (useMinified ? '/library.min.js' : '/library.js');
          if (target) {
            endpoint = endpoint + "?target=" + target;
          }
          var url = runtime._creativePlatformEnvironment.getVariable(['urls', 'api']) + '/libraries/' + library.id + '/' + library.version + endpoint;
          runtime._ajax({
            url: url,
            type: "GET",
            dataType: "script",
            retryOnError: true,
            success: onlibrarysuccess,
            error: onlibraryerror
          });

        };
      })(library, this);

      var url = this._creativePlatformEnvironment.getVariable(['urls', 'api']) + '/libraries/' + library.id + '/' + library.version + '/dependencies';
      this._ajax({
        url: url,
        dataType: "json",
        type: "GET",
        retryOnError: true,
        success: ondependenciessuccess,
        error: ondependencieserror
      });

    }

  },

  _rpcSerializer: function () {
    return {
      parse: function (object) {
        var result = {};
        var keys = Object.keys(object);
        var keylength = keys.length;
        for(var i=0;i<keylength;i++) {
          var obj = object[keys[i]];
          if(typeof obj == 'string') {
            result[keys[i]] = JSON.parse(obj);
          } 
          else if (obj === undefined) {
            result[keys[i]] = null;
          }
          else {
            if(obj._dataView) {
              var blob;
              try {
                blob = new Blob([obj._dataView]);
              }
              catch (e) {
                if(e.name == 'InvalidStateError') {
                    blob = new Blob([obj._dataView.buffer]);
                }
              }
              obj.fileURL = URL.createObjectURL(blob);
              delete obj._dataView;
              result[keys[i]] = obj;
            }
          }
        }
        return result;
      },
      stringify: function (object, callback) {
        var result = {};
        var keys = Object.keys(object);
        var keylength = keys.length;
        var fileReads = [];

        for(var i=0;i<keylength;i++) {
          var obj = object[keys[i]];
          if(obj instanceof File) {
            var entry = {key: keys[i], value : obj};
            fileReads.push(entry);
          }
          else {
            result[keys[i]] = JSON.stringify(obj);
          }
        }

        var filereadlength = fileReads.length;
        if(filereadlength === 0) {
          callback(result);
          return;
        }

        var dataViewRead = function (name, obj, index) {
          return function (dataview) {
            var filejson = obj.toJSON();
            delete filejson.fileURL;
            filejson._dataView = dataview;
            result[name] = filejson;

            if(filereadlength === index + 1) {
              callback(result);
            }
          };
        };

        for(var i=0;i<filereadlength;i++) {
          var file = fileReads[i].value;
          var name = fileReads[i].key;
          file.readAsDataView(dataViewRead(name, file, i));
        }
      }
    };
  },

  /**
  Construct and return the easyXDM.Rpc object.
  It represents the communication channel between the current page and iframe page.
  @method _getRpc
  @since 1.1.0
  @private
  **/
  _getRpc: function(){
    if(!this._rpc){
      this._rpc = new easyXDM.Rpc({
                remote: this._creativePlatformEnvironment.getVariable(['urls', 'api']) + "/sandbox",
                lazy: false,
                props: {frameborder:"0",  width:"0", height:"0", tabindex:"-1", title:"empty", hidden: "true"
                        , style:{"position": "absolute", "top": "-2000px", "left": "0px", "display":"none"}}
            },
            {
                remote: { // Create the stub methods
                    executeInSandbox:{},
                    reloadInSandbox: {}
                },
                serializer: { parse: function (object) { return object; }, stringify: function(object) { return object; } }
            });
    }

    return this._rpc;
  },

  /**
  Loads a set of libraries and necessary dependencies, then calls a client-supplied success or failure callback based on the result.
  If successfull, the <code>callbackOnSuccess</code> will be invoked with one argument for each library requested, and the arguments provided will be equivalent to {Library#exports}.
  @method require
  @since 1.0.0
  @private
  **/
  _require: function(libraries, callbackOnSuccess, callbackOnFailure) {

    // Create the library dependency and evaluate it...
    this.addPendingDependency(libraries, callbackOnSuccess, callbackOnFailure);
    var remaining = this.evaluatePendingDependencies();
    if (remaining > 0) {

      // Okay there's still some dependencies so check to see whether everything
      // has been requested.  This will also take care of handling the callbacks
      // to the client when the files complete or fail to load.
      for (var i = 0; i < libraries.length; i++) {
        this.requestLibrary(libraries[i]);
      }

    }

  },

  /**
  Do the actual reload of library
  @method _require
  @since 1.0.0
  @private
  **/
  _reload: function(library, callbackOnSuccess, callbackOnFailure) {
    var key = this._libraryKey(library);
    var state = this._libraryStates[key];

    // If the library was tried to load before, then reload
    if (state) {
      delete this._libraryStates[key];
      this._require(library, callbackOnSuccess, callbackOnFailure);
    } else {
      if(callbackOnFailure){
        callbackOnFailure();
      }
    }

  },

  /**
  Do the actual execution of library
  @method _execute
  @since 1.0.0
  @private
  **/
  _execute: function(payload, onSuccess, onError){
    onSuccess = onSuccess || function(){};
    onError = onError || function(){};

    function processError(errdata, callback){
      if(callback){
        var result = {
          "error": {
              "exception" : {
                  "description": errdata
              }
          }
        };
        callback(result);
      }
    }

    var callbackOnSuccess = (function(creativePlatformEnvironment, payload){
        return function(){

            // Plugin.panic calls the onErrorCb(onError), so once that is called
            // we should avoid subsequent onError or onSuccess to be called
          var callbackExecuted = false;
          var onErrorCb = function(){
            if(!callbackExecuted){
              callbackExecuted = true;
              onError.apply(this, arguments);
            }
          };

          var onSuccessCb = function(){
            if(!callbackExecuted){
              callbackExecuted = true;
              onSuccess.apply(this, arguments);
            }
          };

          // Entry check
          if(!payload){
            processError("The payload is undefined", onErrorCb);
            return;
          }

          try {
            /*
            The format of the debugging data is like
            {
              "log": "log message\n",
              "debug": "P 1.000000 1.000000 1.000000 0.900000 0.250000 0.150000 1.000000\nL 3.000000 3.000000 3.000000 4.000000 4.000000 4.000000 0.900000 0.250000 0.150000 1.000000\n",
              "warning": "warning message\n",
              "error": "panic message\n"
            }
            */
            var collectDebugginInfo = function(){

              var info = {};

              // The panic message is the format like
              // "panic message\n"
              var panic = creativePlatformEnvironment.getVariable(['outcomes', 'panic']);
              if (panic){
                  console.log("Panic Exit: " + panic);
                  info.error = panic + '\n';
              }

              // Each log message is the string like
              // "log message\n"
              var logs = creativePlatformEnvironment.getVariable(['outcomes', 'logs']);
              if (logs && logs.length > 0){
                  info.log = logs.join('\n') + '\n';
              }

              // Each warning message is the string like
              // "warning message\n"
              var warnings = creativePlatformEnvironment.getVariable(['outcomes', 'warnings']);
              if (warnings && warnings.length > 0){
                  info.warning = warnings.join('\n') + '\n';
              }

              // Each debugging point is the string like
              // "P 1.000000 1.000000 1.000000 0.900000 0.250000 0.150000 1.000000\n"
              var points = creativePlatformEnvironment.getVariable(['outcomes', 'points']);
              if (points && points.length > 0){
                  var pointItems = [];
                  var item;
                  for(var k = 0, tot = points.length; k < tot; k++){
                      item = 'P ' + points[k].join(' ');
                      pointItems.push(item);
                  }
                  info.debug = pointItems.join('\n') + '\n';
              }

              // Each debugging line should be the string like
              // "L 3.000000 3.000000 3.000000 4.000000 4.000000 4.000000 0.900000 0.250000 0.150000 1.000000\n"
              var lines = creativePlatformEnvironment.getVariable(['outcomes', 'lines']);
              if (lines && lines.length > 0){
                  info.debug = info.debug || '';

                  var lineItems = [];
                  var item;
                  for(var k = 0, tot = lines.length; k < tot; k++){
                      item = 'L ' + lines[k].join(' ');
                      lineItems.push(item);
                  }
                  info.debug += lineItems.join('\n') + '\n';
              }

              // Each debugging triangles should be the string like
              // "T 5 7 3.000000 3.000000 3.000000 ... 1 2 3 ... 0.250000 0.150000 1.000000\n"
              var triangles = creativePlatformEnvironment.getVariable(['outcomes', 'triangles']);
              if (triangles && triangles.length > 0){
                  info.debug = info.debug || '';

                  var trianglesItems = [];
                  var item;
                  for(var k = 0, tot = triangles.length; k < tot; k++){
                      item = 'T ' + triangles[k].join(' ');
                      trianglesItems.push(item);
                  }
                  info.debug += trianglesItems.join('\n') + '\n';
              }

              return info;
            };

            // Set up the panic callback. The err object is optional
            creativePlatformEnvironment.setVariable(['callbacks', 'panic'], function(str, err) {

              var e = err? err : new Error(str);

              var info = collectDebugginInfo();
              info.error = str;
              info.stack = e.stack;
              info.exception = e.exception;
              var result = {
                  "status": 400,
                  "error": info
              };
              onErrorCb(result);
              return;
            });

            // Get the library to be executed.
            var executionLibrary = creativePlatformEnvironment.libraryExports(payload["id"], payload["version"]);
            if(!executionLibrary){
              processError("Failed to execute the library (" + payload["id"] + "," + payload["version"] + ")", onErrorCb);
              return;
            }

            // Get the specified execution method or use the old one so the test harness works...
            var executionMethod = payload["executionMethod"];
            var executionAsynchronous = payload["executionAsynchronous"];
            var executionScope = payload["scope"] || [];
            var executionTarget = executionLibrary;

            for (var i = 0; i < executionScope.length && executionTarget; i++) {
              var scope = executionScope[i];
              var scopeSymbol = scope['symbol'];
              if (scope['symbolIsMethod'] && ('function' === typeof executionTarget[scopeSymbol])) {
                executionTarget = executionTarget[scopeSymbol]();
              } else {
                executionTarget = executionTarget[scopeSymbol];
              }
              if (i == 0) {
                var proxy = creativePlatformEnvironment.getVariable(['proxies', scope['symbol']]);
                if (proxy) {
                  executionTarget = proxy(executionTarget);
                }
              }
            }

            if(executionTarget && 'function' !== typeof executionTarget[executionMethod]){
                processError("Missing execution method", onErrorCb);
                return;
            }

            // Add the environment variables to creativePlatformEnvironment.
            if(payload["environment"]){
              var env = payload["environment"];
              for(var v in env){
                  creativePlatformEnvironment.setVariable([v], env[v]);
              }
            }

            // Get the parameters by the passed in execution parameters.
            var executionParams = payload["executionParams"] || {};

            // The routine for processing the result...
            var processResult = function(result) {
              var executeResult = {};
              if (undefined !== result) {
                  if (result && (typeof result.toJSON === 'function')) {
                      executeResult = result.toJSON();
                  } else {
                      executeResult.output = result;
                  }
              }
              executeResult.info = collectDebugginInfo();
              onSuccessCb(executeResult);
            };

            if (executionAsynchronous) {

              var result;
              if (payload["executionParams"]) {
                result=executionTarget[executionMethod](executionParams, processResult);
              }
              else{
                result=executionTarget[executionMethod](processResult);
              }

              if (undefined !== result) {
                  var warnings = creativePlatformEnvironment.getVariable(['outcomes', 'warnings'], []);
                  var error = 'Unexpected value returned by ' + executionMethod + '(';
                  if (payload["executionParams"]) {
                      error += 'params, ';
                  }
                  error += 'callback).  The callback should be used for asynchronous functions.';
                  warnings.push(error);
              }

            } else {
              var result = executionTarget[executionMethod](executionParams);
              processResult(result);
            }

            return;

          } catch(e) {
              var panicHandler = creativePlatformEnvironment.getVariable(['callbacks', 'panic']);
              if (panicHandler){
                  panicHandler("Failed to execute the library", e);
              }

          }
        }
    })(this._creativePlatformEnvironment, payload);

    var callbackOnFailure = (function(payload){
      return function(){
        processError("Failed to load library ("+ payload['id']+ "," + payload['version'] + ")", onError);
      }
    })(payload);

    var lib = { id: payload['id'], version: payload['version'] };
    this._require([lib] , callbackOnSuccess , callbackOnFailure);

  }


};

/**
The Autodesk Creative Platform Runtime is onlyl accessible from the browser DOM member on the {Window}.
The Runtime is not accessible from within a Creative Platform Library.
@class Runtime
@since 1.0.0
@example
var runtime = window.creativePlatformRuntime;
**/
var Runtime = function() {

    /**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @property {_Runtime} _impl
    @private
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Runtime()
    });

    /**
    The environment for the runtime.
    @property {Environment} environment
    @readOnly
    **/
    Object.defineProperty(this, 'environment', {
        enumerable: false,
        configurable: false,
        value: this._impl._creativePlatformEnvironment
    });
};

Runtime.prototype = {

  /**
  Loads a set of libraries and necessary dependencies, then calls a client-supplied success or failure callback based on the result.
  If successfull, the <code>callbackOnSuccess</code> will be invoked with one argument for each library requested, and the arguments provided will be equivalent to {Library#exports}.
  @method require
  @since 1.0.0
  @param {Array[Object]} libraries An array of library-version descriptors, where the descriptor entries in the array have the following members:
    @param {String} libraries.id The unique ID of the library i.e. lPUtCWdT7Ni
    @param {Number} libraries.version Libraries can have multiple versions, so this specifies which version the caller wants
  @param {Function(Object*)} [callbackOnSuccess] A callback to use when all libraries are successfully loaded.  The number of arguments should be equal to the number of libraries in the libraries argument.
  @param {Function(Object)} [callbackOnFailure] A callback to use if the loading encounters problems.  No arguments are currently supplied.
  @async
  @see Library#exports
  @example
  var lib1 = { id: 'lPUtCWdT7Ni', version: 2 };
  var lib2 = { id: 'h5umhDTzkhs', version: 3 };
  window.creativePlatformRuntime.require([lib1, lib2],
    function (lib1Exports, lib2Exports) { console.log('Succeeded!'); },
    function () { console.log('Failed!'); });
  **/
	require: function(libraries, callbackOnSuccess, callbackOnFailure) {

    this._impl._require(libraries, callbackOnSuccess, callbackOnFailure);

	},

  /**
  Loads a library into the environment assuming the library is already required
  @method loadLibrary
  @since 1.2.0
  @param {Object} library The library-version descriptor, where the descriptor entry has the following members:
    @param {String} library.id The unique ID of the library i.e. lPUtCWdT7Ni
    @param {Number} library.version Libraries can have multiple versions, so this specifies which version the caller wants
  @return {Boolean}
  **/
  loadLibrary: function(library) {

      var lib = new Library(this.environment, library.id, library.version);
      if (this.environment.loadLibrary(lib)){
          return true;
      }
      return false;

  },

  /**
  Searches through the existing libraries that are loaded for a particular library based
  on some search criteria.
  @method findLibrary
  @since 1.2.0
  @param {Object} criteria Search criteria for the library to find. The fields are mutually exclusive
    @param {String} criteria.exportedSymbol The name of an exported symbol to look for - i.e. 'shapeGeneratorEvaluate'
  @return {Library}
  @experimental
  **/
  findLibrary: function(criteria){
      return this.environment.findLibrary(criteria);

  },

  /**
  Reloads a library, then calls a client supplied success or failure callback based on the result.
  If successfull, the <code>callbackOnSuccess</code> will be invoked with one argument for the library requested, and the arguments provided will be equivalent to {Library#exports}.
  If the library has not loaded to the client yet or the reload fails, the <code>callbackOnFailure</code> will be invoked.
  The reload work is done in the iframe sandbox.

  @method reload
  @since 1.1.0
  @param {Object} library The library-version descriptor, where the descriptor entries have the following members:
    @param {String} library.id The unique ID of the library i.e. lPUtCWdT7Ni
    @param {Number} library.version Libraries can have multiple versions, so this specifies which version the caller wants
  @param {Function(Object*)} [callbackOnSuccess] A callback to use when the library successfully loaded.
  @param {Function(Object)} [callbackOnFailure] A callback to use if the loading encounters problems.  No arguments are currently supplied.
  @async
  @see Library#exports
  @example
  var lib = { id: 'lPUtCWdT7Ni', version: 2 };
  window.creativePlatformRuntime.reload(lib,
    function (libExports) { console.log('Succeeded!'); },
    function () { console.log('Failed!'); });
  **/
  reload: function(library, onSuccess, onError){
    onSuccess = onSuccess || function(){};
    onError = onError || function(){};

    this._impl._getRpc().reloadInSandbox(library, onSuccess, onError);
  },


  /**
  Execute the specified library giving success and failure callbacks.
  The execution work is done in the iframe sandbox.
  @method execute
  @since 1.1.0
  @param {Object} payload Information about the method to execute
    @param {String} payload.id The {Library#id} of the library to execute.
    @param {Number} payload.version The {Library#version} of the library to execute.
    @param {String} payload.executionMethod The name of the method to execute.
    @param {Object} payload.executionParams The Key-Value dictionary of parameter values to pass to the method.
    @param {Boolean} [payload.executionAsynchronous] A boolean value indicating whether it's asynchronous.
    @param {Object} [payload.environment] Additional environment variable key-value pairs that will get inserted into the {Environment}.
    @param {Object} [payload.defaultIfMissing] If the execution method is not available, this defines the default value returned.
    @param {Array[Object]} [payload.scope] If the execution method is not located directly on {Library#exports} but instead located on a static or function, this allows the caller to specify the scope of the method.
    Each entry in the array has two members: symbol and symbolIsMethod if the symbol is a method.
  @param {Function} onSuccess A callback function when execution succeeds
  @param {Function} onError A callback function when execution fails
  @example
    {
        "id": "xxx",
        "version": 1,
        "executionMethod": "evaluate",
        "scope": [
          { "symbol": "shapeGenerator", "symbolIsMethod": true}
        ],
        "executionAsynchronous": true,
        "executionParams": {
            "height": 13
        },
        "environment": {
             "execution": { "scale": [1, 1, 1], "editorOpen": true}
        }
    }

  @example
    {
        "id": "xxx",
        "version": 1,
        "executionMethod": "evaluate",
        "scope": [
          { "symbol": "shapeConfigurator", "symbolIsMethod": true}
        ],
        "executionAsynchronous": true,
        "executionParams": {
            "shape": "xxx",
            "params": {
              "height": 13
            }
        },
        "environment": {
             "execution": { "scale": [1, 1, 1], "editorOpen": true}
        }
    }

    @example
    {
        "id": "xxx",
        "version": 1,
        "executionMethod": "evaluate",
        "scope": [
          { "symbol": "shapeModifier", "symbolIsMethod": true}
        ],
        "executionAsynchronous": true,
        "executionParams": {
            "instantces": [{"localToParent":[1,0,0,1....], "mesh":{"vertices":[1.0,1.0,0.0,...],"triangles":[0,1,2...]} }],
            "params": {
              "height": 13
            }
        },
        "environment": {
             "execution": { "scale": [1, 1, 1], "editorOpen": true}
        }
    }
  **/
  execute: function(payload, onSuccess, onError){
    onSuccess = onSuccess || function(){};
    onError = onError || function(){};
    if(payload && payload.executionParams) {
      var self = this;
      var isContext = false;
      var scope = payload.scope;
      if(scope && scope.length > 0){
        isContext = (scope[0].symbol === 'shapeConfigurator' || scope[0].symbol === 'shapeModifier');
      }
      if(isContext){
        // for configurator
        this.rpcSerializer().stringify(payload.executionParams.params, function (params) {
          delete payload.executionParams.params;
          self.rpcSerializer().stringify(payload.executionParams, function (executionParams) {
            executionParams.params = params;
            payload.executionParams = executionParams;
            self._impl._getRpc().executeInSandbox(payload, onSuccess, onError);
          });
        });
      }
      else{
        // for generator
        this.rpcSerializer().stringify(payload.executionParams, function (params) {
          payload.executionParams = params;
          self._impl._getRpc().executeInSandbox(payload, onSuccess, onError);
        });
      }

    } else {
      this._impl._getRpc().executeInSandbox(payload, onSuccess, onError);
    }
  },


  /**
  Check whether the library can execute by Runtime library
  @method canExecute
  @since 1.1.0
  @param {Object} library The library-version descriptor, where the descriptor entries have the following members:
    @param {String} library.id The unique ID of the library i.e. lPUtCWdT7Ni
    @param {Number} library.version Libraries can have multiple versions, so this specifies which version the caller wants
  @param {Function} callback A callback function that takes a boolean paramter indicating "can" or "can't" execute
  @async
  @example
  var lib = { id: 'lPUtCWdT7Ni', version: 2 };

  window.creativePlatformRuntime.canExecute(lib, function(can){
    if(can){
      ...
      window.creativePlatformRuntime.execute(payload, onSuccess, onError);
      ...
    } else {
      ...
    }
  });
  */
  canExecute: function(library, callback){
    if(typeof callback !== 'function') return;

    var onSuccess = function(response, textStatus, jqXHR) {
      var modules = response["modules"];
      if(!modules){
        callback(true);
        return;
      }

      for(var i = 0, l = modules.length; i<l;i++){
        if(modules[i].optional !== true){
          callback(false);
          return;
        }
      }
      callback(true);
    };

    var onError = function(response, textStatus, jqXHR) {
      callback(false);
    };

    var url = this.environment.getVariable(['urls', 'api']) + '/libraries/' + library.id + '/' + library.version + '/dependencies';
    this._impl._ajax({
      url: url,
      type: "GET",
      dataType: "json",
      success: onSuccess,
      error: onError
    });
  },

  /**
  Creates a {File} instance given the corresponding json
  @method createFile
  @since 1.3.0
  @param {Object} json Information required to create the {File} instance
  @return {File}
  @example
    {
        "url": "http://api.tinkercad.com/resources/public/a92skd23",
        "file": <FILE/BLOB>
    }
  **/
  createFile: function(json){
    return new File(json);
  },

  rpcSerializer: function () {
    return this._impl._rpcSerializer();
  }

};

//file.js

/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@private
@class _File
**/
var _File = function (fileparametervalue) {
    this._json = JSON.parse(JSON.stringify(fileparametervalue));
    this._url = fileparametervalue.url;
    this._fileURL = fileparametervalue.fileURL;
    this._regex = /\/[^\/^-]*-([^\/]*\.\w*)\/\d/;
    this._name = fileparametervalue.name;
    this._dataViewResponse = undefined;
    this._text = undefined;
};

_File.prototype = {

    _nameFromURL: function () {
        var match;
        if(this._url) {
            match = this._regex.exec(this._url);
            if(match && match.length > 1) {
                match = decodeURIComponent(match[1]);
            }
            else {
                match = this._url.substring(this._url.lastIndexOf('/') + 1);
                match = decodeURIComponent(match);
            }
        }
        return match;
    },

    _namefromFile: function () {
        return this._fileURL.substring(this._fileURL.lastIndexOf('#') + 1);
    },

    name: function () {
        if(!this._name) {
            if(this._fileURL) {
                this._name = decodeURIComponent(this._namefromFile());
            } else {
                this._name = decodeURIComponent(this._nameFromURL());
            }
        }
        return this._name;
    },

    _readURLAsDataView: function (callback, url) {
        if(this._dataViewResponse) {
            callback(new DataView(this._dataViewResponse));
            return;
        }

        url = url || this._url;

        var me = this;
        var onSuccess = function(response, textStatus, jqXHR) {
            if (response) {
                me._dataViewResponse = response;
                callback(new DataView(me._dataViewResponse));
            }
        };

        var onError = function(response, textStatus, jqXHR) {
            callback(undefined);
        };

        if(!Host['creativePlatformRuntime']){
            callback(undefined);
            return;
        }

        //Firefox seems to have a bug that sets the status to 0 even thought the response is valid in case of dataURLs
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function(e) {
            if (this.status == 200 || (this.status === 0 && this.response)) {
                onSuccess(this.response);
            } else {
                onError(this.response);
            }
        };
        xhr.send();
    },

    _readURLAsText: function (callback, url) {
        if(this._text) {
            callback(this._text);
            return;
        }

        url = url || this._url;

        var me = this;
        var onSuccess = function(response, textStatus, jqXHR) {
            me._text = response;
            callback(response);
        };

        var onError = function(response, textStatus, jqXHR) {
            callback(undefined);
        };

        if(!Host['creativePlatformRuntime']){
            callback(undefined);
            return;
        }

        //Firefox seems to have a bug that sets the status to 0 even thought the response is valid in case of dataURLs
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'text';
        xhr.onload = function(e) {
            if (this.status == 200 || (this.status === 0 && this.response)) {
                onSuccess(this.response);
            } else {
                onError(this.response);
            }
        };
        xhr.send();
    },

    _readLocalFileAsDataView: function (callback) {
        this._readURLAsDataView(callback, this._fileURL);
    },

    _readLocalFileAsText: function (callback) {
        this._readURLAsText(callback, this._fileURL);
    },

    readAsDataView: function (callback) {
        if(this._fileURL) {
            this._readLocalFileAsDataView(callback);
        } else {
            this._readURLAsDataView(callback);
        }
    },

    readAsText: function(callback) {
        if(this._fileURL) {
            this._readLocalFileAsText(callback);
        } else {
            this._readURLAsText(callback);
        }
    },

    toJSON: function () {
        var json = JSON.parse(JSON.stringify(this._json));
        if(json.url && json.url.length > 0) {
            delete json.fileURL;
        }
        return json;
    }
};

/**
Information about the input argument required to create an instance of the {{File}} object.
The input supports either a publically accessible url or a local file url. The local file url allows for faster access but has the limitations
of being accessible only within the same browser and domain.
Apart from these properties, the input may also have certain extra properties. These properties will be retained and returned when calling the toJSON method 
but will not affect the functioning of this class.
@json FileJSON
@since 1.4.0
**/

    /**
    The url at which the file can be accessed
    @property url
    @type {String}
    @readOnly
    **/

    /**
    The local file url created using URL.createObjectURL. This url is only accessible within the same browser and for the same domain.
    @property fileURL
    @type {String}
    @readOnly
    **/

    /**
    An optional name of the file. If the name is not provided, it will be retrieved from the URL.
    @property name
    @type {String}
    @optional
    **/

/**
Represents an abstraction of a user-supplied file.
@class File
@since 1.4.0
@constructor
@private
@param {FileJSON} fileparametervalue Input File JSON
**/
var File = function (fileparametervalue) {

    /**
    @property {_Library} _impl
    @private
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _File(fileparametervalue)
    });

    /**
    Represents the name of the file - i.e. Model.obj, Model.mtl, Model.jpg.
    This property is intended to be consistent with https://developer.mozilla.org/en-US/docs/Web/API/File.name.
    @markdown
    @property name
    @readonly
    @type String
    **/
    Object.defineProperty(this, 'name', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: this._impl.name()
    });
};

File.prototype = {

    /**
    This function allows the client to access the text in the file via an asynchronous callback.
    This is similar to the {Library#resourceText} for resources.  
    Comparable to https://developer.mozilla.org/en-US/docs/Web/API/FileReader.readAsText.
    @markdown
    @async
    @method readAsText
    @param {Function(String)} callback A function that is called with a view of the resource once loaded.
    **/
    readAsText: function (callback) {
        this._impl.readAsText(callback);
    },

    /**
    This function allows the client to access the binary data in the file via an asynchronous callback.
    This is similar to the {Library#resourceDataView} for resources.
    @markdown
    @async
    @method readAsDataView
    @param {Function(DataView)} callback A function that is called with a view of the resource once loaded.
    **/
    readAsDataView: function(callback) {
        this._impl.readAsDataView(callback);
    },

    /**
    Returns the JSON representation of the object that can be serialized.  
    The resulting JSON can be passed into the constructor later on to reconstruct the object.
    @method toJSON
    @return {JSON}
    **/
    toJSON: function() {
        return this._impl.toJSON();
    }
};


//footer.js
		Host.creativePlatformRuntime = new Runtime();

		/* This registers the deserializer for the shape generator parameter */
		Host.creativePlatformRuntime.environment.setVariable(['parameters', 'file', 'deserializer'], function(json) {
			if(json) {
				return (json instanceof File) ? json : new File(json);
			}
		});
	};

	// This is a special library so load it...
	creativePlatformLibrary1jiw9epElcKrev0(undefined, undefined);

})(typeof exports === 'undefined' ? window : exports);
//# sourceMappingURL=library.map

	/** <-- BEGIN SEQUENCING CODE **/
	var rt = exports.creativePlatformRuntime;
	rt.environment.setVariable(['disconnected', 'enabled'], true);
	rt.environment.setVariable(['resources', 'root'], './');
	var libraries = [];
	libraries.push({ 'id' : '1vxKXGNaLtr', 'version' : 0 });
	libraries.push({ 'id' : 'aZS9YbvfqUX', 'version' : 0 });
	libraries.push({ 'id' : 'c0HjtqUm7Wz', 'version' : 0 });
	libraries.push({ 'id' : '0vW3XxB8WwN', 'version' : 0 });
	libraries.push({ 'id' : 'aLVZT9dTtGG', 'version' : 0 });
	libraries.push({ 'id' : 'cTLKjc2L7R7', 'version' : 4 });

	rt.environment.setVariable(['runtime', 'libraries'], libraries);
	// The envVars is like {'key': [], 'value': {} }
	for (var i = 0; i < envVars.length; i++) {
		rt.environment.setVariable(envVars[i].key, envVars[i].value);
	}

	/** END SEQUENCING CODE --> **/

//header.js
/**
The Autodesk Core Library provides the Autodesk Creative Platform a broad and deep set of 2D and 3D capabilities.
The library is backwards-compatible with Tinkercad's original Shape Script specification.  
It is our intention to keep the library free of any dependencies to Tinkercad.com, and provide a neutral library that can benefit other products as well.
<h1>Units and Coordinates</h1>
<img src="{@ResourceUrl:coordinate-system.png}" style="float:right; padding:20px; margin-top:-40px;"/>
<p>All units are considered to be millimeters. The applications that use the Creative Platform present the underlying values to users based on their preferences.</p>
<p>A right-handed coordinate system used; X and Y axis are on ground plane; Z extends up.</p>
<h1>Getting Started</h1>
<ol>
	<li>Autodesk Creative Platform Shape Generator Tutorials<ul>
			<li>{Shape Generator Overview}</li>
			<li>{Heart Extrusion Generator} (Beginner)</li>
			<li>{Platonic Solid Generator - Part 1} (Intermediate)</li>
			<li>{Platonic Solid Generator - Part 2} (Advanced)</li></ul>
	</li>
	<li>Advanced<ul>
			<li>{How To Document Your Creative Platform Library}</li></ul>
	</li>
	<li>Where the Autodesk Creative Platform Is Used<ul>
			<li>{Tinkercad's Gen6 Geometry Kernel}</li></ul>
	</li>
</ol>
<h1>Runtime Capabilities</h1>
All Creative Platform Libraries also inherit capabilities from the runtime such as the {Runtime.Environment} and {Runtime.Library} statics.
The runtime allows developers to export functionality in their Creative Platform Libraries so other developers can piggyback on it, and also provides configuration and resource
management utilities for more advanced libraries.
@module 1vxKXGNaLtr
@main
**/
(function(Host){

	"use strict";

	// This list of methods is taken from the following URL
	// https://developer.mozilla.org/en-US/docs/Web/API/console
	var console = {
		dir: function() { },
		error: function() { },
		group: function() { },
		groupCollapsed: function() { },
		groupEnd: function() { },
		info: function() { },
		log: function() { },
		time: function() { },
		timeEnd: function() { },
		trace: function() { },
		warn: function() { }
	};

	var creativePlatformLibrary1vxKXGNaLtrrev0 = function(Environment, Library){
	    
	    var xml = Environment.module('libxmljs');

        // Prepare the exports for 3rd party Node.js libraries like tess2.min.js
        var module = { exports : {} };
//manifest.js
if (Library) {
	Library.name = "Autodesk Creative Platform Core";
	Library.description = "A broad and deep collection of 2D and 3D capabilities.";
	Library.resources = [
		{ "id": "5HOLk65hYHM", "name": "coordinate-system.png" }
		,{ "id": "aqswKA2Js3T", "name": "parameters.png" }
		,{ "id": "1Ljg7qh9Htg", "name": "cluster.png" }
		,{ "id": "4QkaJCDf4Nr", "name": "heart-from-canvas-flipped.png" }
		,{ "id": "68mj4nuVDoF", "name": "heart-from-canvas.png" }
		,{ "id": "2vFXsCHSe8E", "name": "customshape-category.png" }
		,{ "id": "37BkpbF00y8", "name": "cube-scripteditor.png" }
		,{ "id": "hQf8B2vTnJl", "name": "cube-twisted.png" }
		,{ "id": "gWtIZlhXWAG", "name": "cube.png" }
		,{ "id": "finmSeq29y0", "name": "customshape-scripteditor.png" }
		,{ "id": "kXvMrBkvNoO", "name": "dodecahedron-construction.png" }
		,{ "id": "dTpcHUm02yH", "name": "dodecahedron-debug-lines.png" }
		,{ "id": "l3ErqZsE910", "name": "icosahedron-scripteditor.png" }
		,{ "id": "f6qkzuAn2y6", "name": "matrix2.gif" }
		,{ "id": "6EbpqJbk3mZ", "name": "matrix2elements.gif" }
		,{ "id": "jLuUMPvxtvG", "name": "matrix2rotation.gif" }
		,{ "id": "honrGXc4E23", "name": "matrix3.gif" }
		,{ "id": "cW9G5w4CcBC", "name": "matrix3elements.gif" }
		,{ "id": "fL2nQccUud5", "name": "octahedron.png" }
		,{ "id": "dAXPZiN9Pzy", "name": "platonic-family-portrait.png" }
		,{ "id": "9zV30z4SvN9", "name": "platonics-2rows.png" }
		,{ "id": "4Ah9qJ8FCt8", "name": "pythagorean.gif" }
		,{ "id": "859QAaOn3Kd", "name": "scripteditor-examples-menu.png" }
		,{ "id": "g7MbBXP3cDP", "name": "sphere-lod1.png" }
		,{ "id": "2gKfcIjNPha", "name": "tetrahedron-editor-params.png" }
		,{ "id": "cM4B529Vgm2", "name": "tetrahedron-params.png" }
		,{ "id": "5W1bX8Vy3GB", "name": "tetrahedron.png" }
		,{ "id": "bTp5dwuGwii", "name": "bridge_boundaries_origin.png" }
		,{ "id": "khlYlzcmmMu", "name": "bridge_boundaries_result.png" }
		,{ "id": "0iySnPeGQBZ", "name": "debug_triangles.png" }
	];
}
//globals.js
// Any global variables for use internally could be defined here.
// Any enums we'd want to export publicly could also be done

var ERROR_ARGUMENTS_MESSAGE = 'Unexpected arguments. Please refer to documentation.';

function scaleExecutionParam(param){

	var scale = Environment.getVariable(['execution', 'scale']);
	// Adjust the param  based on scale.

    if(scale && Array.isArray(scale) && scale.length === 3){            
        var maxScale = 0.0;
        maxScale = (scale[0] > maxScale) ? scale[0] : maxScale;
        maxScale = (scale[1] > maxScale) ? scale[1] : maxScale;
        maxScale = (scale[2] > maxScale) ? scale[2] : maxScale;

        if (maxScale == 0.0)
            maxScale = 1.0;
        if (maxScale > 100.0)
            maxScale = 100.0;
        if (maxScale < 0.0001)
            maxScale = 0.0001;

        param /= maxScale;           
    }

    return param;
}

// Legacy weld threshold from Tinkercad
var weldThreshold = function(){
	var wt = Environment.getVariable(['execution', 'weldThreshold']);
	if (undefined === wt) { 
		wt = scaleExecutionParam(0.00001);
		Environment.setVariable(['execution', 'weldThreshold'], wt);
	}
	return wt;
}

// Legacy tesselation tolerance from Tinkercad
function tessTolerance(){
	var tt = Environment.getVariable(['execution', 'tessTolerance']);
	if (undefined === tt) { 
		tt = scaleExecutionParam(0.05);
		Environment.setVariable(['execution', 'tessTolerance'], tt);
	}
	return tt;
}

// Use the same precision as Autodesk Shape Manager, or other common geometric 
// kernels such as Spatial ACIS:
// http://doc.spatial.com/index.php/SPAresabs
// http://doc.spatial.com/index.php/Tutorial:ACIS_Tutorials_(Tolerances)
function resabs(n1, n2) {
	return (Math.abs(n1 - n2) < 1e-6);
}




// A global function to override toString, toLocaleString and toValue of the function definition.
// All exported classes should call this function,for example, Path2D, Mesh3D, Bezier2D, Line2D, etc. to conceal the internal implementations
function initializeObjectMethods(obj, displayName) { 
    if (typeof obj === 'function') {
        // To report the object name when TypeError happens
        // V8 uses the overridden toString to generate the error object name
        obj.prototype.toString = function(){
            return displayName;
        }
        // To avoid the code to be dumped
        obj.toString = function() { return ''; }
        obj.toLocaleString = function() { return ''; }
        obj.toValue = function() { return ''; }
    } else if (typeof obj === 'object') {
        // To report the object name when TypeError happens
        // V8 uses the overridden toString to generate the error object name
        obj.toString = function(){
            return displayName;
        }
    }
}

/**
A centrally located set of functions that provide import and export capabilities for popular file formats and conversion routines between data schemas.
@class Conversions
@since 1.1.0
@static
**/
var Conversions = {
};
Library.exports.Conversions = Conversions;
initializeObjectMethods(Conversions, 'Conversions');


// Get the exports variable in Node.js or browser envronment for 3rd party libs like Tess2.min.js
var thirdPartyExports = (typeof window === "undefined") ? module.exports : window;

//baseproxy.js
/**
This class is a layer between the developer's implementation of {IShapeGenerator|IShapeConfigurator|IShapeModifier} and the application.  
It provides some input and output validation, and handling the deserialization of JSON to objects like {Matrix3D}, {Sketch2D}, {Runtime.File}, {Shape}, etc.
@class BaseProxy
@private
**/
var BaseProxy = function(original, methods){
	/**
    @property {IShapeGenerator|IShapeConfigurator|IShapeModifier} _original
    @private
    **/
    this._original = original;

    // Only make the the members public if the original implemented them to avoid confusion:
    if(original && methods){
	    methods.forEach(function(name) {
	        if (original[name]) {
	        	if(!this['_' + name]){
	        		// Add the method to instance if it doesn't exist in prototype.
	            	this['_' + name] = function(){
						this._original[name].apply(this._original, arguments);
					}
	        	}
	        	
	        	this[name] = this['_' + name];
	        }
	    }, this);
    }

    /**
    Cache the parameter definitions.
    @property {Array[ParameterJSON*]} _parameterDefinitions
    @private
    **/
    this._parameterDefinitions = undefined;
};

BaseProxy.prototype = {
	_validateParameters: function(parameters) {

	    // The base attributes common to all parameters, with an indicator of whether they're required
	    var baseAttributes = {
	        'id': true,
	        'displayName': true,
	        'displayIcon': false,
	        'type': true,
	        'validate': false,
	        'invalid': false,
	        'visible': false,
	        'default': true
	    };

	    // Type specific attributes, with an indicator of whether they're required
	    var typeAttributes = {
	        'bool': { 'rangeMin' : false, 'rangeMax' : false, 'ticks' : false, 'steps' : false, 'displayValue' : false },
	        'int': { 'rangeMin' : false, 'rangeMax' : false, 'ticks' : false, 'steps' : false, 'displayValue' : false },
	        'float': { 'rangeMin' : false, 'rangeMax' : false, 'ticks' : false, 'steps' : false, 'displayValue' : false },
	        'length': { 'rangeMin' : false, 'rangeMax' : false, 'ticks' : false, 'steps' : false, 'displayValue' : false, 'displayUnit' : false },
	        'angle': { 'rangeMin' : false, 'rangeMax' : false, 'ticks' : false, 'steps' : false, 'displayValue' : false },
	        'list': { 'listValues' : true, 'listLabels' : false, 'listImages' : false , 'listClasses' : false, 'pageSize': false},
	        'sketch' : { },
	        'string' : { 'singleLine' : false, 'maxLength': false },
	        'file' : { 'accept': true, 'config': false, 'maxSize': false, 'default' : false }
	    };

	    // Merge the base and type attributes...
	    for (var k in typeAttributes) {
	        for (var l in baseAttributes) {
	            if (undefined === typeAttributes[k][l]) {
	                typeAttributes[k][l] = baseAttributes[l];
	            }
	        }
	    }

	    if (parameters instanceof Array) {
	        parameters.forEach(function(parameter) {
	            var attributes = typeAttributes[parameter['type']];
	            if (undefined === attributes) {
	                Plugin.panic("Unknown Parameter Type: [" + parameter['type'] + "].  Valid types are: " + Object.keys(typeAttributes));
	            } else {

	                // Verify all the required attributes...
	                for(var k in attributes) {
	                    if (true === attributes[k]) {
	                        if (undefined === parameter[k]) {
	                            Plugin.panic("Required Attribute [" + k + "] missing for parameter [" + (parameter['id'] || parameter['displayName']) + "]");
	                        }
	                    }
	                }

	                // Verify all parameter attributes are known (to catch misspellings or usage problems)
	                for (var k in parameter) {
	                    if (undefined === attributes[k]) {
	                        Plugin.panic("Unrecognized Attribute [" + k + "] defined for parameter [" + (parameter['id'] || parameter['displayName']) + "].  Valid attributes are: " + Object.keys(attributes));
	                    }
	                }
	            }
	        });
	    }
	},

	_deserializeParameters: function(definitions, parameters) {
	    definitions.forEach(function(definition) {
	        var deserializer = Environment.getVariable(['parameters', definition['type'], 'deserializer']);
	        if (deserializer) {
	            try {
	                parameters[definition['id']] = deserializer(parameters[definition['id']]);
	            } catch (e) {
	                Plugin.warning("A problem occurred while deserializing parameter [" + definition['id'] + "]");
	            }
	        }
	    });
	},

	_unpackParameters: function(parameters, callback) {
        // Unpack the parameters based on the parameter definitions but
        // cache the parameter definitions so we don't request them on
        // every mouse move when interacting on the client.
        if (this._original.parameters) {
            if (undefined === this._parameterDefinitions) {
                console.log("Fetching Parameter Definitions");
                var me = this;
                this._parameters(function(definitions) {
                    me._parameterDefinitions = definitions;
                    me._deserializeParameters(me._parameterDefinitions, parameters);
                    callback(parameters);
                })
            } else {
                console.log("Re-using Parameter Definitions");
                this._deserializeParameters(this._parameterDefinitions, parameters);
                callback(parameters);
            }
        } else {
            callback(parameters);
        }
    },

    // Define the proxy methods
    _parameters: function(callback) {
    	var me = this;
        me._original.parameters(function(results) {
            me._validateParameters(results);
            callback(results);
        });
    },
};

// Define the proxy methods
var proxyMethods = ['presets', 'evaluate', 'preview', 'validate', 'configuration', 'randomize'];
proxyMethods.forEach(function(name) {
		BaseProxy.prototype["_" + name] = function(){
			this._original[name].apply(this._original, arguments);
		}
    });

initializeObjectMethods(BaseProxy, 'BaseProxy');
//3rd.js
/**
This library implements CSG operations on meshes elegantly
and concisely using BSP trees, and is meant to serve as an
easily understandable implementation of the algorithm
@opensource csg.js
@websiteurl https://github.com/evanw/csg.js/
@downloadurl https://github.com/evanw/csg.js/archive/master.zip
@licenseurl https://github.com/evanw/csg.js/blob/master/LICENSE
@licensetext Copyright (c) 2011 Evan Wallace (http://madebyevan.com/)

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
@source csg.min.js
@symbols CSG
**/

/**
The tess2.js library performs polygon boolean operations and tesselation
to triangles and convex polygons. It is a port of libtess2, which is turn
is a cleaned up version of the stock GLU tesselator. The original code
was written Eric Veach in 1994. The greatest thing about tess2.js is that
it handles all kinds of input like self-intersecting polygons or any nomber
of holes and contours.
@opensource tess2.js
@websiteurl https://github.com/memononen/tess2.js
@downloadurl https://github.com/memononen/tess2.js/archive/master.zip
@licenseurl http://oss.sgi.com/projects/FreeB/
@source tess2.min.js
@symbols Tess2
**/

/**
canvg is a SVG parser and renderer. It takes a URL to a SVG file or the text of
an SVG file, parses it in JavaScript, and renders the result on a Canvas element
@opensource canvg
@websiteurl https://code.google.com/p/canvg/
@downloadurl https://code.google.com/p/canvg/downloads/detail?name=canvg-1.3.zip
@licenseurl https://code.google.com/p/canvg/source/browse/trunk/MIT-LICENSE.txt
@licensetext Copyright (c) 2010-2011 Gabe Lerner (gabelerner@gmail.com) - http://code.google.com/p/canvg/

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
@derivative svgparser.js
@symbols SvgParser
**/
//documentation.js
/**
This version represents the initial debut of Shape Scripts in Tinkercad.
A good article summarizing this release is here: http://blog.tinkercad.com/2012/10/12/tinkercad-launches-shape-scripts-api/.
@version 1.0.0
@released 2012-10-12T00:00:00Z
@markdown
**/

/**
This version represents the initial debut of Autodesk's Creative Platform.
With the release several new features such as Text and Sketch debuted for the first time.
A good article summarizing this release is here: http://blog.tinkercad.com/2013/12/19/sketch-and-text/.
@version 1.1.0
@released 2013-12-17T00:00:00Z
@markdown
**/

/**
This version was a point release that contained internal improvements but no API changes.
@version 1.1.1
@released 2014-01-01T00:00:00Z
@markdown
**/

/**
Introduced some experimental enhancements to the {Mesh3D} class and the ability to annotate it with attributes.
@version 1.2.0
@released 2014-03-07T00:00:00Z
@markdown
**/

/**
Introduced the ability to convert a {Mesh3D} to STL.
@version 1.3.0
@released 2014-04-10T00:00:00Z
@markdown
**/

/**
- Introduced the ability to implement a Shape Generator using an object-oriented approach via {IShapeGenerator}.
- Introduced the ability to convert a {Mesh3D} to binary STL.
- Introduced the APIs for conversion between ArrayBuffers and base64 ASCII stings.
- Removed @experimental tag from Conversions.toSTLFromMesh3D and renamed to {Conversions#toAsciiSTLFromMesh3D}.
@version 1.4.0
@released 2014-05-07T00:00:00Z
@markdown
**/

/**
- Added `id` support to {LayoutGroupJSON#id} and {LayoutGroupItemJSON#id}.
- Added `background` support to {LayoutGroupJSON#background}.
- Added support to position the 3D View with {LayoutGroupView3DJSON} and the `view3d` type for {LayoutGroupJSON#type}.
- Moved the `dock` attribute from {LayoutGroupJSON} to {LayoutGroupItemJSON}
- Added `fill` support to {LayoutGroupItemJSON#dock}.
- Changed the `layout` attribute on {ShapeGeneratorConfigurationJSON} from {Array[LayoutGroupJSON]} to {LayoutGroupJSON} to be more consistent.
- Removed ParameterConfigurationJSON to simplify things which also affected the following:
  - Removed `parameter` from {LayoutGroupItemParameterJSON}.  The {LayoutGroupItemJSON#id} field is now also used to identify the parameter.
  - Changed {RandomizerConfigurationJSON#parameters} to be an {Array[String]}.
@version 1.5.0
@released 2014-05-09T00:00:00Z
@markdown
**/

/**
- Added new {Box3D} and {Ray3D} classes.
- Added {Mesh3D#bounds} to get compute bounds of {Mesh3D}.
- Added new `IDebuggable` interface and added `debug` support for {Point2D}, {Point3D}, {Vector2D}, {Vector3D}, {Box2D} and {Box3D}.
- Added {Matrix3D#coordinateSystem} to set a transform based on a coordinate system.
- Added new {Creation} name space:
  - {Creation#extrude}: extrudes 2D geometry into a 3D mesh with more options.
- Added {Box2D#debug}, {Box2D#center} and {Box2D#clone} to {Box2D}.
- Added {Debug#show} and {Debug#triangles} methods to {Debug}.
- Added {Solid3D#toJSON} to output a custom JSON string.
- Changed the arguments of {IShapeGenerator#validate} to support information about the image map states.
@version 1.6.0
@released 2014-05-23T00:00:00Z
@markdown
**/

/**
- Renamed {MapKeyJSON#hover} from `highlight` for consistency with {MapKeyJSON#active}.
@version 1.7.0
@released 2014-06-10T00:00:00Z
@markdown
**/

/**
- Added {Mesh3D#clone} to clone a {Mesh3D} object.
- Added {Mesh3D#triangles} to get the indices of all the triangles within a {Mesh3D} object.
- Added `debug` support to {Mesh3D#debug}.
- Added boundary support to {Mesh3D}:
  - Added new {Mesh3DBoundary} class which represents a boundary within a {Mesh3D} object.
  - Added {Mesh3D#boundaries} and {Mesh3D#boundariesByTriangles} to compute boundaries of a {Mesh3D} Object.
- Added {Mesh3D#trianglesByTriangle} and {Mesh3D#trianglesByVertex} related to connectivity of the mesh.
- Added {Mesh3D#triangleByIndex} and {Mesh3D#vertexByIndex} to get triangle or vertex by index.
- Added {Selection}, {Mesh3DSelection} and {Selector} classes which are used for selection.
- Added new parameter type {Matrix3D} support in {Mesh3D#transform} and {Solid3D#transform}
@version 1.8.0
@released 2014-06-18T00:00:00Z
@markdown
**/

/**
- Made changes so that the {IShapeGenerator#preview} and {IShapeGenerator#evaluate} methods recieve real objects for parameters, rather than serialized JSON representations.
  - For example a {Sketch2D} object was received by the client as a serialized JSON representation, which had to be serialized and deserialized on both sides.
  - Now a Sketch2D object can be received directly without deserializing it in client code.
  - In the future when {Runtime.File} is available, it will be passed directly for file inputs, and eventually things like Colors, Matrices, Images, etc. could be passed directly.
- Changed the constructor of {Sketch2D} to accept another {Sketch2D} object.
- Added {MapKeyJSON#meshes} to indicate the highlighted meshes
- Added displayUnit, displayValue, steps and ticks properties on {LengthParameterJSON}, {AngleParameterJSON}, {IntegerParameterJSON} and {FloatParameterJSON}.
    - see {LengthParameterJSON#displayUnit}, {LengthParameterJSON#displayValue}, {LengthParameterJSON#steps}, {LengthParameterJSON#ticks}
@version 1.9.0
@released 2014-06-26T00:00:00Z
@markdown
**/

/**
- Added new {RefSet} class.
@version 1.10.0
@released 2014-07-03T00:00:00Z
@markdown
**/

/**
- Added {Path2D#clone} to clone a {Path2D} object.
- Added {Sketch2D#clone} to clone a {Sketch2D} object.
@version 1.11.0
@released 2014-07-10T00:00:00Z
@markdown
**/

/**
- Added {Vector3D#scale}.
- Added {Vector3D#subtract}.
- Added {Vector3D#add}.
- Added {Point3D#distanceTo}.
- Improved {Mesh3D#intersect}, {Mesh3D#unite}, {Mesh3D#subtract} to remove non-manifold edges in the result.
@version 1.12.0
@released 2014-07-24T00:00:00Z
@markdown
**/

/**
- Updated {Mesh3D#vertexByIndex} to have better performance
- Added {Vector3D#negate}.
- Added {Mesh3D#combineByBoundaries}.
- Added {Mesh3DSelection#expandByCoplanar}.
- Added {Sketch2D#projectBoundary}.
- Changed {ListParameterJSON#listImages}.
- Added {ParameterJSON#displayIcon}.
- Added {ListImageItem}.
@version 1.13.0
@released 2014-08-07T00:00:00Z
@markdown
**/

/**
- Added {StringParameterJSON#maxLength} to limit the number of character inputted.
@version 1.14.0
@released 2014-08-14T00:00:00Z
@markdown
**/

/**
- Supported parameter fontSize in the function {Conversions#toSketch2DFromText}.
- Updated the constructor of Sketch2D to accept an array of Path2D objects.
@version 1.15.0
@released 2014-09-04T00:00:00Z
@markdown
**/

/**
- Added {Mesh3D#toJSON}.
- Added {Matrix3D#toJSON}.
- Added new {Font} class
- Added {Sketch2D#combine}.
- Updated {Conversions#toSketch2DFromText} to accept Font object as a parameter.
@version 1.16.0
@released 2014-09-11T00:00:00Z
@markdown
**/
/**
- Added {Creation#emboss} for creating embossed or engraved mesh from 2D geometry.
- Added {WindingRule} enumeration
- Added property {Sketch2D#windingRule} to allow customzing the winding rule used to determine the interior region of a sketch.
- Added {ListParameterJSON#listClasses} to add extra css to list items.
- Added the ability for users to tesselate their own sketches and get boundary information.
- Updated {EventSource} constructor so a target could be specified for propagation to {Event#target}.
@version 1.17.0
@released 2014-10-16T00:00:00Z
@markdown
**/

/**
- Added {Mesh3D#trianglesByEdge} to get a list of triangles that are adjacent to the specified edge
- Updated {Mesh3D#transform} to fix a bug that the internal vertex set is not valid after transformation
@version 1.18.0
@released 2014-10-31T00:00:00Z
@markdown
**/

/**
- Added documentation support for Promise objects.
@version 1.19.0
@released 2014-12-03T00:00:00Z
@markdown
**/

/**
This describes the basic fields that are available for all parameters.  Depending on the parameter type
additional fields can also be specified as described in the notes below.
The value of parameters can be obtained through {IShapeGenerator#preview}, {IShapeGenerator#evaluate} or {IShapeGenerator#validate}.
@json ParameterJSON
**/

    /**
    The unique identifier for the parameter.
    @property id
    @type String
    @required
    **/

    /**
    The user-visible name of the parameter.
    If a displayIcon is provided, the displayName shows up as the tooltip on the displayIcon.
    @property displayName
    @type String
    @required
    **/

    /**
    The URL of the user-visible icon to be displayed for the parameter. Accepts a fully qualified URL of an image.
    To set the URL of a local resource added to the Library, see {Runtime.Library#imageURL}
    @property displayIcon
    @type String
    @optional
    @example
    params = [{
            "id" : "Name",
            "type" : "string",
            "displayIcon" : "http://domain/image.png",
            "default" : ""
        }]
    @example
    params = [{
            "id" : "Name",
            "type" : "string",
            "displayIcon" : Library.imageURL("image-16x16.png"),
            "default" : ""
        }]
    @since 1.13.0
    **/

    /**
    Indicates whether the parameter requires validation using {IShapeGenerator#validate} when modified.
    Custom validation allows more complex data types to be validated, as well as allowing validation to take
    the values of other parameters into consideration.
    @property validate
    @type Boolean
    @default false
    @optional
    @experimental
    @since 1.4.0
    **/

    /**
    During validation using {IShapeGenerator#validate}, if a parameter is not valid then the function
    can set this property to an error description that will be displayed to the user to explain why the value
    is not valid.
    @property invalid
    @type String
    @default ""
    @optional
    @experimental
    @since 1.4.0
    **/

    /**
    Indicates the type of the parameter, upon which additional properties can be configured.  The allowable
    values that are supported today are:
    <ul>
        <li><code>"angle"</code> : Refer to {AngleParameterJSON} for additional fields.</li>
        <li><code>"bool"</code> : Refer to {BooleanParameterJSON} for additional fields.</li>
        <li><code>"file"</code> : Refer to {FileParameterJSON} for additional fields.</li>
        <li><code>"float"</code> : Refer to {FloatParameterJSON} for additional fields.</li>
        <li><code>"int"</code> : Refer to {IntegerParameterJSON} for additional fields.</li>
        <li><code>"length"</code> : Refer to {LengthParameterJSON} for additional fields.</li>
        <li><code>"list"</code> : Refer to {ListParameterJSON} for additional fields.</li>
        <li><code>"sketch"</code> : Refer to {SketchParameterJSON} for additional fields.</li>
        <li><code>"string"</code> : Refer to {StringParameterJSON} for additional fields.</li>
    </ul>
    @property type
    @type String
    @required
    **/

    /**
    Allows the developer to control the visibility of the parameter.  This member can also be changed during
    the {IShapeGenerator#validate} callback.
    @property visible
    @type Boolean
    @default true
    @optional
    @experimental
    @since 1.6.0
    **/

/**
Indicates an angle. A degree symbol will be displayed next to the input. The value returned to the processing function will be in degrees.
The {ParameterJSON#type} must be set to "angle" for these additional properties to be configured.
@json AngleParameterJSON
@extends ParameterJSON
@example
var params = [
  {
    "id": "sweep",
    "displayName": "Sweep Angle",
    "type": "angle",
    "rangeMin": 0,
    "rangeMax": 360,
    "default": 270
  }
];
**/

    /**
    The default value for the parameter expressed in degrees.
    The value of this parameter when accessed through {IShapeGenerator#preview}, {IShapeGenerator#evaluate} or {IShapeGenerator#validate} will be the same type.
    @property default
    @type Number
    @required
    **/

    /**
    The minimum value for the parameter slider expressed in degrees (inclusive). Be aware however that currently
    users can still manually enter smaller values, so the processing code needs to safeguard against that scenario.
    @property rangeMin
    @type Number
    @default 0
    @optional
    **/

    /**
    The maximum value for the parameter slider expressed in degrees (inclusive). Be aware however that currently
    users can still manually enter larger values, so the processing code needs to safeguard against that scenario.
    @property rangeMax
    @type Number
    @default 1
    @optional
    **/

    /**
    This property allows the developer to specify where visual indicators appear for numberline tick marks.  This does not prevent a user from manually entering a value
    that does not coorespond with one of the predefined tick marks.
    @property ticks
    @type Array[Number]
    @optional
    @since 1.9.0
    **/

    /**
    When an array is supplied, it explicitly defines the allowable values for the input.  When a number is supplied, it identifies allowable values based on integer multiples of the number supplied, starting
    with {AngleParameterJSON#rangeMin}.
    @property steps
    @type Number|Array[Number]
    @default 1
    @optional
    **/

    /**
    Indicates whether the underlying parameter value should be displayed to the user.
    @property displayValue
    @type Boolean
    @default true
    @optional
    @since 1.9.0
    **/

/**
Indicates a boolean value (true or false).
The {ParameterJSON#type} must be set to "bool" for these additional properties to be configured.
@json BooleanParameterJSON
@extends ParameterJSON
@example
var params = [
  {
    "id": "pointed",
    "displayName": "Pointed",
    "type": "bool",
    "default": true
  }
];
**/

    /**
    The default value for the parameter.
    The value of this parameter when accessed through {IShapeGenerator#preview}, {IShapeGenerator#evaluate} or {IShapeGenerator#validate} will be the same type.
    @property default
    @type Boolean
    @required
    **/

/**
Indicates a unitless real value. Developers should use {LengthParameterJSON} or {AngleParameterJSON} instead when applicable.
The {ParameterJSON#type} must be set to "float" for these additional properties to be configured.
@json FloatParameterJSON
@extends ParameterJSON
@example
var params = [
  {
    "id": "symmetry",
    "displayName": "Symmetry",
    "type": "float",
    "rangeMin": -0.5,
    "rangeMax": 1.0,
    "default": 0.1
  }
];
**/

    /**
    The default value for the parameter.
    The value of this parameter when accessed through {IShapeGenerator#preview}, {IShapeGenerator#evaluate} or {IShapeGenerator#validate} will be the same type.
    @property default
    @type Number
    @required
    **/

    /**
    The minimum value for the parameter slider (inclusive). Users can still enter smaller values however, so the processing code needs to safeguard against that scenario.
    @property rangeMin
    @type Number
    @default 0
    @optional
    **/

    /**
    The minimum value for the parameter slider (inclusive). Users can still enter smaller values however, so the processing code needs to safeguard against that scenario.
    @property rangeMax
    @type Number
    @default 1
    @optional
    **/

    /**
    This property allows the developer to specify where visual indicators appear for numberline tick marks.  This does not prevent a user from manually entering a value
    that does not coorespond with one of the predefined tick marks.
    @property ticks
    @type Array[Number]
    @optional
    @since 1.9.0
    **/

    /**
    When an array is supplied, it explicitly defines the allowable values for the input.  When a number is supplied, it identifies allowable values based on integer multiples of the number supplied, starting
    with {FloatParameterJSON#rangeMin}.
    @property steps
    @type Number|Array[Number]
    @default 1
    @optional
    **/

    /**
    Indicates whether the underlying parameter value should be displayed to the user.
    @property displayValue
    @type Boolean
    @default true
    @optional
    @since 1.9.0
    **/

/**
Indicates a unitless integer value. Developers should use {LengthParameterJSON} or {AngleParameterJSON} instead when applicable.
@json IntegerParameterJSON
@extends ParameterJSON
@example
var params = [
  {
    "id": "sides",
    "displayName": "# Of Sides",
    "type": "int",
    "rangeMin": 3,
    "rangeMax": 30,
    "default": 5
  }
];
**/

    /**
    The default value for the parameter.
    The value of this parameter when accessed through {IShapeGenerator#preview}, {IShapeGenerator#evaluate} or {IShapeGenerator#validate} will be the same type.
    @property default
    @type Number
    @required
    **/

    /**
    The minimum value for the parameter slider (inclusive). Users can still enter smaller values however, so the processing code needs to safeguard against that scenario.
    @property rangeMin
    @type Number
    @default 0
    @optional
    **/

    /**
    The minimum value for the parameter slider (inclusive). Users can still enter smaller values however, so the processing code needs to safeguard against that scenario.
    @property rangeMax
    @type Number
    @default 1
    @optional
    **/

    /**
    This property allows the developer to specify where visual indicators appear for numberline tick marks.  This does not prevent a user from manually entering a value
    that does not coorespond with one of the predefined tick marks.
    @property ticks
    @type Array[Number]
    @optional
    @since 1.9.0
    **/

    /**
    When an array is supplied, it explicitly defines the allowable values for the input.  When a number is supplied, it identifies allowable values based on integer multiples of the number supplied, starting
    with {IntegerParameterJSON#rangeMin}.
    @property steps
    @type Number|Array[Number]
    @default 1
    @optional
    **/

    /**
    Indicates whether the underlying parameter value should be displayed to the user.
    @property displayValue
    @type Boolean
    @default true
    @optional
    @since 1.9.0
    **/

/**
A parameter that represents the length. Based on user preferences, it will be displayed as inches or millimeters. The value returned to processing function will always be in millimeters.
@json LengthParameterJSON
@extends ParameterJSON
@example
var params = [
  {
    "id": "radius",
    "displayName": "Radius",
    "type": "length",
    "rangeMin": 1,
    "rangeMax": 50,
    "default": 20
  };
];
**/

    /**
    The default value for the parameter expressed in millimeters.
    The value of this parameter when accessed through {IShapeGenerator#preview}, {IShapeGenerator#evaluate} or {IShapeGenerator#validate} will be the same type.
    @property default
    @type Number
    @required
    **/

    /**
    The minimum value for the parameter slider expressed in millimeters (inclusive). Users can still enter smaller values however, so the processing code needs to safeguard against that scenario.
    @property rangeMin
    @type Number
    @default 0
    @optional
    **/

    /**
    The maximum value for the parameter slider expressed in millimeters (inclusive). Users can still enter larger values however, so the processing code needs to safeguard against that scenario.
    @property rangeMax
    @type Number
    @default 1
    @optional
    **/

    /**
    This property allows the developer to specify where visual indicators appear for numberline tick marks.  This does not prevent a user from manually entering a value
    that does not coorespond with one of the predefined tick marks.
    @property ticks
    @type Array[Number]
    @optional
    @since 1.9.0
    **/

    /**
    When an array is supplied, it explicitly defines the allowable values for the input.  When a number is supplied, it identifies allowable values based on integer multiples of the number supplied, starting
    with {LengthParameterJSON#rangeMin}.
    @property steps
    @type Number|Array[Number]
    @default 1
    @optional
    **/

    /**
    Indicates whether the underlying parameter value should be displayed to the user.
    @property displayValue
    @type Boolean
    @default true
    @optional
    @since 1.9.0
    **/

    /**
    Allows the developer to force a particular unit of length to be displayed, regardless of user unit preferences.  This is often necessary when designs for things like Metric or English
    parts require a certain value such as bolt lengths or diameters.  The actual value of the parameter is always internally provided in millimeters, however the value presented to the user would
    be automatically converted to the appropriate value based on the unit.  The acceptable values for this property are:
    - ft (Foot)
    - in (Inch)
    - m (Meter)
    - cm (Centimeter)
    - mm (Millimeter)
    @markdown
    @property displayUnit
    @type String
    @default undefined
    @optional
    @since 1.9.0
    **/

/**
A json object to hold images for different states.
@json ListImageItem
@since 1.13.0
@unlisted
@see ListParameterJSON#listImages
**/

    /**
    An image for hover state.
    Accepts a fully qualified URL.
    @property hover
    @type String
    @default undefined
    @optional
    @since 1.13.0
    **/

    /**
    An image for active state.
    Accepts a fully qualified URL.
    @property active
    @type String
    @since 1.13.0
    **/

    /**
    An image for normal state.
    Accepts a fully qualified URL.
    @property normal
    @type String
    @since 1.13.0
    **/

/**
A list of labels or images presented to the user in a combobox and values that accompany them.  The {ListParameterJSON#listLabels} or {ListParameterJSON#listImages} field must be provided.
@json ListParameterJSON
@extends ParameterJSON
@example
var params = [
  {
    "id": "technique",
    "displayName": "Size Specifies",
    "type": "list",
    "listLabels": ["Radius", "Length of Apothem", "Length of Side"],
    "listValues": ["c", "a", "s"],
    "default": "c"
  }
];

@example
var params = [
  {
    "id": "diameter",
    "displayName": "Diameter",
    "type": "list",
    "listImages": ["http://domain/nominal.png", "http://domain/inside.png", "http://domain/outside.png"],
    "listClasses": ["css-nominal", "css-inside", "css-outside"],
    "listValues": ["n", "i", "o"],
    "default": "n"
  }
];

@example
//This example demonstrates how local resource images can be used within the listImages
var images = ["resource1.png", "resource2.png", "resource3.png"];
var listImages = [];
for(var i=0,len=image.length;i&lt;len;i++) {
    listImages.push(Library.imageURL(images[i]));
}

var params = [
  {
    "id": "diameter",
    "displayName": "Diameter",
    "type": "list",
    "listImages": listImages,
    "listValues": ["n", "i", "o"],
    "default": "n"
  }
];

@example
var params = [
  {
    "id": "diameter",
    "displayName": "Diameter",
    "type": "list",
    "listImages": [
        {
            "active": "http://domain/nominal_active.png",
            "hover": "http://domain/nominal_hover.png",
            "normal": "http://domain/nominal.png"
        },
        {
            "active": "http://domain/inside_active.png",
            "hover": "http://domain/inside_hover.png",
            "normal": "http://domain/inside.png"
        },
        {
            "active": "http://domain/outside_active.png",
            "hover": "http://domain/outside_hover.png",
            "normal": "http://domain/outside.png"
        }
    ],
    "listValues": ["n", "i", "o"],
    "default": "n"
  }
];

@example
var params = [
  {
    "id": "diameter",
    "displayName": "Diameter",
    "type": "list",
    "listImages": [
        {
            "active": Library.imageURL("first_active32x32.png"),
            "hover": Library.imageURL("first_hover32x32.png"),
            "normal": Library.imageURL("first_normal32x32.png")
        },
        {
            "active": Library.imageURL("second_active32x32.png"),
            "hover": Library.imageURL("second_hover32x32.png"),
            "normal": Library.imageURL("second_normal32x32.png")
        },
        {
            "active": Library.imageURL("third_active32x32.png"),
            "hover": Library.imageURL("third_hover32x32.png"),
            "normal": Library.imageURL("third_normal32x32.png")
        }
    ],
    "listValues": ["n", "i", "o"],
    "default": "n"
  }
];
**/

    /**
    The default value for the parameter, which corresponds to a key in {ListParameterJSON#listValues}.
    The value of this parameter when accessed through {IShapeGenerator#preview}, {IShapeGenerator#evaluate} or {IShapeGenerator#validate} will be the same type.
    @property default
    @type String|Number
    @required
    **/

    /**
    An array of values cooresponding to the {ListParameterJSON#listLabels} entries. Must contain the same number of elements that are in {ListParameterJSON#listLabels}.
    @property listValues
    @type Array[String|Number]
    @default []
    @required
    **/

    /**
    An array of user-visible strings that appear in a drop down box for the set of {ListParameterJSON#listValues} that is supplied.
    @property listLabels
    @type Array[String*]
    @optional
    **/

    /**
    An array of user-visible images that appear for the user to select from for the set of {ListParameterJSON#listValues} that is supplied.
    The values coorespond to fully qualified URLs, for example: "http://domain/image1.png", "http://domain/image2.png", etc. Or a {ListImageItem} having image names for different states.
    To know more about setting the URL of a local resource added to the Library, see {Runtime.Library#imageURL}
    @property listImages
    @type {Array[String*]|Array[ListImageItem*]}
    @optional
    @since 1.13.0
    **/

    /**
    An array of css classes corresponding to the {ListParameterJSON#listLabels} entries. Must contain the same number of elements that are in {ListParameterJSON#listLabels}.
    The values must be a valid css class name.
    @property listClasses
    @type {Array[String*]}
    @optional
    @since 1.17.0
    **/

    /**
    Specifies the maximum number of listImages that need to be shown in a single page. If the total number of images in the {ListParameterJSON#listImages} property are
    more than the pageSize, the control can generate a paging navigation. If this property is not set, all the images will be shown without any pagination.
    @property pageSize
    @type Number
    @optional
    @since 1.13.0
    **/

/**
A 2D sketch. Developers are encouraged to add SVG resources to their project and load them asynchronously to populate the defaults. The actual value is a {Sketch2D} object obtained from {Conversions#toSketch2DFromSVG}.
@json SketchParameterJSON
@extends ParameterJSON
@example
function shapeGeneratorDefaults(callback) {
  Library.resourceText('Circle.svg', function(resourceData) {
    var sketch2D = Conversions.toSketch2DFromSVG(resourceData);
    var params = [
      {
        "id": "sketch",
        "displayName": "Profile",
        "type": "sketch",
        "default": sketch2D
      }
    ];
    callback(params);
  });
}
**/

    /**
    It is a {Sketch2D} object constructed from the SVG resource file.
    @property default
    @type {Sketch2D}
    @required
    **/

/**
This is the definition of a parameter
@json StringParameterJSON
@extends ParameterJSON
@example
var params = [
  {
    "id": "equation",
    "displayName": "Z = f(x,y)",
    "type": "string",
    "default": "Math.cos(Math.sqrt(x * x + y * y))"
  }
];
**/

    /**
    The default value for the parameter.
    The value of this parameter when accessed through {IShapeGenerator#preview}, {IShapeGenerator#evaluate} or {IShapeGenerator#validate} will be the same type.
    @property default
    @type String
    @required
    **/

    /**
    A single-line text entry input is provided, rather than the default multi-line text area input.
    @property singleLine
    @type Boolean
    @default false
    @optional
    **/

    /**
    The upper limit number of characters that the text entry can accept.
    @property maxLength
    @type Number
    @optional
    **/


/**
This is the definition of a file input parameter. This is an asychronous-only parameter which means that the Parameter Processing has to use the Asynchronous approach
for this to work correctly.
The parameter should return a value of type {Runtime.File}
@json FileParameterJSON
@extends ParameterJSON
@proposed
@example
//An example of defining the file parameter synchronously.
params = [
    {
        "id": "image",
        "displayName": "Image",
        "type": "file",
        "accept": "image/*",
        "maxSize": 1048576
    }
];

@example
//To fetch a mask from a local resource, the asynchronous method of defining the parameters is required.
//This example also shows how a mask can be applied on a file parameter supporting images
function shapeGeneratorDefaults(callback) {
    Library.resourceText('Mask.svg', function(resourceData) {
        var sketch2D = Conversions.toSketch2DFromSVG(resourceData);
        var params = [
            {
                "id": "image",
                "displayName": "Image",
                "type": "file",
                "accept": "image/*",
                "maxSize": 1048576,
                "config" : {
                    "mask" : sketch2D
                }
            }
        ];
        callback(params);
      });
}

@example

// The File object returned by the file Parameter can be used to
// retrieve the contents of the file as text in this manner
function shapeGeneratorEvaluate(params, callback) {

    var file = params['file'];
    if(!file) { //Always check if a file has been selected before attempting operations
        //Create the mesh when a file is not selected.
        //A good option would be to use a default file as a placeholder prompting ther user to select a file
        file = Library.resourceFile('default.txt')
    }

    file.readAsText(function (text) {
        Debug.log('The file contents are - ' + text);
        //Create mesh
        var mesh = new Mesh3D();
        var solid = Solid.make(mesh);
        callback(solid);
    });
}

@example

// The contents can also be retrieved as a DataView
function shapeGeneratorEvaluate(params, callback) {

    var file = params['file'];
    if(!file) { //Always check if a file has been selected before attempting operations
        //Create the mesh when a file is not selected.
        //A good option would be to use a default file as a placeholder prompting ther user to select a file
        file = Library.resourceFile('default.png')
    }

    file.readAsDataView(function (dataview) {
        //Dataview operations
        //....
        //Create mesh
        var mesh = new Mesh3D();
        var solid = Solid.make(mesh);
        callback(solid);
    });
}

@example

// If the ShapeGenerator has the Canvas dependency, the Image class can also be leveraged to acess the file contents as an Image.
function shapeGeneratorEvaluate(params, callback) {

    var file = params['image'];
    if(!file) { //Always check if a file has been selected before attempting operations
        //Create the mesh when a file is not selected.
        //A good option would be to use a default file as a placeholder prompting ther user to select a file
        file = Library.resourceFile('default.png')
    }

    var image = Canvas.Image.loadFromFile(file, function (imagedata) {
        //Image data
        //Create mesh
        var mesh = new Mesh3D();
        var solid = Solid.make(mesh);
        callback(solid);
    });
}
**/

    /**
    Allows the client to restrict the types of files that can be supplied by the user.
    The value must conform to rules defined by https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#attr-accept.
    @markdown
    @property accept
    @type String
    @required
    **/

    /**
    Allows the client to configure the maximum file size allowed (inclusive) in bytes.
    For example, for a maximum size of 1MB this property would be configured to 1,048,576.
    @markdown
    @property maxSize
    @type Number
    @optional
    **/

    /**
    Allows the client to specify additionl configuration basing on the "accept" type. For example, for "image/*" type a {Sketch2D} object is set as the "mask"
    @markdown
    @property config
    @type {FileParameterConfigurationJSON}
    @optional
    **/

/**
Configures the additional configuration per each "accept" type
@json FileParameterConfigurationJSON
@proposed
**/

    /**
    Sets the mask to crop image for accept type "image/*". The scale of the Sketch2D converted from the SVG file is required in pixels.
    @property mask
    @type {Sketch2D}
    @optional
    **/


/**
Describes the configuration of the 3D view.
@json ViewConfigurationJSON
@since 1.4.0
@see ShapeGeneratorConfigurationJSON#view
**/

    /**
    Defines the global material to apply to all 3D geometry.
    @property material
    @type MaterialConfigurationJSON
    @optional
    **/

    /**
    A URL to an environment map image to use.
    @property environment
    @type String
    @optional
    **/

    /**
    Defines the camera settings.
    @property camera
    @type CameraConfigurationJSON
    @optional
    **/

    /**
    Defines the shading method. Right now 'flat' and 'smooth' are supported. 'flat' is the default one if it's not speficied.
    @property shading
    @type String
    @optional
    **/

/**
Configures the material.
@json MaterialConfigurationJSON
@since 1.4.0
@see ViewConfigurationJSON#material
**/

    /**
    The material id. Acceptable values are:
    <ul>
        <li><code>"red plastic"</code></li>
        <li><code>"red polished plastic"</code></li>
        <li><code>"white polished plastic"</code></li>
        <li><code>"black polished plastic"</code></li>
        <li><code>"white ceramic"</code></li>
        <li><code>"polished silver"</code></li>
        <li><code>"raw silver"</code></li>
    </ul>
    @property id
    @type String
    @required
    **/


/**
Configures the camera settings.
@json CameraConfigurationJSON
@since 1.4.0
@see ViewConfigurationJSON#camera
**/

    /**
    Define the camera view direction.
    @property direction
    @type Array[Number*]
    @optional
    **/

/**
Describes the layout of the parameters.
@json LayoutGroupJSON
@since 1.4.0
@see ShapeGeneratorConfigurationJSON#layout
**/

    /**
    The name of this group.  When nested in a parent group whose {LayoutGroupJSON#type} is configured as "tabs", this controls the tab name.
    @property name
    @type String
    @optional
    **/

    /**
    The globally unique identifier of this group.  If this group is contained within a parent {LayoutGroupItemJSON} this id will
    override the {LayoutGroupItemJSON#id} for the item.
    When the HTML for this particular item is generated, the element is guaranteed to have a suffix equivalent to the ID supplied.
    This allows designers to overlay CSS style sheets later on to have greater control over the layout provided CSS selectors are
    written with suffix matches rather than exact matches.  For example imagine the following HTML code:
    <pre class="prettyprint">
&lt;div&gt;
&#9;&lt;div id="div1_stop"&gt;Stop&lt;/div&gt;
&#9;&lt;div id="div2_slow"&gt;Slow&lt;/div&gt;
&#9;&lt;div id="div3_go"&gt;Go&lt;/div&gt;
&lt;/div&gt;
    </pre>
    In this case, "div1", "div2" and "div3" prefixes may have been provided to the element by the internal UI framework.
    However "stop", "slow" and "go" were IDs provided by the developer so that the resulting elements could be found.
    This permits some stylization customization using CSS selectors such as this:
    <pre class="prettyprint">
div[id$=stop] {
&#9;height: 40px;
}
    </pre>
    @property id
    @since 1.5.0
    @type String
    @optional
    **/

    /**
    The children of this particular group.
    @property children
    @type Array[LayoutGroupItemJSON*]
    @optional
    **/

    /**
    Configures the type of group, which affects how this group is presented to the user.  If not configured, it will simply be nested in the display.
    <ul>
        <li><code>"tabs"</code><p>Each child of this group is displayed as a tab, and the contents of a single child are displayed at any time.  Refer to {LayoutGroupTabsJSON} for additional fields.</p></li>
        <li><code>"map"</code><p>An interactive image map is used to navigate the children of this group, and the contents of a single child are displayed at any time.  Refer to {LayoutGroupMapJSON} for additional fields.</p></li>
        <li><code>"choice"</code><p>Allows clients to restrict the user input such that the parameters of any particular group are mutually exclusive from other groups.  Refer to {LayoutGroupChoiceJSON} for additional fields.</p></li>
        <li><code>"view3d"</code><p>Allows clients to configure where the 3D view goes. Refer to {LayoutGroupView3DJSON} for additional fields.</p></li>
    </ul>
    @property type
    @type String
    @optional
    **/

    /**
    A URL to a background image to use behind the group.
    @property background
    @type string
    @optional
    **/

/**
Describes the layout of the parameters.
@json LayoutGroupMapJSON
@since 1.4.0
@see LayoutGroupJSON#type
@extends LayoutGroupJSON
**/

    /**
    The configuration of the map to use.
    @property map
    @type MapConfigurationJSON
    @required
    **/

/**
Describes the layout of the parameters.
@json LayoutGroupChoiceJSON
@since 1.4.0
@see LayoutGroupJSON#type
@extends LayoutGroupJSON
**/

    /**
    Configure how the users's choice is communicated back.
    @property choice
    @type ChoiceConfigurationJSON
    @required
    **/

/**
Allows the client to configure the 3D View.
@json LayoutGroupView3DJSON
@since 1.5.0
@see LayoutGroupJSON#type
@extends LayoutGroupJSON
**/

    /**
    Contains the configuration data for the view.
    @property view
    @type ViewConfigurationJSON
    @required
    **/

/**
Describes the configuration of an image map that can be used to navigate a group's children.
@json MapConfigurationJSON
@since 1.4.0
@see LayoutGroupMapJSON#map
**/

    /**
    A URL to the default image to display to the user for the map.
    @property image
    @type String
    @required
    **/

    /**
    A URL to the color map for the default image that defines the different areas.
    @property map
    @type String
    @required
    **/

    /**
    A description of which colors in the {MapConfigurationJSON#map} coorespond to which nested groups.
    The item that is selected by default happens to be the first item in the array.
    @property legend
    @type Array[MapKeyJSON*]
    @required
    **/

/**
Associates different colors in the {MapConfigurationJSON#map} with alternate groups of items to be displayed when clicked.
@json MapKeyJSON
@since 1.4.0
@see MapConfigurationJSON#map
**/

    /**
    A color (i.e. "FF00CC") from the {MapConfigurationJSON#map} that this key configures.
    @property color
    @type String
    @required
    **/

    /**
    A URL to an alternate image to display when the user hovers over this region, that overrides the {MapConfigurationJSON#image}.
    @property hover
    @type String
    @required
    **/

    /**
    A URL to an alternate image to display when the user selects over this region, that overrides the {MapConfigurationJSON#image}.
    If no value is supplied then the {MapKeyJSON#hover} image will be shown.
    @property active
    @type String
    @optional
    @since 1.7.0
    **/

    /**
    A description of a group to display when the user clicks on the image while it's highlighted.
    @property group
    @type LayoutGroupJSON
    @required
    **/

    /**
    The mesh IDs that are interested by this map selection.
    These IDs are compared with the decorated attribute IDs of the mesh3D objects to find out the ones to highlight.
    @property meshes
    @type Array[String]
    @optional
    @since 1.9.0
    **/

/**
Describes the layout of the parameters.
@json LayoutGroupItemJSON
@since 1.4.0
@see LayoutGroupJSON#children
**/

    /**
    Describes where this item is docked in relation to the parent group.  Acceptable values are:
    <ul>
        <li><code>"left"</code><p>This item is docked to the left of the parent group.</p></li>
        <li><code>"right"</code><p>This item is docked to the right of the parent group.</p></li>
        <li><code>"top"</code><p>This item is docked to the top of the parent group.</p></li>
        <li><code>"bottom"</code><p>This item is docked to the bottom of the parent group.</p></li>
        <li><code>"fill"</code><p>This item is expanded to fill the space remaining in the parent group.</p></li>
    </ul>
    @property dock
    @type String
    @optional
    @since 1.5.0
    **/

    /**
    Configures the type of item which is one of the following:
    <ul>
        <li><code>"group"</code><p>This represents a group nested within a parent group.  Refer to {LayoutGroupItemGroupJSON} for additional fields.</p></li>
        <li><code>"parameter"</code><p>This represents that a parameter should be displayed to the user.  Refer to {LayoutGroupItemParameterJSON} for additional fields.</p></li>
        <li><code>"label"</code><p>This represents a simple text label to be displayed to the user.  Refer to {LayoutGroupItemLabelJSON} for additional fields.</p></li>
        <li><code>"randomizer"</code><p>This represents a quick way for the user to randomize a configurable set of parameters to quickly vary permutations.  Refer to {LayoutGroupItemRandomizerJSON} for additional fields.</p></li>
    </ul>
    @property type
    @type String
    @required
    **/

    /**
    Indicates whether a separator appears before this item to help enforce organization.
    @property separated
    @type Boolean
    @optional
    @default true
    **/

    /**
    A globally unique identifier for this element.
    This ID also manifests in the HTML and can be referenced in CSS sheets by designers to have greater control over the layout.
    Refer to {LayoutGroupJSON#id} for detailed information.
    @property id
    @type String
    @optional
    @since 1.5.0
    @see LayoutGroupJSON#id
    **/

/**
Indicates an item in a group that is a group.
@json LayoutGroupItemGroupJSON
@since 1.4.0
@see LayoutGroupItemJSON#type
@extends LayoutGroupItemJSON
**/

    /**
    The nested group.
    @property group
    @type LayoutGroupJSON
    @required
    **/

/**
Indicates an item in a group that is a parameter.  The {LayoutGroupItemJSON#id} member should coorespond to the ID of the parameter this item is for and must be the same.
@json LayoutGroupItemParameterJSON
@since 1.4.0
@see LayoutGroupItemJSON#type
@extends LayoutGroupItemJSON
**/


/**
Indicates an item in a group that is a label.
@json LayoutGroupItemLabelJSON
@since 1.4.0
@see LayoutGroupItemJSON#type
@extends LayoutGroupItemJSON
**/

    /**
    Configures the label that's displayed to the user.
    @property label
    @type LabelConfigurationJSON
    @required
    **/

/**
Indicates an item in a group that is randomizer.
@json LayoutGroupItemRandomizerJSON
@since 1.4.0
@see LayoutGroupItemJSON#type
@extends LayoutGroupItemJSON
**/

    /**
    Configures the randomizer that's displayed to the user.
    @property randomizer
    @type RandomizerConfigurationJSON
    @required
    **/

/**
Configures a Label.
@json LabelConfigurationJSON
@since 1.4.0
@see LayoutGroupItemLabelJSON#label
**/

    /**
    The text to display for the label.
    @property text
    @type String
    @required
    **/

    /**
    The font size for the label text.Acceptable values are:
    <ul>
        <li><code>"smaller"</code></li>
        <li><code>"small"</code></li>
        <li><code>"medium"</code></li>
        <li><code>"large"</code></li>
        <li><code>"larger"</code></li>
    </ul>
    @property fontSize
    @type String
    @optional
    **/

    /**
    An additional css style for the label. It must be a valid css class name(s).
    To add multiple css classes on label, add space between each class name. Example,
    <ul>
        <li><code>{"styleClass": "class1"}</code></li>
        <li><code>{"styleClass": "class1 class2 class3"}</code></li>
    </ul>
    @property styleClass
    @since 1.18.0
    @type String
    @optional
    **/

/**
Configures the parameters affected by a Randomizer.
@json RandomizerConfigurationJSON
@since 1.4.0
@see LayoutGroupItemRandomizerJSON#randomizer
**/

    /**
    Identifies the IDs of the parameters that should be randomized when clicking on the randomizer.
    @property parameters
    @type Array[String]
    @required
    **/

/**
Configures the player configuration
@json PlayerConfigurationJSON
@since 1.9.0
**/

    /**
    Sets the url for the ShapeGenerator specific CSS to be included for styling the Player.
    @property css
    @type String
    @optional
    **/

//xml.js
if(!xml &&  typeof window !== 'undefined'){
    /* Define the adaptors for the window.DOMParser classes.
     * SvgParser depends on the xml parser. The sample code below lists all the interfaces used inside the SvgParser.
     * window.DOMParser doesn't provide the compatible interfaces. So I add some adptor classes for them. In the adaptors, only the required ones are implemented.
        var xdoc = xmlParser.parseXml(svgString);
        var node = xdoc.root();
        node.name();
        node.childNodes()[0];
        node.attrs()[0];
        node.attrs()[0].name();
        node.attrs()[0].value();
     */

    // see http://www.w3schools.com/dom/dom_nodetype.asp
    var XMLNodeTypeEnum = {
        ELEMENT_NODE: 1,
        ATTRIBUTE_NODE: 2,
        TEXT_NODE: 3,
        CDATA_SECTION_NODE: 4,
        ENTITY_REFERENCE_NODE: 5,
        ENTITY_NODE: 6,
        PROCESSING_INSTRUCTION_NODE: 7,
        COMMENT_NODE: 8,
        DOCUMENT_NODE: 9,
        DOCUMENT_TYPE_NODE: 10,
        DOCUMENT_FRAGMENT_NODE: 11,
        NOTATION_NODE: 12
    };

    var XMLDocumentAdaptor = function (domDocument){
        this.domDocument = domDocument;
    };
    XMLDocumentAdaptor.prototype = {
        root: function(){
            if(this.domDocument.hasChildNodes()) {
                var childNodes = this.domDocument.childNodes;
                var child;
                for(var i=0; i<childNodes.length; i++ ){
                    child = childNodes[i];
                    if(child.nodeType === XMLNodeTypeEnum.ELEMENT_NODE){
                        return new XMLElementAdaptor(child);
                    }
                } 
            }
            return undefined;
        },

        get: function(xpath, nsuri){
            var xmlDoc = this.domDocument;
            var contextNode = this.domDocument;
            var result = xmlDoc.evaluate(xpath, contextNode, function(prefix){
                    return nsuri;
                }, XPathResult.ANY_TYPE, null);
            var elem = result.iterateNext();
            if(elem){
                return new XMLElementAdaptor(elem);
            }
            else{
                return undefined;
            }
        },

        toString: function(){
            if(XMLSerializer){
                return (new XMLSerializer()).serializeToString(this.domDocument);
            }
            else{
                return "";
            }
        }
    };

    var XMLNamespaceAdaptor = function (nsuri){
        this.nsuri = nsuri;
    };
    XMLNamespaceAdaptor.prototype = {
        href: function(){
            return this.nsuri;
        }
    };

    var XMLElementAdaptor = function (domElement){
        this.domElement = domElement;
    };
    XMLElementAdaptor.prototype = {

        name: function(){
            return this.domElement.nodeName;
        },
        type: function() {
            var t = XMLNodeTypeEnum;

            // See https://github.com/polotek/libxmljs/blob/master/src/xml_node.cc
            // XmlNode::get_type()
            switch (this.domElement.nodeType) {
            case t.ELEMENT_NODE:
                return "element";
            case t.ATTRIBUTE_NODE:
                return "attribute";
            case t.TEXT_NODE:
                return "text";
            case t.CDATA_SECTION_NODE:
                return "cdata";
            case t.ENTITY_REFERENCE_NODE:
                return "entity_ref";
            case t.ENTITY_NODE:
                return "entity";
            case t.PROCESSING_INSTRUCTION_NODE:
                return "pi";
            case t.COMMENT_NODE:
                return "comment";
            case t.DOCUMENT_NODE:
                return "document";
            case t.DOCUMENT_TYPE_NODE:
                return "document_type";
            case t.DOCUMENT_FRAGMENT_NODE:
                return "document_frag";
            case t.NOTATION_NODE:
                return "notation";
            }

            return "";
        },
        childNodes: function(){
            var children = [];
            var domChildren = this.domElement.childNodes;
            for(var i = 0, tot = domChildren.length; i < tot; i++){
                children.push(new XMLElementAdaptor(domChildren[i]));
            }

            return children;
        },
        attrs: function(){
            var attributes = [];
            var domAttributes = this.domElement.attributes;
            for(var i = 0, tot = domAttributes.length; i < tot; i++){
                attributes.push(new XMLEAttributeAdaptor(domAttributes[i]));
            }

            return attributes;
        },
        attr: function(){
            if (arguments.length === 1) {
                var arg = arguments[0];
                if (typeof arg === 'object') {
                    // object setter
                    // iterate keys/value to set attributes
                    for (var k in arg) {
                        this.domElement.setAttribute(k, arg[k]);
                    };
                    return this;
                } else if (typeof arg === 'string') {
                    // getter
                    return this.domElement.getAttribute(arg);
                }
            } else if (arguments.length === 2) {
                // 2 arg setter
                var name = arguments[0];
                var value = arguments[1];
                this.domElement.setAttribute(name, value);
                return this;
            }
        },

        /// helper method to attach a new node to this element
        /// @param name the element name
        node : function(name) {
            var xmlDoc = this.domElement.ownerDocument;
            var elem = xmlDoc.createElement(name);
            this.domElement.appendChild(elem);
            return new XMLElementAdaptor(elem);
        },

        addChild : function(elemAdaptor) {
            this.domElement.appendChild(elemAdaptor.domElement);
            return this;
        },

        // In the DOM, everything is a node. The text of an element is stored in a child node.
        text: function() {
            if(arguments.length === 0){
                // getter
                return this.domElement.textContent;
            }
            else{
                // setter
                this.domElement.textContent = arguments[0].toString();
                return this;
            }
        },

        namespace: function(){
            var nsuri = this.domElement.namespaceURI;
            return new XMLNamespaceAdaptor(nsuri);
        },

        get: function(xpath, nsuri){
            var xmlDoc = this.domElement.ownerDocument;
            var contextNode = this.domElement;
            var result = xmlDoc.evaluate(xpath, contextNode, function(prefix){
                    return nsuri;
                }, XPathResult.ANY_TYPE, null);
            var elem = result.iterateNext();
            if(elem){
                return new XMLElementAdaptor(elem);
            }
            else{
                return undefined;
            }
        }
    };

    var XMLEAttributeAdaptor = function (domAttribute){
        this.domAttribute = domAttribute;
    };
    XMLEAttributeAdaptor.prototype = {
        name: function(){
            return this.domAttribute.name;
        },
        value: function(){
            return this.domAttribute.value;
        }
    };

    var XMLParserAdaptor = function(){
        this.domParser = null;

        if (window && window.DOMParser){
            this.domParser = new window.DOMParser();
        }
    }
    XMLParserAdaptor.prototype = {
        parseXml : function(str){
            if(this.domParser){
                str = str.replace(/<!DOCTYPE svg[^>]*>/, '');
                var domDocument = this.domParser.parseFromString(str, 'text/xml');
                return new XMLDocumentAdaptor(domDocument);
            }
            else{
                return undefined;
            }
        }
    }

    xml = new XMLParserAdaptor();
}
//debug.js
/**
An interface that objects can implement to support {Debug#show}.
@interface IDebuggable
@since 1.6.0
**/
var IDebuggable = function() {
};

IDebuggable.prototype = {
    /**
    Instructs the object to present useful debugging information via a series of calls to {Debug#point}, {Debug#line} and {Debug#triangles}.
    @method debug
    @required
    **/
    debug: function() {
    }
};


/** 
Internal / Private data for namespace.  This is not exported so clients can not find it or use it.
@class _Debug
@static
@private
**/
var _Debug = { 

     /** 
     Cache the log strings in the string array in the form of ['log 1', 'log 2', ...]
     @private
     @property {Array} _logBuffer
     **/
    _logBuffer : Environment.getVariable(['outcomes', 'logs'], []),
    
    /** 
    Cache the debugging points in the array in the form of [[x, y, z, r, g, b, a], ...]
    @private
    @property {Array} _pointBuffer
    **/
    _pointBuffer : Environment.getVariable(['outcomes', 'points'], []),
    
    /** 
    Cache the debugging lines in the array in the form of [[sx, sy, sz, ex, ey, ez, r, g, b, a], ...]
    @private
    @property {Array} _lineBuffer
    **/
    _lineBuffer : Environment.getVariable(['outcomes', 'lines'], []),

    /** 
    Cache the debugging triangles in the array in the form of [[nv, nt, x, y, z, ..., 1, 2, 3, ..., r, g, b, a], ...]
    @private
    @property {Array} _trianglesBuffer
    **/
    _trianglesBuffer : Environment.getVariable(['outcomes', 'triangles'], []),
    
    /** 
    Define the current color applying to the debugging lines and points.
    The default color is the same as the default value of TinkerCAD.
    @private
    @property {Array} _currentColor
    **/
    _currentColor : [0.900000, 0.250000, 0.150000, 1.00000],
    
    /** 
    Set the color. Each color value is between 0 and 1. If the passed in color value is less than 0, it will be set to be 0. 
    If the passed in color value is greater than 1, it will be set to be 1.
    @private
    @method _setColor
    @param {Array} cArray The array denotes color in the form of [r, g, b, a]
    @chainable
    **/
    _setColor:function(cArray){        
        if(Array.isArray(cArray) && cArray.length === 4){       
            var currentColor = this._currentColor;
            
            var v = 0;
            for (var i = 0, tot = cArray.length; i < tot; i++) {
                v = cArray[i];
                v = v < 0 ? 0 : v;
                v = v > 1 ? 1 : v;
                currentColor[i] = v;
            }
        }
        
        return this;
    },
    
    /** 
    Add a new line. An array [sx, sy, sz, ex, ey, ez, r, g, b, a] which represents a line is added to the line buffer.
    @private
    @method _addLine
    @param {Array[Number]} vArray The array denotes the start and end points in the form of [sx, sy, sz, ex, ey, ez]
    @chainable
    **/
    _addLine: function(vArray){
        if(Array.isArray(vArray) && vArray.length === 6){            
            var line = vArray.concat(this._currentColor); 
            this._lineBuffer.push(line);
        }
        
        return this;
    },
    
    /** 
    Add a new point. An array [x, y, z, r, g, b, a] which represents a point is added to the point buffer.
    @private
    @method _addPoint
    @param {Array[Number]} vArray The array denotes the pointin the form of [x, y, z]
    @chainable
    **/
    _addPoint: function(vArray){
        if(Array.isArray(vArray) && vArray.length === 3){            
            var point = vArray.concat(this._currentColor); 
            this._pointBuffer.push(point);
        }
        
        return this;
    },
    
    /** 
    Add the log string to the buffer.
    @private
    @method _addLog
    @param {String} str The log string.
    @chainable
    **/
    _addLog: function(str) {
    
        this._logBuffer.push(str);
        
        return this;
    },
    
    /** 
    Add triangles to the buffer.
    @private
    @method _addTriangles
     @param {Array[Number]} vertices An array of points to use for the vertices of the triangles.
     @param {Array[Number]} indices An array of indices of the triangles.
    @chainable
    **/
    _addTriangles: function(vertices, indices) {
        var nverts = vertices.length;
        var ntris = indices.length;
        var item = [nverts, ntris];
        for(var i = 0; i < nverts; i++) {
            item.push(vertices[i]);
        }
        for(var i = 0; i < ntris; i++) {
            item.push(indices[i]);
        }
        for(var i = 0, ncolors = this._currentColor.length; i < ncolors; i++) {
            item.push(this._currentColor[i]);
        }
        this._trianglesBuffer.push(item);        
        return this;
    },

    /** Check if there is illegal number member in the array.
    @private
    @method _hasNaN
    @param {Array} vArray
    @return {Boolean} Returns false if the passed in argument is not an array or all the array members are legal numbers.
    **/
    _hasNaN: function(vArray){
        if(!Array.isArray(vArray)){            
            return false;
        }
        
        for (var i = 0, tot = vArray.length; i < tot; i++) {
            if(isNaN(vArray[i])){
                return true;
            }
        }
        
        return false;
    }    
};


/** 
When a Creative Platform Library runs, it is executed remotely in the cloud where it has access to the computing resources of a large cluster of server computers. When everything is going as expected, your script will only need to return the 3D solid it has generated.
In error situations and for debugging purposes, you may need to send back some other data as well. These functions allow you to return data from your Creative Platform Library back to the app.
@class Debug
@since 1.0.0
@static
**/
var Debug = {     

     /** 
     Set the color for the visualized debugging lines and points. Once you change the color, the color will apply to all the new created debugging lines and points. 
     The previous lines and points are not affected.
     @method color
     @since 1.0.0     
     @param {Array[Number]} args Various permutations of arguments are allowed. Define the color with r, g, b, a. The value ranges are [0,1]. The alpha value is optional and default to 1.0. Please see the examples for usage.
     @chainable 
     @example

     // Define the color with r, g, b, a:
     Debug.color(0.5, 0.6, 0.2, 0.8);

     @example

     // Define the color with r, g, b:
     Debug.color(0.5, 0.6, 0.2);

     @example

     // Define the color with [r, g, b, a]:
     Debug.color([0.5, 0.6, 0.2, 0.8]);
      
     @example

     // Define the color with [r, g, b]:
     Debug.color([0.5, 0.6, 0.2]);

     */
    color: function() {
        
        // 1. Populate an array in the form of [r, g, b, a]
        var cArray = undefined;
        
        switch(arguments.length){
        case 1: // (cArray)
            var tempArray = arguments[0];
            if(Array.isArray(tempArray) && (tempArray.length === 3 || tempArray.length === 4)){
                cArray = tempArray;
            }
            break;
        case 3: // (r, g, b)
        case 4: // (r, g, b, a)
            cArray = Array.prototype.slice.call(arguments);
            break;
        default:
            break;
        }
        
        // 2. Check the array members to make sure they are all numbers.
        if(cArray && !_Debug._hasNaN(cArray)){
            if(cArray.length === 3){
                cArray.push(1.0); // The alpha is not specified. Set it to be 1 by default.
            }
            // 3. This is a valid color, set it.             
            _Debug._setColor(cArray);
        }
        
        return this;
    },

     /** 
     Prints the string str into the printout list in the script editor.
     You can use this method to inspect the state of your script when it's being executed.
     @method log
     @since 1.0.0
     @param {String} str The log string.
     @chainable
     */
    log: function(str) {
        if(str && typeof str.toString === 'function'){
            _Debug._addLog(str.toString());
        }
        
        return this;
    },

     /** 
     Creates a debugging line from the point start to the point end.
     The line is displayed in the editor when the Autodesk Creative Platform Library Editor is open. You can use debugging lines to visualize values in 3D space.
     @method line
     @since 1.0.0
     @param {Array[Number]} args Various permutations of arguments are allowed.  Please see the examples for usage.
     @chainable 
     @example

     // Define a line by passing in 6 numbers 
     // cooresponding to the X, Y and Z values of 
     // 2 points:
     Debug.line(0, 0, 0, 1, 0, 0);

     @example

     // Define a line by passing in 2 arrays 
     // containing 3 numbers each, cooresponding 
     // to the X, Y and Z:
     Debug.line([0, 0, 0], [1, 0, 0]);

     @example

     // Define a line by passing in 1 array 
     // containing 6 numbers cooresponding to 
     // the X, Y and Z values of 2 points:
     Debug.line([0, 0, 0, 1, 0, 0]);

     */
     line: function() {
    
        // 1. Populate an array in the form of [sx, sy, sz, ex, ey, ez]
        var vArray = undefined;
        
        switch(arguments.length){
        case 1: // (vArray)
            var tempArray = arguments[0];
            if(Array.isArray(tempArray) && tempArray.length === 6){
                vArray = tempArray;
            }
            break;
        case 2: // (start, end)
            var start = arguments[0];
            var end = arguments[1];
            if(Array.isArray(start) && start.length === 3 && Array.isArray(end) && end.length === 3){
                vArray = start.concat(end);                
            }
            break;
        case 6: // (sx, sy, sz, ex, ey, ez)
            vArray = Array.prototype.slice.call(arguments);
            break;
        default:
            break;
        }
        
        // 2. Check the array members to make sure they are all numbers.
        if(vArray && !_Debug._hasNaN(vArray)){
            // 3. This is a valid line, add it.
            _Debug._addLine(vArray);
        }

        return this;         
     },

     /** 
     Allows the developer to visualize any object that implements the {IDebuggable} for diagnostic or debugging purposes.
     @method show
     @since 1.6.0
     @param {IDebuggable} item An object to diagnose.
     @chainable 
     **/
     show: function(item) {
        if(item && (typeof item.debug == 'function')) {
            item.debug();
        }
        return this;
     },

    /** 
    Displays a set of triangles in 3D space for diagnostic or debugging purposes.  Triangles should be specified in counter-clockwise winding order.
    The triangles are only displayed when the Autodesk Creative Platform Library Editor is open, so end users will not see it.

    How to use:

            var showTriangleList = function() {
                var triangleList = [
                    10, -10, 0,
                    30, -10, 0,
                    30, 10, 0,    
                    30, 10, 0,
                    10, 10, 0,
                    10, -10, 0    
                ];
                Debug.triangles(triangleList);
            };

            var showIndexedTriangles = function() {
                var vertices = [
                    40, -10, 0,
                    60, -10, 0,
                    60, 10, 0,
                    40, 10, 0    
                ];  
                var indices = [
                    0, 1, 2,
                    2, 3, 0
                ];  
                Debug.triangles(vertices, indices);
            };

            Debug.color(0, 0, 255);
            showTriangleList();
            Debug.color(255, 0, 0);
            showIndexedTriangles();

    Result:

    ![debug_triangles]({@ResourceUrl:debug_triangles.png})

    @method triangles
    @since 1.6.0
    @param {Array[Number]|Array[Point3D]} vertices An array of points to use for the vertices of the triangles.
    @param {Array[Number]} [indices] An optional set of indices that can be used
    @markdown
    @chainable 
    */
    triangles: function(vertices, indices) {
    var nverts = vertices.length;
    if(vertices && nverts > 0) {
        indices = indices || [];
        if(vertices[0] instanceof Point3D) {
            var verts = [];
            for(var i = 0; i < nverts; i++) {
                var vert = vertices[i];
                verts.push(vert.x, vert.y, vert.z);                    
            }
            _Debug._addTriangles(verts, indices);

        } else {
            _Debug._addTriangles(vertices, indices);
        }
    }
    return this;
    },

     /** 
     Displays a point in 3D space for diagnostic or debugging purposes.  
     The point is only displayed when the Autodesk Creative Platform Library Editor is open, so end users will not see it.  
     @method point
     @since 1.0.0
     @param {Array[Number]} args Various permutations of arguments are allowed.  Please see the examples for usage.
     @chainable 
     @example

     // Define a point by passing in 3 numbers 
     // cooresponding to the X, Y and Z:
     Debug.point(0, 1, 0);

     @example

     // Define a point by passing in i array 
     // containing 3 numbers cooresponding 
     // to the X, Y and Z:
     Debug.point([0, 1, 0]);

     **/
    point: function() {

        // 1. Populate an array in the form of [x, y, z]
        var vArray = undefined;
        
        switch(arguments.length){
        case 1: // (vArray)
            var tempArray = arguments[0];
            if(Array.isArray(tempArray) && tempArray.length === 3){
                vArray = tempArray;
            }
            break;        
        case 3: // (x, y, z)
            vArray = Array.prototype.slice.call(arguments);
            break;
        default:
            break;
        }
        
        // 2. Check the array members to make sure they are all numbers.
        if(vArray && !_Debug._hasNaN(vArray)){
            // 3. This is a valid point, add it.
            _Debug._addPoint(vArray);
        }
        
        return this;
    }
};

// Create the IMPL such that clients can't see it
Object.defineProperty(Debug, '_impl', {
       writable: false,
       enumerable: false,
       configurable: false,
       value: _Debug
});

/*
 * Export it for public use
 */
Library.exports.Debug = Debug;
initializeObjectMethods(Debug, 'Debug');

//winding.js
/**
The winding order of a 2D path.
@enum WindingOrder
@static
@proposed
**/

    /**
    Clockwise winding order.
    @default 1
    @type Number
    @property Clockwise
    @readonly
    @proposed
    **/

    /**
    Counter Clockwise winding order.
    @default 2
    @type Number
    @property CounterClockwise
    @readonly
    @proposed
    **/

    /**
    Unknown winding order. The winding order of a path can be unknown if it is not closed or not having a dominant winding order.
    @default 0
    @type Number
    @property Unknown
    @readonly
    @proposed
    **/

/**
The Winding Rule determines how overlapping sketch geometry is handled during tesselation.  For more detailed background information refer to the following articles:
1. http://www.glprogramming.com/red/chapter11.html
2. https://www.opengl.org/sdk/docs/man2/xhtml/gluTessProperty.xml
@see Creation#extrude
@see Creation#emboss
@see Sketch2D#windingRule
@see Tess#boundariesFromCountours
@see Tess#polygonsFromBoundaries
@markdown
@enum WindingRule
@static
@since 1.17.0
**/
var WindingRule = {
	
	/**
	Event-Odd winding rule. The interior of a geometry are regions with odd winding numbers.
    @default 0
    @type Number
    @property EvenOdd
    @readonly
    **/
	EvenOdd: 0,

	/**
	Non-Zero winding rule. The interior of a geometry are regions with non-zero winding numbers.
    @default 1
    @type Number
    @property NonZero
    @readonly
    **/
	NonZero: 1,	

	/**
	Positive winding rule. The interior of a geometry are regions with positive winding numbers.
    @default 2
    @type Number
    @property Positive
    @readonly
    **/
	Positive: 2,

	/**
	Negative winding rule. The interior of a geometry are regions with negative winding numbers.
    @default 3
    @type Number
    @property Negative
    @readonly
    **/
	Negative: 3,

	/**
	Winding rule AbsGreaterOrEqualTwo. The interior of a geometry are regions with winding numbers whose absolute values are greater than or equal to two.	
    @default 4
    @type Number
    @property AbsGreaterOrEqualTwo
    @readonly
    **/
	AbsGreaterOrEqualTwo: 4

};

// Expose WindingRule for public use
initializeObjectMethods(WindingRule, 'WindingRule');
Library.exports.WindingRule = WindingRule;
//mesh3d.js


/**
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _Mesh3D
@private
**/
var _Mesh3D = function() {

    /**
    The vertices list
    @private
    @property _vertices
    **/
    this._vertices = [];

    /**
    The triangle bases on the vertex index
    @private
    @property _triangles
    **/
    this._triangles = [];

    /**
    A helper structure to speed up the vertex look up
    @private
    @property _vertexSet
    **/
    this._vertexSet = {};

};

_Mesh3D.prototype = {

    /**
    Private function for generating the hash key for vertex
    @private
    @property _hash
    **/
    _hash: function(x, y, z) {

        var ics = 1/weldThreshold();
        // '#' is needed to distinguish the cases (10, 10, 10) and (101, 0, 10);
        return  Math.floor(x * ics + 0.5) + '#' +
                Math.floor(y * ics + 0.5) + '#' +
                Math.floor(z * ics + 0.5);

    },

    /**
    Private function for adding the vertex
    @private
    @property _addVertex
    **/
    _addVertex: function(x, y, z) {

        var hash = this._hash(x, y, z);
        var idx = this._vertexSet[hash];
        if (undefined === idx) {
            this._vertices.push(x, y, z);
            idx = this._vertices.length/3 - 1;
            this._vertexSet[hash] = idx;
        }
        return idx;
    },

    /**
    Get the bounds of the mesh triangles.
    @private
    @property _bounds
    @return {Array}
    **/
    _bounds: function() {
        var vertices = this._vertices;
        var xmin = Number.MAX_VALUE;
        var ymin = Number.MAX_VALUE;
        var zmin = Number.MAX_VALUE;
        var xmax = -Number.MAX_VALUE;
        var ymax = -Number.MAX_VALUE;
        var zmax = -Number.MAX_VALUE;

        var x,y,z;
        for (var i = 0, tot = vertices.length/3; i < tot; i++) {
            x = vertices[3*i];
            y = vertices[3*i+1];
            z = vertices[3*i+2];

            if (x < xmin) {
                xmin = x;
            } else if (x > xmax) {
                xmax = x;
            }

            if (y < ymin) {
                ymin = y;
            } else if (y > ymax) {
                ymax = y;
            }

            if (z < zmin) {
                zmin = z;
            } else if (z > zmax) {
                zmax = z;
            }
        }

        var bounds = undefined;
        if (xmin < xmax && ymin < ymax && zmin < zmax){
            bounds = [xmin, ymin, zmin, xmax, ymax, zmax];
        }
        return bounds;
    },


    /*
    Calculate the normal of the specified triangle by index
    @private
    @method _triangleNormal
    @return {Array} the x, y, z values of the normal
    */
    _triangleNormal: function(triangles, vertices, idx) {

        var foffset = 3*idx;
        var v1Offset = 3*triangles[foffset  ];
        var v2Offset = 3*triangles[foffset+1];
        var v3Offset = 3*triangles[foffset+2];

        var v1x = vertices[v1Offset  ];
        var v1y = vertices[v1Offset+1];
        var v1z = vertices[v1Offset+2];
        var v2x = vertices[v2Offset  ];
        var v2y = vertices[v2Offset+1];
        var v2z = vertices[v2Offset+2];
        var v3x = vertices[v3Offset  ];
        var v3y = vertices[v3Offset+1];
        var v3z = vertices[v3Offset+2];

        var x1 = v2x - v1x;
        var y1 = v2y - v1y;
        var z1 = v2z - v1z;
        var x2 = v3x - v1x;
        var y2 = v3y - v1y;
        var z2 = v3z - v1z;

        var normX = y1 * z2 - z1 * y2;
        var normY = z1 * x2 - x1 * z2;
        var normZ = x1 * y2 - y1 * x2;

        var len = Math.sqrt(normX * normX + normY * normY + normZ * normZ);
        if (len > 0) {
            normX /= len;
            normY /= len;
            normZ /= len;
        }

        return [normX, normY, normZ];
    },


    /*
    Chceck the if the winding orders of the mesh triangles are correct.

    In the implementation, the shared edge is represented by the structure below.
    {
                    t1 : 29,
                    t1v : 0,
                    t2 : 17,
                    t2v : 2,
                    complete : true
    }

    - t1 : the index of the first triangle.
    - tlv : the offset of the start point of the edge based on the right hand rule
                    of the triangle. the value could be 0, 1, 2.
    - t2 : the index of the second triangle.
    - t2v : the offset of the start point of the edge based on the right hand rule
                    of the triangle. the value could be 0, 1, 2.
    - complete: a flag to indicate the two triangles are all set.

    @private
    @method _isWindingOrderCorrect
    @return boolean
    **/
    _isWindingOrderCorrect: function(){

        var Tris = this._triangles;
        var Verts = this._vertices;

        // utility functions
        function n3(a){
            return (1<<a)&3;
        }

        function map2get(map, k1, k2){
            var o = map[k1];
            if(o){
                return o[k2];
            }

            return undefined;
        }

        function map2put(map, k1, k2, v){
            var o = map[k1];
            if(!o){
                o = map[k1] = {};
            }
            o[k2] = v;
        }

        var map2 = {};
        var ntris = Tris.length / 3;
        var ei, v1, v2, minv, maxv;
        var boundTri = {
            x: Number.MIN_VALUE,
            v: -1
        };
        var v, maxx;

        for(var i = 0; i < ntris; i++){
            for(var j = 0; j < 3; j++){
                v1 = Tris[3*i+j];
                v2 = Tris[3*i+n3(j)];
                minv = v1 < v2 ? v1 : v2;
                maxv = v1 > v2 ? v1 : v2;

                v = Verts[3*v1] > Verts[3*v2] ? v1 : v2;
                maxx = Verts[3*v];

                if(maxx > boundTri.x){
                    boundTri.x = maxx;
                    boundTri.v=v; // vertex index
                }

                if((ei = map2get(map2, minv, maxv)) !== undefined){
                    if(ei.complete){
                        // the edge is shared by three triangles
                        return false;
                    }
                    ei.t2 = i;
                    ei.t2v = j;
                    ei.complete = 1;

                    // check the winding order
                    if(Tris[3*ei.t1+ei.t1v] === Tris[3*ei.t2+ei.t2v]){
                        return false;
                    }

                    continue;
                }

                // add a new edge
                ei = {};
                ei.t1=i;
                ei.t1v=j;
                map2put(map2, minv, maxv, ei);
            }
        }

        // Input the map and the vetex index in Verts
        function getTriangles(map, v){
            var edges = [];
            var o = map[v];
            if(o){
                for(var p in o){
                    edges.push(o[p]);
                }
            }

            for(var p in map){
                if(map[p][v]){
                    edges.push(map[p][v]);
                }
            }

            var triangles = [];
            var t;
            for(var i = edges.length - 1; i >=0; i-- ){
                t = edges[i].t1;
                if(triangles.indexOf(t) === -1){
                    triangles.push(t);
                }
                t = edges[i].t2;
                if(v && triangles.indexOf(t) === -1){
                    triangles.push(t);
                }
            }

            return triangles; // Return the triangle index in Tris
        }


        if(boundTri.v !== -1){
            var triangles = getTriangles(map2, boundTri.v);

            var x = new Vector3D(1,0,0);
            var n, angle, t;

            // Find a triangle which is not parallel to the x axis
            var i = triangles.length -1;
            for(; i >= 0; i--){
                n = this._triangleNormal(Tris, Verts, triangles[i]);
                angle = x.dot(n);
                if( angle < -10e-6 || angle > 10e-6){
                    t = triangles[i];
                    break;
                }
            }

            if(t){
                var tri0 = Tris[3*t]*3;
                var tri1 = Tris[3*t+1]*3;
                var tri2 = Tris[3*t+2]*3;
                var midPoint =  {
                        x: (Verts[tri0] + Verts[tri1] + Verts[tri2])/3,
                        y: (Verts[tri0+1] + Verts[tri1+1] + Verts[tri2+1])/3,
                        z: (Verts[tri0+2] + Verts[tri1+2] + Verts[tri2+2])/3
                    };

                var point;
                var maxt = t;
                var direction = {x: 1, y:0, z:0};

                maxx = midPoint.x;

                // Get the outmost triangle in the x axis direction.
                for(var k = i-1; k >= 0; k--){
                    var to = 3*triangles[k];
                    var tri0 = Tris[to]*3;
                    var tri1 = Tris[to+1]*3;
                    var tri2 = Tris[to+2]*3;

                    var pa = {x:Verts[tri0], y:Verts[tri0+1], z:Verts[tri0+2]};
                    var pb = {x:Verts[tri1], y:Verts[tri1+1], z:Verts[tri1+2]};
                    var pc = {x:Verts[tri2], y:Verts[tri2+1], z:Verts[tri2+2]};

                    point = this._hitTriangle(midPoint, direction, pa, pb, pc);

                    if(point && point.x > maxx){
                        maxx = point.x;
                        maxt = triangles[k];
                    }
                }

                n = this._triangleNormal(Tris, Verts, maxt);
                angle = x.dot(n);
                if( angle < 0){
                    return false;
                }
            }
        }

        return true;
    },

    /*
    Add a triangle to the mesh.
    @method _addTriangle
    @param {Number} i0 The 1st index of the triangle
    @param {Number} i1 The 2nd index of the triangle
    @param {Number} i2 The 3rd index of the triangle
    @private
    */
    _addTriangle: function(i0, i1, i2) {
        if(i0 === i1 || i1 === i2 || i2 ===i0) {
            // skip degenerated triangle.
            return;
        }
        this._triangles.push(i0, i1, i2);
    },

    /*
    Remove a triangle from the mesh.
    @method _removeTriangle
    @param {Number} index The index of the triangle
    @private
    */
    _removeTriangle: function(index) {
        this._triangles.splice(3*index, 3);
    },

    /**
    Intersects the triangle bounded by vertex pa, pb, pc.
    @method  hitTriangle
    @param {Point3D} origin The origin of pick ray
    @param {Vector3D} direction The direction of pick ray
    @param {Point3D} pa Vertex 'a' of triangle
    @param {Point3D} pb Vertex 'b' of triangle
    @param {Point3D} pc Vertex 'c' of triangle
    @return {Point3D} Return the intersection point
    @private
    **/
    _hitTriangle: function(origin, direction, pa, pb, pc) {

        function normalize(vec){
            var len = Math.sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
            var factor = len > 0 ? 1/len : 0.0;
            vec.x *= factor;
            vec.y *= factor;
            vec.z *= factor;
        }

        // Check the point p and c are at the same side of line defined by a and b point
        function sameSide(p, c, a, b) {
            var ab = new Vector3D(b.x - a.x, b.y - a.y, b.z - a.z);
            var ap = new Vector3D(p.x - a.x, p.y - a.y, p.z - a.z);
            var ac = new Vector3D(c.x - a.x, c.y - a.y, c.z - a.z);
            var v1 = ab.cross(ap);
            var v2 = ab.cross(ac);
            if (v1.dot(v2) >= 0) {
                return true;
            }
            return false;
        }

        var p1 = { x: origin.x,            y: origin.y,           z: origin.z};
        var p2 = { x: direction.x + p1.x,  y: direction.y + p1.y, z: direction.z + p1.z};

        var d, a1, a2, a3;
        var total, denom, mu;

        var pa1 = { x: 0.0,  y: 0.0, z: 0.0};
        var pa2 = { x: 0.0,  y: 0.0, z: 0.0};
        var pa3 = { x: 0.0,  y: 0.0, z: 0.0};

        // Calculate the parameters for the plane
        var n   = { x: 0.0,  y: 0.0, z: 0.0};
        n.x = (pb.y - pa.y) * (pc.z - pa.z) - (pb.z - pa.z) * (pc.y - pa.y);
        n.y = (pb.z - pa.z) * (pc.x - pa.x) - (pb.x - pa.x) * (pc.z - pa.z);
        n.z = (pb.x - pa.x) * (pc.y - pa.y) - (pb.y - pa.y) * (pc.x - pa.x);
        normalize(n);

        d = -n.x * pa.x - n.y * pa.y - n.z * pa.z;

        // Calculate the position on the line that intersects the plane
        denom = n.x * (p2.x - p1.x) + n.y * (p2.y - p1.y) + n.z * (p2.z - p1.z);

        // Line and plane don't intersect
        if(resabs(denom, 0.0)) {
            return null;
        }

        mu = -(d + n.x * p1.x + n.y * p1.y + n.z * p1.z) / denom;

        if (mu < 0) {
            return null;
        }

        var p = { x: 0.0,  y: 0.0, z: 0.0};

        // Capture point p to global for further use outside function
        p.x = p1.x + mu * (p2.x - p1.x);
        p.y = p1.y + mu * (p2.y - p1.y);
        p.z = p1.z + mu * (p2.z - p1.z);

        // Determine whether or not the intersection point is bounded by pa, pb, pc
        // by checking the p point is at the same side of all 3 triangle edges
        if (sameSide(p, pc, pa, pb) &&
            sameSide(p, pa, pb, pc) &&
            sameSide(p, pb, pc, pa)) {
            return p;
        }

        return null;
    },

    /**
    Bridging boundaries and create patches.
    @method  _bridgeBoundaries
    @param {Array{Mesh3DBoundary}} ours Our boundaries
    @param {Array{Mesh3DBoundary}} theirs Their boundaries
    @return {Object} Return the patches
    @private
    **/
    _bridgeBoundaries: function(ours, theirs) {

        var squareLength = function(x0,y0,z0, x1,y1,z1) {
            return (x0 - x1)*(x0 - x1) + (y0 - y1)*(y0 - y1) + (z0 - z1)*(z0 - z1);
        };

        // Convert Mesh3DBoundary to vertex array
        var toVertexArray = function(boundary) {
            var vertices = boundary.mesh._impl._vertices;
            var indices = boundary.vertexIndices;
            if (indices[0] == indices[indices.length -1]) {
                indices.pop();
            }
            var boundaryVertices = [];
            for(var i = 0, count = indices.length; i < count; i++) {
                var i0 = 3 * indices[i];
                boundaryVertices.push(vertices[i0], vertices[i0 + 1], vertices[i0 + 2]);
            }
            return boundaryVertices;
        };

        // Find a nearest vertex boundary in vertexArrays for va
        // For now, just test if it's the nearest boundary of the first point on boundary vb.
        var findNearestVertexBoundary = function(vertexArrays, va) {
            var x0 = va[0];
            var y0 = va[1];
            var z0 = va[2];
            var nearest = {index: -1, distance: Number.MAX_VALUE,  point:-1};
            for(var i = 0; i < vertexArrays.length; i++) {
                var vertexBoundary = vertexArrays[i];
                for(var j = 0; j < vertexBoundary.length/3; j++) {
                    var idx = j*3;
                    var x1 = vertexBoundary[idx];
                    var y1 = vertexBoundary[idx + 1];
                    var z1 = vertexBoundary[idx + 2];
                    var distance = squareLength(x0, y0, z0, x1, y1, z1);

                    if(distance <= nearest.distance) {
                        nearest.index = i;
                        nearest.distance = distance;
                        nearest.point = j;
                    }
                }
            }
            return nearest;
        };

        var findVertexBoundaryPairs = function(ours, theirs) {

            var a, b, x;
            if(ours.length <= theirs.length) {
                a = ours;
                b = theirs;
                x = false;
            } else {
                a = theirs;
                b = ours;
                x = true;
            }

            var pairs = [];
            while(true) {

                if(a.length === 0 || b.length === 0) {
                    break;
                }

                var aBoundary = a.pop();
                if(aBoundary.length === 0) {
                    continue;
                }

                var nearest = findNearestVertexBoundary(b, aBoundary);
                if(nearest.index < 0) {
                    continue;
                }

                var bBoundary = b[nearest.index];

                // Remove it so that it will not be bridged to others again.
                b.splice(nearest.index, 1);

                // They are combined perfectly already...
                // Or some vertices are coincident..
                if(resabs(nearest.distance, 0)) {
                    continue;
                }

                if(bBoundary.length === 0) {
                    continue;
                }

                if(x) {
                    pairs.push({
                        our: bBoundary,
                        ourIndex: nearest.point,
                        their: aBoundary,
                        theirIndex: 0
                    });
                } else  {
                    pairs.push({
                        our: aBoundary,
                        ourIndex: 0,
                        their: bBoundary,
                        theirIndex: nearest.point
                    });
                }
            };

            return pairs;
        };

        // Bridging two vertex boundaries and create a mesh patch.
        // See more details of the bridging idea in wiki page:
        //  https://wiki.autodesk.com/pages/viewpage.action?pageId=157442162
        function bridgeBoundaries(b0, b0start, b1, b1start) {

            var addTriangle = function(indices, a, b, c) {
                if(a === b || b === c || c === a) {
                    // skip degenerated triangle.
                    return;
                }
                indices.push(a, b, c);
            };

            var a, astart;
            var b, bstart;
            if(b0.length >= b1.length) {
                a = b0;
                astart = b0start;
                b = b1;
                bstart = b1start;
            } else {
                a = b1;
                astart = b1start;
                b = b0;
                bstart = b0start;
            }

            var aLength = a.length/3;
            var bLength = b.length/3;

            var acount = 0;
            var bcount = 0;

            // -->
            var nextA = function(index) {
                var next = index;
                if(acount > 0 && index == astart) {
                    next = astart;
                } else {
                    next = index <= 0 ? aLength - 1 : index - 1;
                }
                return next;
            };

            // <--
            var nextB = function(index) {
                var next = index;
                if(bcount  > 0 && index == bstart) {
                    next = bstart;
                } else {
                    next = index >= bLength - 1 ? 0 : index + 1;
                }
                return next;
            };

            var MaxTypicalScale = 4.0; // square length is 2X longer.
            var MinTypicalScale = 1.0 / MaxTypicalScale;

            var vertices = [];
            var indices = [];
            a.forEach(function(element){
                vertices.push(element);
            });
            b.forEach(function(element){
                vertices.push(element);
            });

            var ai = astart;
            var bi = bstart;
            var anext = nextA(ai);
            var bnext = nextB(bi);
            var apre = ai;
            var bpre = bi;

            var i1x3 = ai*3, i2x3 = anext*3;
            var alen = squareLength(a[i1x3], a[i1x3+1], a[i1x3+2], a[i2x3],a[i2x3+1],a[i2x3+2]);
            i1x3 = bi*3; i2x3 = bnext*3;
            var blen = squareLength(b[i1x3], b[i1x3+1], b[i1x3+2], b[i2x3],b[i2x3+1],b[i2x3+2]);

            var boffset = aLength;
            var aoffset = 0;

            while(true) {

                var lenScale = 1.0;
                if(resabs(blen, 0.0)) {
                    lenScale = resabs(alen, 0.0) ? 1.0 : MaxTypicalScale;
                } else {
                    lenScale = alen/blen;
                }

                if(lenScale > MaxTypicalScale) {
                    if(blen !== 0) {
                        addTriangle(indices, boffset + bnext, boffset + bpre, aoffset + ai);
                    } else {
                        addTriangle(indices, aoffset + apre, aoffset + anext, boffset + bi);
                        apre = anext;
                        anext = nextA(anext);
                        acount++;
                    }

                    bpre = bnext;
                    bnext = nextB(bnext);
                    bcount ++;

                    i1x3 = bi*3; i2x3 = bnext*3;
                    blen = squareLength(b[i1x3], b[i1x3 + 1], b[i1x3 + 2], b[i2x3], b[i2x3 + 1], b[i2x3 + 2]);

                } else if(lenScale < MinTypicalScale) {
                    if(alen !== 0) {
                        addTriangle(indices, aoffset + apre, aoffset + anext, boffset + bi);
                    } else {
                        addTriangle(indices, boffset + bnext, boffset + bpre, aoffset + ai);
                        bpre = bnext;
                        bnext = nextB(bnext);
                        bcount ++;
                    }

                    apre = anext;
                    anext = nextA(anext);
                    acount++;

                    i1x3 = ai*3; i2x3 = anext*3;
                    alen = squareLength(a[i1x3], a[i1x3 + 1], a[i1x3 + 2], a[i2x3], a[i2x3 + 1], a[i2x3 + 2]);

                } else {
                    // Just add the triangle in to mesh
                    // Larger aspect ratio is expected.
                    i1x3 = apre*3;  i2x3 = bnext*3;
                    var length1 = squareLength(a[i1x3], a[i1x3 + 1], a[i1x3 + 2], b[i2x3], b[i2x3 + 1], b[i2x3 + 2]);
                    i1x3 = anext*3; i2x3 = bpre*3;
                    var length2 = squareLength(a[i1x3], a[i1x3 + 1], a[i1x3 + 2], b[i2x3], b[i2x3 + 1], b[i2x3 + 2]);
                    if(length1 > length2) {
                        addTriangle(indices, aoffset + apre,  aoffset + anext, boffset + bpre);
                        addTriangle(indices, aoffset + anext, boffset + bnext, boffset + bpre);
                    } else {
                        addTriangle(indices, aoffset + apre, aoffset + anext, boffset + bnext);
                        addTriangle(indices, aoffset + apre, boffset + bnext, boffset + bpre);
                    }

                    ai = anext;
                    bi = bnext;

                    apre = anext;
                    anext = nextA(anext);
                    bpre = bnext;
                    bnext = nextB(bnext);

                    acount++;
                    bcount++;

                    i1x3 = ai*3; i2x3 = anext*3;
                    alen = squareLength(a[i1x3], a[i1x3 + 1], a[i1x3 + 2], a[i2x3], a[i2x3 + 1], a[i2x3 + 2]);
                    i1x3 = bi*3; i2x3 = bnext*3;
                    blen = squareLength(b[i1x3], b[i1x3 + 1], b[i1x3 + 2], b[i2x3], b[i2x3 + 1], b[i2x3 + 2]);
                }

                if((acount+ bcount) > (aLength + bLength)) {
                    break;
                }
            }

            return {vertices: vertices, indices: indices};
        };


        // Create vertex arrays for boundaries
        var ourVertexArrays = ours.map(function(boundary){
            return toVertexArray(boundary);
        });

        // Create vertex arrays for "other" mesh and this updated mesh.
        var otherVertexArrays = theirs.map(function(boundary){
            return toVertexArray(boundary);
        });

        var pairs = findVertexBoundaryPairs(ourVertexArrays, otherVertexArrays);
        var patches = [];
        pairs.forEach(function(pair) {
            var patch = bridgeBoundaries(pair.their, pair.theirIndex, pair.our, pair.ourIndex);
            patches.push(patch);
        });

        return patches;
    }
};

/**
Creates an object that represents a 3D mesh.
Call this constructor with JavaScript's standard new keyword: new Mesh3D()
By default, the mesh is empty. Use the triangle and quad methods to add polygons.
Note that the shape constructed from polygons must be closed, i.e. it must enclose a volume.
A mesh that does not enclose a volume (such as a flat shape) may not produce the expected
result when made into a Solid object.
@class Mesh3D
@since 1.0.0
@constructor
**/
var Mesh3D =  function() {

    /**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @private
    @property {_Mesh3D} _impl
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Mesh3D()
    });

    /**
    A set of client defined, key-value attributes that can be used to store information
    directly onto this object, providing a simple decorator pattern.  Clients should
    make their keys fairly unique to prevent key clashes.
    @property {Object} attributes
    @since 1.2.0
    @readonly
    **/
    Object.defineProperty(this, 'attributes', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: {}
    });

    /**
    Fires when the mesh is changed.  The client-received {Event#data} represents this mesh.  The {Event#originalEvent} will be undefined.

    In the future {Event#type} may contain some information that allows the client to understand the specific type of change that happened.
    @event change
    @since 1.2.0
    @public
    @type {EventSource}
    **/
    Object.defineProperty(this, 'change', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: new EventSource('changed')
    });

};

Mesh3D.prototype = {

    /**
    Adds a triangle to the mesh. The arguments passed to this method describe the three vertices of the triangle, and should be provided in the counter-clockwise order.
    @method triangle
    @since 1.0.0
    @param {Number*|Array[Number*]|Array[Number*]*} args The arguments can be one of the following 3 combinations: 1) Nine separate numbers, representing the X, Y and Z position of 3 vertices.
    2) An array of nine separate numbers representing the X, Y and Z position of 3 vertices or 3) Three arrays containing 3 numbers each, representing the X, Y and Z position of each vertex.
    @chainable
    @example

    // Define a triangle by passing in 9 numbers
    // corresponding to the X, Y and Z values of
    // 3 points:
    mesh.triangle(0, 0, 0, 1, 0, 0, 0, 1, 0);

    @example

    // Define a triangle by passing in 3 arrays
    // containing 3 numbers each, corresponding
    // to the X, Y and Z:
    var pt1 = [0, 0, 0];
    var pt2 = [1, 0, 0];
    var pt3 = [0, 1, 0];
    mesh.triangle(pt1, pt2, pt3);

    @example

    // Define a triangle by passing in 1 array
    // containing 9 numbers corresponding to
    // the X, Y and Z values of 3 points:
    var pts = [0, 0, 0, 1, 0, 0, 0, 1, 0];
    mesh.triangle(pts);

    **/
    triangle: function() {
        var _impl = this._impl;
        switch(arguments.length){
            case 1:
                if (Array.isArray(arguments[0]) && arguments[0].length === 9){
                    var idx1 = _impl._addVertex(arguments[0][0], arguments[0][1], arguments[0][2]);
                    var idx2 = _impl._addVertex(arguments[0][3], arguments[0][4], arguments[0][5]);
                    var idx3 = _impl._addVertex(arguments[0][6], arguments[0][7], arguments[0][8]);
                    _impl._addTriangle(idx1, idx2, idx3);
                } else {
                    Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
                }
                break;
            case 3:
                if (Array.isArray(arguments[0]) && arguments[0].length === 3
                    && Array.isArray(arguments[1]) && arguments[1].length === 3
                    && Array.isArray(arguments[2]) && arguments[2].length === 3){
                    var idx1 = _impl._addVertex(arguments[0][0], arguments[0][1], arguments[0][2]);
                    var idx2 = _impl._addVertex(arguments[1][0], arguments[1][1], arguments[1][2]);
                    var idx3 = _impl._addVertex(arguments[2][0], arguments[2][1], arguments[2][2]);
                    _impl._addTriangle(idx1, idx2, idx3);
                } else {
                    Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
                }
                break;
            case 9:
                var idx1 = _impl._addVertex(arguments[0], arguments[1], arguments[2]);
                var idx2 = _impl._addVertex(arguments[3], arguments[4], arguments[5]);
                var idx3 = _impl._addVertex(arguments[6], arguments[7], arguments[8]);
                _impl._addTriangle(idx1, idx2, idx3);
                break;
            default:
                Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        this.change.fire(this);

        return this;

    },

    /**
    Adds a quad (a 3D rectangle) to the mesh.
    The arguments passed to this method describe the four vertices of the quad.
    @method quad
    @since 1.0.0
    @param {Array[Number]} args Various permutations of arguments are allowed.  Please see the examples for usage.
    @chainable
    @example

    // Define a qud by passing in 12 numbers
    // corresponding to the X, Y and Z values of
    // 4 points:
    mesh.quad(0, 0, 1, 3, 0, 1, 3, 2, 1, 0, 2, 1);

    @example

    // Define a quad by passing in 4 arrays
    // containing 3 numbers each, corresponding
    // to the X, Y and Z:
    mesh.quad([0,0, 1], [3, 0, 1], [3, 2, 1], [0, 2, 1]);

    @example

    // Define a quad by passing in 1 array
    // containing 12 numbers corresponding to
    // the X, Y and Z values of 4 points:
    mesh.quad([0, 0, 1, 3, 0, 1, 3, 2, 1, 0, 2, 1]);

    */
    quad: function() {
        var _impl = this._impl;

        switch(arguments.length){
            case 1:
                if (Array.isArray(arguments[0]) && arguments[0].length === 12){
                    var idx1 = _impl._addVertex(arguments[0][0], arguments[0][1], arguments[0][2]);
                    var idx2 = _impl._addVertex(arguments[0][3], arguments[0][4], arguments[0][5]);
                    var idx3 = _impl._addVertex(arguments[0][6], arguments[0][7], arguments[0][8]);
                    var idx4 = _impl._addVertex(arguments[0][9], arguments[0][10], arguments[0][11]);
                    _impl._addTriangle(idx1, idx2, idx3);
                    _impl._addTriangle(idx1, idx3, idx4);
                } else {
                    Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
                }
                break;
            case 4:
                if (Array.isArray(arguments[0]) && arguments[0].length === 3
                    && Array.isArray(arguments[1]) && arguments[1].length === 3
                    && Array.isArray(arguments[2]) && arguments[2].length === 3
                    && Array.isArray(arguments[3]) && arguments[3].length === 3){
                    var idx1 = _impl._addVertex(arguments[0][0], arguments[0][1], arguments[0][2]);
                    var idx2 = _impl._addVertex(arguments[1][0], arguments[1][1], arguments[1][2]);
                    var idx3 = _impl._addVertex(arguments[2][0], arguments[2][1], arguments[2][2]);
                    var idx4 = _impl._addVertex(arguments[3][0], arguments[3][1], arguments[3][2]);
                    _impl._addTriangle(idx1, idx2, idx3);
                    _impl._addTriangle(idx1, idx3, idx4);
                } else {
                    Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
                }
                break;
            case 12:
                if (typeof(arguments[0]) === 'number' && typeof(arguments[1]) === 'number' && typeof(arguments[2]) === 'number' &&
                    typeof(arguments[3]) === 'number' && typeof(arguments[4]) === 'number' && typeof(arguments[5]) === 'number' &&
                    typeof(arguments[6]) === 'number' && typeof(arguments[7]) === 'number' && typeof(arguments[8]) === 'number' &&
                    typeof(arguments[9]) === 'number' && typeof(arguments[10]) === 'number' && typeof(arguments[11]) === 'number'){
                    var idx1 = _impl._addVertex(arguments[0], arguments[1], arguments[2]);
                    var idx2 = _impl._addVertex(arguments[3], arguments[4], arguments[5]);
                    var idx3 = _impl._addVertex(arguments[6], arguments[7], arguments[8]);
                    var idx4 = _impl._addVertex(arguments[9], arguments[10], arguments[11]);
                    _impl._addTriangle(idx1, idx2, idx3);
                    _impl._addTriangle(idx1, idx3, idx4);
                } else {
                    Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
                }
                break;
            default:
                Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        this.change.fire(this);
        return this;

     },

    /**
    Transforms the mesh's vertices by the transformation matrix given in tm,
    which must be a 16-element array of numbers or a Matrix3D instance.
    @method transform
    @since 1.0.0
    @param {Matrix3D|Array[Number]} matrix A Matrix3D instance or an array of 16 numbers.
    @chainable

    @example

        // Scale to 2X and translation by 5, 5, 5
        var tm = [
                    2, 0, 0, 0,
                    0, 2, 0, 0,
                    0, 0, 2, 0,
                    5, 5, 5, 1
                 ];
        mesh.transform(tm);

     @example

        // Scale to 2X and translation by 5, 5, 5
        var tm = new Matrix3D();
        tm.identity().scaling(2).translation(5, 5, 5);
        mesh.transform(tm);

     **/

    transform: function(tm) {

        var mtx;
        if (Array.isArray(tm) && tm.length === 16) {
            mtx = new Matrix3D(tm);
        } else if (tm instanceof Matrix3D) {
            mtx = tm;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        this._impl._vertexSet = {};

        var elements = mtx.elements;
        var _impl = this._impl;
        var vNum = _impl._vertices.length/3;
        var x, y, z, x1, y1, z1, vIdx, hash;
        for (var i = 0; i < vNum; i++) {
            vIdx = i * 3;
            x = _impl._vertices[vIdx];
            y = _impl._vertices[vIdx + 1];
            z = _impl._vertices[vIdx + 2];
            x1 = x*elements[0] + y*elements[4] + z*elements[8] + elements[12];
            y1 = x*elements[1] + y*elements[5] + z*elements[9] + elements[13];
            z1 = x*elements[2] + y*elements[6] + z*elements[10] + elements[14];
            _impl._vertices[vIdx] = x1;
            _impl._vertices[vIdx + 1] = y1;
            _impl._vertices[vIdx + 2] = z1;

            hash = _impl._hash(x1, y1, z1);
            _impl._vertexSet[hash] = i;
        };

        this.change.fire(this);
        return this;
    },

    /**
    Adds the indexed triangle list given the vertices and indexed triangle lists.
    Before the indices of triangles are stored, they are adjusted basing on the existing vertices indices in the Mesh3D object, so this method is safe to be called multiple times for importing mesh data.
    @method indexedTriangles
    @since 1.1.0
    @param {Array[Number]} vertices a vertex list
    @param {Array[Number]} indices a index triangle list that refers the vertex list by indices
    @chainable
    **/
    indexedTriangles: function(vertices, indices) {

        // Make sure the data integrity
        if (Array.isArray(vertices) &&
            Array.isArray(indices) &&
            vertices.length % 3 === 0 &&
            indices.length % 3 === 0) {

            var _impl = this._impl;
            var vLen = vertices.length;
            var iLen = indices.length;
            var indexMapping = [];

            // Step 1: push the vertices in and get the new indices
            for (var i = 0, j = 0; i < vLen; i+=3, j++) {
                var idx = _impl._addVertex(vertices[i], vertices[i+1], vertices[i+2]);
                indexMapping[j]=idx;
            };

            // Step 2: push the indexed triangles in with the new indices
            var imLen = indexMapping.length;
            for (var k = 0; k < iLen; k++) {
                var oldIdx = indices[k];
                if (oldIdx > imLen - 1 || oldIdx < 0){
                    Plugin.panic("The vertex index is out of range");
                }
                _impl._triangles.push(indexMapping[oldIdx]);
            };

        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        this.change.fire(this);
        return this;
    },

    /**
    Combines this mesh with the supplied mesh(es). It doesn't perform the mesh boolean but simply merges vertices. The current mesh becomes the resulting one.
    @method combine
    @since 1.2.0
    @param {Mesh3D|Array[Mesh3D]} meshes One or more meshes.
    @chainable
    **/
    combine: function(meshes) {
        if(!Array.isArray(meshes)){
            meshes = [meshes];
        }

        var mesh;
        for(var i = 0; i < meshes.length; i++){
            mesh = meshes[i];
            if (!(mesh instanceof Mesh3D)) {
                Plugin.panic("The supplied data meshes["+i+"] is not a Mesh3D object.");
            }
            this.indexedTriangles(mesh._impl._vertices, mesh._impl._triangles);
        }

        this.change.fire(this);

        return this;
    },

    /**
    Flips the normals of all the surfaces inside the mesh.
    @method flipNormals
    @since 1.7.0
    @chainable
    **/
    flipNormals: function() {
        var triangles = this._impl._triangles;
        var length = triangles.length;
        for (var i = 0; i < length; i += 3) {
            var temp = triangles[i + 1];
            triangles[i + 1] = triangles[i + 2];
            triangles[i + 2] = temp;
        }
        return this;
    },

    /**
    Clones the mesh3D object
    @method clone
    @return {Mesh3D}
    @since 1.8.0
    **/
    clone:  function(){

        var mesh = new Mesh3D();
        var triangles = this._impl._triangles;
        var vertices = this._impl._vertices;
        var vertexSet = this._impl._vertexSet;

        mesh._impl._triangles = triangles.slice(0);
        mesh._impl._vertices = vertices.slice(0);

        var newVertexSet = mesh._impl._vertexSet;
        for (var key in vertexSet) {
            newVertexSet[key] = vertexSet[key];
        }

        return mesh;
    },

    /**
    Unites this mesh with the supplied mesh(es) to create
    a single mesh that represents the union of all meshes.
    In order to get correct result, it requires all the meshes have right winding order (counter clockwise in right handed system) which yields normals that point outside of the object.
    It's an asynchronous function and requires to use with the asynchronus approach of shape generator.

    @example

    function shapeGeneratorEvaluate(params, callback){
        var leftPyramid = new Mesh3D();
        var v = [[-10, 0, 0], [10, 0, 0], [0, 20, 0], [0, 0, 20]];
        leftPyramid.triangle(v[0], v[2], v[1]);
        leftPyramid.triangle(v[0], v[1], v[3]);
        leftPyramid.triangle(v[0], v[3], v[2]);
        leftPyramid.triangle(v[1], v[2], v[3]);

        var rightPyramid = new Mesh3D();
        v = [[0, 0, 0], [20, 0, 0], [10, 20, 0], [10, 0, 20]];
        rightPyramid.triangle(v[0], v[2], v[1]);
        rightPyramid.triangle(v[0], v[1], v[3]);
        rightPyramid.triangle(v[0], v[3], v[2]);
        rightPyramid.triangle(v[1], v[2], v[3]);

        rightPyramid.unite(leftPyramid, function(mesh){
            var s = Solid.make(mesh);
            callback(s);
        });
    }

    @method unite
    @since 1.2.0
    @param meshes {Mesh3D|Array[Mesh3D]} One or more meshes.
    @param callback {Function(Mesh3D|undefined)} A callback that receives the resulting mesh upon completion or failure.
    @async
    **/
    unite: function(meshes, callback) {
        // TODO: Use CSG.js initially
        // Check on the incoming meshes to see if they have a BSP tree already in the cache.
        // If not generate one and store it in the versioned attribute cache.
        // I have this asynchronous so that if we need to do an AJAX request in the future
        // to leverage the entire cluster, we can add that in later without changing API.

        return meshBoolean("union", this, meshes, callback);
    },

    /**
    Subtracts the supplied mesh(es) from this mesh, essentially
    creating holes in this mesh where the supplied mesh(es) exist,
    and returns a single resulting mesh.
    In order to get correct result, it requires all the meshes have right winding order (counter clockwise in right handed system) which yields normals that point outside of the object.
    It's an asynchronous function and requires to use with the asynchronus approach of shape generator.

    @example

    function shapeGeneratorEvaluate(params, callback){
        var leftPyramid = new Mesh3D();
        var v = [[-10, 0, 0], [10, 0, 0], [0, 20, 0], [0, 0, 20]];
        leftPyramid.triangle(v[0], v[2], v[1]);
        leftPyramid.triangle(v[0], v[1], v[3]);
        leftPyramid.triangle(v[0], v[3], v[2]);
        leftPyramid.triangle(v[1], v[2], v[3]);

        var rightPyramid = new Mesh3D();
        v = [[0, 0, 0], [20, 0, 0], [10, 20, 0], [10, 0, 20]];
        rightPyramid.triangle(v[0], v[2], v[1]);
        rightPyramid.triangle(v[0], v[1], v[3]);
        rightPyramid.triangle(v[0], v[3], v[2]);
        rightPyramid.triangle(v[1], v[2], v[3]);

        rightPyramid.subtract(leftPyramid, function(mesh){
            var s = Solid.make(mesh);
            callback(s);
        });
    }

    @method subtract
    @since 1.2.0
    @param meshes {Mesh3D|Array[Mesh3D]} One or more meshes.
    @param callback {Function(Mesh3D|undefined)} A callback that receives the resulting mesh upon completion or failure.
    @async
    **/
    subtract: function(meshes, callback) {
        // TODO: Use CSG.js initially
        // Check on the incoming meshes to see if they have a BSP tree already in the cache.
        // If not generate one and store it in the versioned attribute cache.
        // I have this asynchronous so that if we need to do an AJAX request in the future
        // to leverage the entire cluster, we can add that in later without changing API.
        return meshBoolean("subtract", this, meshes, callback);
    },

    /**
    Intersects this mesh with each of the supplied mesh(es),
    and returns a single resulting mesh that represents the
    intersection of all meshes.
    In order to get correct result, it requires all the meshes have right winding order (counter clockwise in right handed system) which yields normals that point outside of the object.
    It's an asynchronous function and requires to use with the asynchronous approach of shape generator.

    @example

    function shapeGeneratorEvaluate(params, callback){
        var leftPyramid = new Mesh3D();
        var v = [[-10, 0, 0], [10, 0, 0], [0, 20, 0], [0, 0, 20]];
        leftPyramid.triangle(v[0], v[2], v[1]);
        leftPyramid.triangle(v[0], v[1], v[3]);
        leftPyramid.triangle(v[0], v[3], v[2]);
        leftPyramid.triangle(v[1], v[2], v[3]);

        var rightPyramid = new Mesh3D();
        v = [[0, 0, 0], [20, 0, 0], [10, 20, 0], [10, 0, 20]];
        rightPyramid.triangle(v[0], v[2], v[1]);
        rightPyramid.triangle(v[0], v[1], v[3]);
        rightPyramid.triangle(v[0], v[3], v[2]);
        rightPyramid.triangle(v[1], v[2], v[3]);

        rightPyramid.intersect(leftPyramid, function(mesh){
            var s = Solid.make(mesh);
            callback(s);
        });
    }

    @method intersect
    @since 1.2.0
    @param meshes {Mesh3D|Array[Mesh3D]} One or more meshes.
    @param callback {Function(Mesh3D|undefined)} A callback that receives the resulting mesh upon completion or failure.
    @async
    **/
    intersect: function(meshes, callback) {
        // TODO: Use CSG.js initially
        // Check on the incoming meshes to see if they have a BSP tree already in the cache.
        // If not generate one and store it in the versioned attribute cache.
        // I have this asynchronous so that if we need to do an AJAX request in the future
        // to leverage the entire cluster, we can add that in later without changing API.
        return meshBoolean("intersect", this, meshes, callback);
    },

    /**
    Computes edges of this mesh. The return array is a line pieces.
    For example: lines P1-P2, P3-P4 in the array are [P1, P2, P3, P4].
    @method edges
    @since 1.2.0
    @return {Array}
    **/
    edges: function() {
        if (this.attributes['edges'] !== undefined &&
            this.attributes['edges']['data'] !== undefined){
            return this.attributes['edges']['data'];
        }

        // Bind the handler the very first time when the prop is not there
        if (undefined === this.attributes['edges']) {
            this.change.bind(edgesCacheHandler);
        }

        var edges = [];

        var n1Normal = new Vector3D();
        var n2Normal = new Vector3D();

        var filter = function(edge) {
            var result = {edge: edge, marked: false};
            // Find neighboring faces with edge and its symmetric edge.
            // Not water tight or non-manifold? Collect it anyway.
            var symEdge = edge.sym;
            if(!symEdge) {
                result.marked = true;
            } else if (!_Topology.isPositiveEdge(edge)) {
                result.marked = false;
            } else if(symEdge.faces.length > 1 || edge.faces.length > 1) {
                result.marked = true;
            } else {
                var leftFace = edge.faces[0];
                var rightFace = symEdge.faces[0];

                var meshImpl = edge.body.mesh._impl;
                var n1 = meshImpl._triangleNormal(meshImpl._triangles, meshImpl._vertices, leftFace);
                var n2 = meshImpl._triangleNormal(meshImpl._triangles, meshImpl._vertices, rightFace);

                n1Normal.x = n1[0];
                n1Normal.y = n1[1];
                n1Normal.z = n1[2];

                n2Normal.x = n2[0];
                n2Normal.y = n2[1];
                n2Normal.z = n2[2];

                var thresholdAngle = 0.8191520;    // Math.cos(35*Math.PI/180);
                if (n1Normal.dot(n2Normal) < thresholdAngle) {
                    result.marked = true;
                }
            }
            return result;
        };

        var callback = function(result) {
            if (result.marked) {
                edges.push(result.edge.v0, result.edge.v1);
            }
        };

        // Compute edges of this mesh. The return array is a line pieces.
        // For example: lines P1-P2, P3-P4 in the array are [P1, P2, P3, P4].
        var body = _Topology.body(this);
        _Topology.eachEdge(body, _Topology.filterObject(filter, callback));

        var cache = { 'data' :  edges};
        this.attributes['edges'] = cache;

        return edges;
    },

    /**
    Computes the bounds of the Mesh.
    @method bounds
    @return {Box3D}
    @since 1.6.0
    **/
    bounds: function() {
        if (this.attributes['bounds'] !== undefined &&
            this.attributes['bounds']['data'] !== undefined){
            return this.attributes['bounds']['data'];
        }

        // Bind the handler the very first time when the prop is not there
        if (undefined === this.attributes['bounds']) {
            this.change.bind(boundsCacheHandler);
        }

        var ba = this._impl._bounds();
        var bounds = undefined;

        if (ba) {
            bounds = new Box3D(
                    new Point3D(ba[0], ba[1], ba[2]),
                    new Point3D(ba[3], ba[4], ba[5])
                   );
            var cache = { 'data' :  bounds};
            this.attributes['bounds'] = cache;
        }

        return bounds;
    },

    /**
    Computes the boundaries of the Mesh.
    @method boundaries
    @return {Array[Mesh3DBoundary]}
    @since 1.8.0
    **/
    boundaries: function() {

        if (this.attributes['boundaries'] !== undefined &&
            this.attributes['boundaries']['data'] !== undefined){
            Debug.log('cached boundaries data is used');
            return this.attributes['boundaries']['data'];
        }

        // Bind the handler the very first time when the prop is not there
        if (undefined === this.attributes['boundaries']) {
            this.change.bind(boundariesCacheHandler);
        }

        // Edge information
        var edges = [];

        var filter = function(edge) {
            var result = {edge: edge, marked: false};
            var symEdge = edge.sym;
            if(!symEdge) {
                result.marked = true;
            }
            return result;
        };

        var callback = function(result) {
            if (result.marked) {
                edges.push({
                    v0: result.edge.v0,
                    v1: result.edge.v1
                });
            }
        };
        var body = _Topology.body(this);
        _Topology.eachEdge(body, _Topology.filterObject(filter, callback));

        var edgeBoundaries = _Topology.edgeBoundaries(body, edges);
        var cache = { 'data' :  edgeBoundaries};
        this.attributes['boundaries'] = cache;

        return edgeBoundaries;
    },

    /**
    Computes the boundaries of a subset of given triangles specified by triangle indices.
    @method boundariesByTriangles
    @param {Array[Number]} indices A set of triangle indices to compute the boundaries from.
    @return {Array[Mesh3DBoundary]}
    @since 1.8.0
    **/
    boundariesByTriangles: function(indices) {

        var verts = this._impl._vertices;
        var tris  = this._impl._triangles;

        var tempMesh = new Mesh3D();
        tempMesh._impl._vertices = verts.slice(0);
        tempMesh._impl._triangles = [];
        for(var i = 0, ntris = indices.length; i < ntris; i++) {
            var ix3 = indices[i]*3;
            tempMesh._impl._triangles.push(tris[ix3], tris[ix3+1], tris[ix3+2]);
        }

        var edgeBoundaries = tempMesh.boundaries();
        return edgeBoundaries;
    },

    /**
    Returns a list of triangles that are adjacent to the specified triangle's edges or vertices.
    @method trianglesByTriangle
    @param {Number} index A triangle index to use as the starting point for the search.
    @param {Boolean} byEdge Find triangles by adjacent edge or not.
    @return {Array[Number]} The indices of the adjacent triangles.
    @since 1.8.0
    **/
    trianglesByTriangle: function(index, byEdge) {
        byEdge = byEdge ? true : false;
        var tris = this._impl._triangles;
        var seedTi = 3 * index;
        var seedTriVerts = {};
        seedTriVerts[tris[seedTi]] = true;
        seedTriVerts[tris[seedTi+1]] = true;
        seedTriVerts[tris[seedTi+2]] = true;

        var body = _Topology.body(this);
        var triangles = {};

        // Use DFS to find adjacent triangles that share at least one
        // vertex with the seed triangle.
        var findAdjacentTriangles = function(triIndex) {
            triangles[triIndex] = true;

            var ti = 3 * triIndex;
            var triverts = [tris[ti], tris[ti+1], tris[ti+2]];

            // Iterate edges and symmetric edges of this triagle: [v0, v1], [v1, v2], [v2, v0], [v1, v0], [v2, v1], [v0, v2]
            for (var i = 2, j = 0; j < 3; i = j++) {
                var v0 = triverts[i], v1 = triverts[j];

                // Exit recursion when the edge does not contain vertex
                // that is on the seed triangle.
                var seedv0 = seedTriVerts[v0];
                var seedv1 = seedTriVerts[v1];
                var found = (byEdge && seedv0 && seedv1 ) || (!byEdge && (seedv0 || seedv1))
                if (found) {
                    var edge = _Topology.edgeOfVertices(body, v0, v1);
                    var symmetricEdge = _Topology.edgeOfVertices(body, v1, v0);
                    var faces = [];
                    if (edge) {
                        faces.push.apply(faces, edge.faces);
                    }
                    if (symmetricEdge) {
                        faces.push.apply(faces, symmetricEdge.faces);
                    }
                    faces.forEach(function(face) {
                        if (!triangles[face]) {
                            findAdjacentTriangles(face);
                        }
                    });
                }
            }
        };
        findAdjacentTriangles(index);

        // Delete the seed triangle itself
        delete triangles[index];
        return Object.keys(triangles);
    },


    /**
    Returns a list of triangles that are adjacent to the specified vertex.
    @method trianglesByVertex
    @param {Number} index A vertex index to use as the starting point for the search.
    @return {Array[Number]} The indices of the adjacent triangles.
    @since 1.8.0
    **/
    trianglesByVertex: function(index) {

        var triangles = [];
        var markedFaces= {};
        var filter = function(edge) {
            var result = {edge: edge, marked: false};
            var symEdge = edge.sym;
            if(symEdge && edge.v0 === index) {
                result.marked = true;
            } else if (!symEdge && (edge.v1 === index || edge.v0 === index)){
                result.marked = true;
            }
            return result;
        };

        var callback = function(result) {
            if (result.marked) {
                result.edge.faces.forEach(function(face){
                    if(!markedFaces[face]) {
                       triangles.push(face);
                    }
                    markedFaces[face] = true;
                });
            }
        };

        var body = _Topology.body(this);
        _Topology.eachEdge(body, _Topology.filterObject(filter, callback));

        return triangles;
    },

    /**
    Returns a list of triangles that are adjacent to the specified edge.
    @method trianglesByEdge
    @param {Number} vstart A vertex index to use as the edge start point.
    @param {Number} vend A vertex index to use as the edge end point.
    @return {Array[Number]} The indices of the adjacent triangles.
    @since 1.18.0
    **/
    trianglesByEdge: function(vstart, vend) {
        var body = _Topology.body(this);
        var edge = _Topology.edgeOfVertices(body, vstart, vend);
        if (edge) {
            return edge.faces;
        }

        return [];
    },

    /**
    Returns the coordinate of a particular vertex in an array [x, y, z] by given its index.
    @method vertexByIndex
    @param {Number} index A vertex index to get the information of.
    @return {Array} result The position [x, y, z] of the vertex.
    @since 1.8.0
    **/
    vertexByIndex: function(index) {
        var verts = this._impl._vertices;
        if(index >= verts.length/3) {
            return undefined;
        }
        var ix3 = 3 * index;
        return [ verts[ix3], verts[ix3 + 1], verts[ix3 + 2] ];
    },

    /**
    Returns information about a particular triangle given its index.
    @method triangleByIndex
    @param {Number} index A triangle index to get the information of.
    @return {Array[Number]} result.vertices The vertex indices of the triangle.
    @since 1.8.0
    **/
    triangleByIndex: function(index) {
        var tris = this._impl._triangles;
        if(index >= tris.length/3) {
            return undefined;
        }
        var ix3 = 3 * index;
        var verts = [tris[ix3], tris[ix3 + 1], tris[ix3 + 2]];
        return verts;
    },

    /**
    @method select
    @implements ISelectable
    @since 1.8.0
    **/
    select: function(selector) {

        var pickResultsSorter = function(a, b) {
            return a.distance - b.distance;
        }

        if(!selector || !selector.ray) {
            return null;
        }

        var pickResults = [];

        var pickRay = selector.ray;
        var o = pickRay.origin;
        var dir = pickRay.direction;
        var tris  = this._impl._triangles;
        var verts = this._impl._vertices;

        var points = [];
        for(var i = 0, nverts = verts.length; i < nverts; i += 3) {
            var pt = {x:verts[i], y:verts[i + 1], z:verts[i + 2]};
            points.push(pt);
        }

        for(var i = 0, ntris = tris.length; i < ntris; i += 3) {
            var i0 = tris[i    ];
            var i1 = tris[i + 1];
            var i2 = tris[i + 2];
            var p = this._impl._hitTriangle(o, dir, points[i0], points[i1], points[i2]);
            if(p) {
                var distance = (p.x-o.x)*(p.x-o.x) + (p.y-o.y)*(p.y-o.y) + (p.z-o.z)*(p.z-o.z);
                pickResults.push({
                    triangle: i/3,
                    point: p,
                    distance: distance
                });
            }
        }

        if(pickResults.length === 0) {
            return null;
        }

        // Just result the first selection
        pickResults.sort(pickResultsSorter);

        var pickResult = pickResults[0];
        var meshSelection = new Mesh3DSelection(this, [pickResult.triangle]);
        meshSelection.distance = Math.sqrt(pickResult.distance);
        meshSelection.collision = new Point3D(pickResult.point.x, pickResult.point.y, pickResult.point.z);
        meshSelection.selector = selector;
        selector.selections.push(meshSelection);

        return meshSelection;
    },

    /**
    Removes a set of triangles within this mesh as identified by the supplied selection.
    Any vertices that are unused afterwards are removed as well.
    @method removeTriangles
    @param {Mesh3DSelection} selection A selection that identifies a set of triangles.
    @since 1.8.0
    **/
    removeTriangles: function(selection) {
        var tis = selection.triangleIndices.slice(0);
        tis.sort(function(a, b) {return a-b;});
        for(var i = tis.length-1; i >= 0; i--) {
            this._impl._removeTriangle(tis[i]);
        }
        this.change.fire(this);
    },

    /**
    This is a specialized version of the {Mesh3D#combine} function that allows two meshes to be combined
    and fused along one or more boundaries that they share.  There are three possible permuations when calling this method:
    1. The boundaries where this mesh and the other mesh should be combined at are both **known**, so the `ours` and `theirs` arguments are both provided.
    2. The boundaries on this mesh are **known**, however where they connect on the other mesh is **unknown** so the `ours` argument is provided and `theirs` can be left undefined.
    3. The boundaries on this mesh are **unknown**, however the boundaries on the other mesh are **known** so the `theirs` argument can be provided and `ours` can be left undefined.

    If neither `ours` and `theirs` is supplied, this function will fallback to {Mesh3D#combine}.

    In below example, we combine purple mesh and blue mesh along their boundaries.

            // Get boundaries of purple mesh and blue mesh
            var boundariesOnPurple = purple.boundaries();
            var boundariesOnBlue = blue.boundaries();

            // combine
            var boundaries = {
                    ours: boundariesOnBlue,
                    theirs: bounadriesOnPurple
                };
            blue.combineByBoundaries(purple, boundaries);

    Original meshes:

    ![bridge_boundaries_origin]({@ResourceUrl:bridge_boundaries_origin.png})

    Bridged patch and resultant mesh:

    ![bridge_boundaries_result]({@ResourceUrl:bridge_boundaries_result.png})

    @method combineByBoundaries
    @param {Mesh3D} mesh Another mesh to combine with this mesh.
    @param {Object} boundaries Information about the boundaries to combine the meshes along.
      @param {Array[Mesh3DBoundary]} [boundaries.ours] The known boundaries on this mesh where the meshes should fuse together.
      @param {Array[Mesh3DBoundary]} [boundaries.theirs] The known boundaries on the other mesh where the meshes should fuse together.
    @see Mesh3D#combine
    @since 1.13.0
    @markdown
    @chainable
    **/
    combineByBoundaries: function(mesh, boundaries) {

        if(!mesh) {
            Debug.panic('Another mesh is empty.');
            return this;
        }

        //Just do a combine first.
        this.combine([mesh]);

        // A general combine is enough
        // if no boundaries provided or there is no any boundaries in other mesh.
        if (!boundaries) {
            Debug.log('Neither ours and theirs is supplied, this function will fallback to combine.');
            return this;
        }

        var ours = boundaries.ours || [];
        var theirs = boundaries.theirs || [];
        if (ours.length === 0 && theirs.length === 0) {
            Debug.log('Neither ours and theirs is supplied, this function will fallback to combine.');
            return this;
        }

        theirs = theirs.length === 0 ? mesh.boundaries() :  theirs;
        if(theirs.length === 0) {
            return this;
        }

        var patches = this._impl._bridgeBoundaries(ours, theirs);
        var me = this;
        patches.forEach(function(patch) {
            me.indexedTriangles(patch.vertices, patch.indices);
            //Debug.triangles(patch.vertices, patch.indices);
        });

        this.change.fire(this);
        return this;
    },

    /**
    Returns the indices of all the triangles in the mesh.
    - The total number of triangles is equal to `this.triangles() / 3`.
    - The 3 vertex indices for the N-th triangle are: 3 &times; N + 0, 3 &times; N + 1 and 3 &times; N + 2.
    - If this mesh is a tetrahedron, there will be 4 vertices and 4 triangles, and 12 elements in the value returned by this function.
    - This function returns a copy of the indices, so clients should store the result in a variable rather than calling this from within a `for` loop.
    @markdown
    @method triangles
    @return {Array[Number]}
    @since 1.8.0
    **/
    triangles: function() {
        return this._impl._triangles.slice(0);
    },

    /**
     Overrides the default serialization process of JSON.stringify method, and
     returns the serialized JSON with below format
     @example
     {
        "vertices":  [x1, y1, z1, x2, y2, z2, ...],
        "triangles":   [0, 1, 2, ...]
     }
     @method toJSON
     @return {JSON}
     @since 1.16.0
     **/
    toJSON: function() {
        var meshData = {};
        meshData['vertices'] = this._impl._vertices;
        meshData['triangles'] = this._impl._triangles;
        return meshData;
    },

    /**
    @implements IDebuggable
    @method debug
    @since 1.8.0
    **/
    debug: function() {
        Debug.triangles(this._impl._vertices, this._impl._triangles);
    }
};


/*
Boolean meshes together and generate the resulting one in a new mesh
@method meshBoolean
*/
function meshBoolean(op, srcMesh, meshes, callback){

    callback = callback || function(){};
    if(!Array.isArray(meshes)){
        meshes = [meshes];
    }

    var incorrectMeshes = [];
    if(!srcMesh._impl._isWindingOrderCorrect()){
        incorrectMeshes.push("source mesh");
    }
    for(var k = 0; k < meshes.length; k++){
        if(!(meshes[k] instanceof Mesh3D)){
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        if(!meshes[k]._impl._isWindingOrderCorrect()){
            incorrectMeshes.push("meshes["+k+"]");
        }
    }
    if(incorrectMeshes.length > 0){
        var str = "Inward pointing normals detected by right hand rule on meshes (" + incorrectMeshes.join(',') + ")."
        Plugin.warning(str);
    }

    var srcBSP = getBSP(srcMesh);
    var opBSP;
    for(var i = 0; i < meshes.length; i++){
        opBSP = getBSP(meshes[i]);
        srcBSP = srcBSP[op](opBSP);
    }

    var mesh = buildMesh3D(srcBSP);
    mesh = MeshInspector.repair(mesh, [RepairOptionEnum.NONMANIFOLD_EDGES]);

    callback(mesh);
};


/*
Get the bsp if there is a cached one or call buildBSP.
We use the internal static function here because we want to
conceal BSP as an internal implementation
@method getBSP
*/
function getBSP(mesh){

    if (mesh.attributes['bsp'] !== undefined &&
        mesh.attributes['bsp']['data'] !== undefined){
        return mesh.attributes['bsp']['data'];
    }

    // Bind the  handler the very first time when the prop is not there
    if (undefined === mesh.attributes['bsp']) {
        mesh.change.bind(bspCacheHandler);
    }

    var bsp = buildBSP(mesh);
    var cache = { 'data' :  bsp};
    mesh.attributes['bsp'] = cache;
    return bsp;

}


/*
Build internal BSP structure from Mesh3D. If there is a cached one, use it
@method buildBSP
*/
function buildBSP(mesh){

    var Tris = mesh._impl._triangles;
    var Verts = mesh._impl._vertices;
    var ntris = Tris.length / 3;

    var polygons = [];
    var n;
    function vertex(v, n) {
        var pos = [Verts[3*v], Verts[3*v+1], Verts[3*v+2]];
        return new CSG.Vertex(pos, n);
    }
    function normal(t){
        var tri0 = Tris[3*t]*3;
        var tri1 = Tris[3*t+1]*3;
        var tri2 = Tris[3*t+2]*3;
        var point0 = [Verts[tri0], Verts[tri0+1], Verts[tri0+2]];
        var point1 = [Verts[tri1], Verts[tri1+1], Verts[tri1+2]];
        var point2 = [Verts[tri2], Verts[tri2+1], Verts[tri2+2]];
        var e01 = new CSG.Vector([(point1[0] - point0[0]), (point1[1] - point0[1]), (point1[2] - point0[2])]);
        var e02 = new CSG.Vector([(point2[0] - point0[0]), (point2[1] - point0[1]), (point2[2] - point0[2])]);
        var n = e01.cross(e02).unit();
        return n;
    }
    for (var t = 0; t < ntris; t++) {
        n = normal(t);
        polygons.push(new CSG.Polygon([vertex(Tris[3*t], n), vertex(Tris[3*t+1], n), vertex(Tris[3*t+2], n)]));
    }
    var bsp = CSG.fromPolygons(polygons);
    return bsp;
};

/*
Build Mesh3D structure from internal BSP structure
@method buildMesh3D
*/
function buildMesh3D (bsp){
    var polygons = bsp.toPolygons();
    var mesh = new Mesh3D();

    function point(v){
        var pos = v.pos;
        return [pos.x, pos.y, pos.z];
    }

    var vertices, start;
    for(var i =0, t = polygons.length; i < t; i++){
        vertices = polygons[i].vertices;
        start = vertices[0];
        for(var j = 1, vt = vertices.length-1; j < vt; j++){
            mesh.triangle(point(start), point(vertices[j]), point(vertices[j+1]));
        }
    }

    // Cache the bsp
    var cache = { 'data' :  bsp};
    mesh.attributes['bsp'] = cache;

    return mesh;
};


/**
Internal class to wrap up topology related stuffs.
@class _Topology
@static
@private
**/
var _Topology = {
    /**
    Get/Create Topology Body for specific mesh object.
    @method body
    @param {Mesh3D} mesh The Mesh3D object.
    @return {Body}
    @private
    **/
    body: function(mesh) {
        if (mesh.attributes['body'] !== undefined &&
            mesh.attributes['body']['data'] !== undefined){
            return mesh.attributes['body']['data'];
        }

        // Bind the  handler the very first time when the prop is not there
        if (undefined === mesh.attributes['body']) {
            mesh.change.bind(this._bodyCacheHandler);
        }

        var body = this._makeBody(mesh);
        var cache = { 'data' :  body};
        mesh.attributes['body'] = cache;
        return body;
    },

    /**
    Create filter object which will be used in eachEdge and eachFace for traversing items in the collection.
    @method filterObject
    @param {Function} filter The filter method.
    @param {Function} callback The callback.
    @return {Object}
    @private
    **/
    filterObject: function(filter, callback) {
        var fo = {
            filter: filter,
            callback: callback
        };
        return fo;
    },

    /**
    Traverse winged edge in the body.
    @method eachEdge
    @param {Body} body The Body object.
    @param {Object} edgeFilter The filter object.
    @private
    **/
    eachEdge: function(body, edgeFilter) {
        var edges = body.edgeHash;
        var keys = Object.keys(edges);
        keys.forEach(function(key) {
            var edge = edges[key];
            var filter = edgeFilter.filter;
            var callback = edgeFilter.callback;
            var result = filter(edge);
            callback(result);
        });
    },

    /**
    Gets a particular edge by its vertices
    @method edgeOfVertices
    @param {Body} body The Body object.
    @param {Number} vstart The starting vertex.
    @param {Number} vend The ending vertex.
    @private
    @return {Edge} The edge object, or null if does not exist.
    **/
    edgeOfVertices: function(body, vstart, vend) {
        return body.edgeHash[this._hashOfEdge({v0: vstart, v1: vend})];
    },

    /**
    Get mesh boundaries from specific unsorted edges.
    @method edgeBoundaries
    @param {Body} body The Body object.
    @param {Array[Edge]} edges An array of disconnected edges.
    @return {Array[Mesh3DBoundary]}
    @private
    **/
    edgeBoundaries: function(body, edges) {

        var findEdgeBoundaries = function (edges) {
            var boundaries = [];
            var badEdges = [];

            while(true) {
                if(edges.length < 1) {
                    break;
                }

                var sorted = [];
                var seed = edges.pop();
                sorted.push(seed);

                var found = false;
                while(!found) {
                    var foundOne = false;
                    for (var i = edges.length - 1; i >= 0; i--) {
                        var cur = edges[i];

                        if(cur.v0 === sorted[sorted.length-1].v1) {
                            edges.splice(i, 1);
                            sorted.push(cur);
                            foundOne = true;
                            if(cur.v1 === sorted[0].v0) {
                                found = true;
                            }
                            break;
                        }
                    }

                    var poplast = false;
                    if(!foundOne) {
                        var badEdge = sorted.pop();
                        badEdges.push(badEdge);

                        if(edges.length > 0 && sorted.length === 0) {
                            poplast = true;
                            seed = edges.pop();
                            sorted.push(seed);
                        }
                    }

                    if(edges.length === 0 && !poplast) {
                        break;
                    }

                };

                boundaries.push(sorted);
            };

            return boundaries;
        };

        var edgeBoundaries = findEdgeBoundaries(edges);

        var meshBoundaries = [];
        for(var i = 0; i < edgeBoundaries.length; i++) {
            var edgeBoundary = edgeBoundaries[i];
            var meshBoundary = new Mesh3DBoundary();
            meshBoundary.mesh = body.mesh;
            for(var j = 0; j < edgeBoundary.length; j++) {
                var edge = edgeBoundary[j];
                meshBoundary.vertexIndices.push(edge.v0);
            }
            meshBoundaries.push(meshBoundary);
        }

        return meshBoundaries;
    },

    /**
    Get the sense of the edge.
    positive sense means that it starts from smaller vertex index.
    @method positive
    @private
    **/
    isPositiveEdge: function(edge) {
        return edge.v0 < edge.v1;
    },

    /**
    The handler for removing body cache in attributes
    @method _bodyCacheHandler
    @private
    **/
     _bodyCacheHandler: function(event){
        if (event.data instanceof Mesh3D) {
            var mesh = event.data;
            delete mesh.attributes['body']['data'];
        }
    },

    /**
    Create Topology Body for specific mesh object.
    @method _makeBody
    @param {Mesh3D} mesh The Mesh3D object.
    @return {Body}
    @private
    **/
    _makeBody: function(mesh3d) {
        var body = {
            mesh: mesh3d,
            edgeHash: {}
        };
        var mesh = body.mesh;
        if(!mesh) {
            return null;
        }

        var verts = mesh._impl._vertices;
        var tris  = mesh._impl._triangles;

        for(var i = 0, ntris = tris.length; i < ntris; i += 3) {
            var vis = [tris[i], tris[i+1], tris[i+2]];

            // Create a new face
            var faceEdges = [];
            var face = i/3;
            for (var j = 0; j < 3; j ++) {
                var vi0 = vis[j];
                var vi1 = vis[(j + 1) % 3];
                var hash = this._hashOfEdge({
                    v0: vi0,
                    v1: vi1
                });

                var edge = body.edgeHash[hash];
                if(edge) {
                    // This mesh is non-manifold.
                    edge.faces.push(face);

                } else {
                    // New Edge on the face
                    var edge = {
                        body: body,
                        v0:   vi0,
                        v1:   vi1,
                        sym:  null,
                        faces: [face]
                    };
                    body.edgeHash[hash] = edge;
                }

                faceEdges.push(edge);
            }

            for(var k = 0, nedge = faceEdges.length; k < nedge; k++) {
                var edge = faceEdges[k];

                // Symmetric Edge
                var symHash = this._hashOfEdge({
                    v0: edge.v1,
                    v1: edge.v0
                });
                var symEdge = body.edgeHash[symHash];
                edge.sym = symEdge;
                if(symEdge) {
                    symEdge.sym = edge;
                }
            }
        }
        return body;
    },

    /**
    Get hash code for edge
    min-max:true  positive edge
    min-max:false its symmetric edge
    @method _hashOfEdge
    @private
    **/
    _hashOfEdge: function(e) {
        var start, end;
        var v0 = e.v0;
        var v1 = e.v1;
        var positive = v0 < v1;
        if(positive) {
            start = v0;
            end = v1;
        } else {
            start = v1;
            end = v0;
        }
        return start + '-' + end + ':' + positive;
    }
};


/*
The handler for removing bsp cache in attributes
@method bspCacheHandler
*/
function bspCacheHandler(event){
    if (event.data instanceof Mesh3D) {
        var mesh = event.data;
        delete mesh.attributes['bsp']['data'];
    }
};


/*
The handler for removing edges cache in attributes
@method edgesChangeHandler
*/
function edgesCacheHandler(event){
    if (event.data instanceof Mesh3D) {
        var mesh = event.data;
        delete mesh.attributes['edges']['data'];
    }
};

/*
The handler for removing bounds cache in attributes
@method boundsChangeHandler
*/
function boundsCacheHandler(event){
    if (event.data instanceof Mesh3D) {
        var mesh = event.data;
        delete mesh.attributes['bounds']['data'];
    }
};

/*
The handler for removing boundaries cache in attributes
@method boundariesChangeHandler
*/
function boundariesCacheHandler(event){
    if (event.data instanceof Mesh3D) {
        var mesh = event.data;
        delete mesh.attributes['boundaries']['data'];
    }
};

initializeObjectMethods(Mesh3D, 'Mesh3D');

Library.exports.Mesh3D = Mesh3D;


//meshinspector.js
var repairNonmanifoldEdges = (function(){

function assert(r){
  if(!r){
    // Debug.log("Assert Fail.");
  }
}
function log(str){
  //Debug.log(str);
}
function roughly(a, b){
  return Math.abs(a-b) < 1e-6;
}

function getIndexedObject(mesh) {
  var points = [];
  var faces = [];

  var triangles = mesh._impl._triangles;
  for(var i = 0, ntris = triangles.length / 3; i < ntris; i ++) {
      faces.push([triangles[3*i], triangles[3*i+1], triangles[3*i+2]]);
  }

  var vertices = mesh._impl._vertices;
  for(var i = 0, tot = vertices.length / 3; i < tot; i ++) {
      points.push(new Vector3D(vertices[3*i], vertices[3*i+1], vertices[3*i+2]));
  }

  return {faces:faces, points:points};
}

function EdgeEntity(guid, p0, p1) {
  this.guid = guid;
  this.p0 = p0;
  this.p1 = p1;
  this.faces = [];
}

function EdgeData() {
  this.edgeMap = {};
}

EdgeData.prototype.edgeForGuid = function(guid) {
  if (guid in this.edgeMap)
    return this.edgeMap[guid];
  return null;
};

EdgeData.prototype.guidForEdge = function(p0, p1) {
  if (p1 < p0) {
    var temp = p0;
    p0 = p1;
    p1 = temp;
  }
  return p0 + "edge" + p1;
};

EdgeData.prototype.edgeForPoints = function(p0, p1) {
  return this.edgeForGuid(this.guidForEdge(p0, p1));
};

EdgeData.prototype.addFace = function(face) {
  for (var i = 0; i < face.length; ++i) {
    this.addEdge(face[i], face[(i + 1) % face.length], face);
  }
};

EdgeData.prototype.addEdge = function(p0, p1, face) {
  assert(face);
  var guid = this.guidForEdge(p0, p1);
  var edge = this.edgeForGuid(guid);
  if (!edge) {
    edge = this.edgeMap[guid] = new EdgeEntity(guid, p0, p1);
  }
  assert(edge.faces.length < 2);
  edge.faces.push(face);
  return edge;
};

EdgeData.prototype.deleteEdge = function(edge) {
  var guid = this.guidForEdge(edge.p0, edge.p1);
  assert(guid in this.edgeMap);
  assert(edge == this.edgeMap[guid]);
  delete this.edgeMap[guid];
};

EdgeData.prototype.edgeList = function() {
  var l = [];
  for (var e in this.edgeMap) {
    l.push(this.edgeMap[e]);
  }
  return l;
};

function Partitioner() {
  this.idToSetMap = {};
  this.pointToIDMap = {};
  this.lastID = 0;
};

Partitioner.prototype.setList = function() {
  var l = [];
  for (var i in this.idToSetMap) {
    l.push(this.idToSetMap[i]);
  }
  return l;
};

Partitioner.prototype.newSetID = function() {
  return ++this.lastID;
};

Partitioner.prototype.addEdge = function(edge) {
  var set, setID;
  if (edge.p0 in this.pointToIDMap) {
    setID = this.pointToIDMap[edge.p0];
    set = this.idToSetMap[setID];
    set.push(edge);
    if (!(edge.p1 in this.pointToIDMap)) {
      this.pointToIDMap[edge.p1] = setID;
    } else if (setID != this.pointToIDMap[edge.p1]) {
      this.mergeSetsForEdge(edge);
    }
  } else if (edge.p1 in this.pointToIDMap) {
    setID = this.pointToIDMap[edge.p1];
    set = this.idToSetMap[setID];
    set.push(edge);
    this.pointToIDMap[edge.p0] = setID;
  } else {
    setID = this.newSetID();
    this.idToSetMap[setID] = [edge];
    this.pointToIDMap[edge.p0] = this.pointToIDMap[edge.p1] = setID;
  }
};

Partitioner.prototype.mergeSetsForEdge = function(edge) {
  var setID = this.pointToIDMap[edge.p0];
  var setToConvertID = this.pointToIDMap[edge.p1];
  var set = this.idToSetMap[setID];
  var setToConvert = this.idToSetMap[setToConvertID];
  for (var edgeIndex in setToConvert) {
    var e = setToConvert[edgeIndex];
    assert(this.pointToIDMap[e.p0] == setID ||
           this.pointToIDMap[e.p0] == setToConvertID);
    this.pointToIDMap[e.p0] = setID;
    assert(this.pointToIDMap[e.p1] == setID ||
           this.pointToIDMap[e.p1] == setToConvertID);
    this.pointToIDMap[e.p1] = setID;
    set.push(e);
  }
  delete this.idToSetMap[setToConvertID];
};

function nearParallel(v0, v1) {
  var dot = v0.dot(v1);
  var abs = Math.abs(Math.abs(dot) - 1);
  return abs < .00001;
}

function pointNearLine(point, linePoint, lineVector) {
  var v0 = linePoint.clone().subtract(point);
  var v1 = lineVector.clone().scale(v0.dot(lineVector));
  return v0.subtract(v1).length() < .00001;
}

function groupCollinear(index, connectedSets) {
  var problemSets = [];
  var s;
  for (s in connectedSets) {
    var set = connectedSets[s];
    var problemSetsForSet = [];
    // Compare unit vectors to see that they're near-parallel, then check a
    // point on the edge to see that it's near the current set's first
    // line.  If it's a match, add the edge to that set.  If not, keep looking.
    // If you don't find one, create a new edge set, and let this be the
    // archetypical edge for that set.
    // Note that these collinear sets may still represent multiple problems, and
    // may or may not be directly connected, but our fixup algorithm should be
    // able to handle that.
    var e;
    for (e in set) {
      var edge = set[e];
      var p0V = index.points[edge.p0];
      var p1V = index.points[edge.p1];
      var group = null;
      var p0AlongOffset;
      var p1AlongOffset;
      edge.unitV = p1V.clone().subtract(p0V).normalize();
      for (var ps in problemSetsForSet) {
        var psP0V = problemSetsForSet[ps].p0V;
        var psUnitV = problemSetsForSet[ps].unitV;
        if (nearParallel(edge.unitV, psUnitV) &&
            pointNearLine(p0V, psP0V, psUnitV)) {
          group = problemSetsForSet[ps];
          p0AlongOffset = p0V.clone().subtract(psP0V).dot(psUnitV);
          p1AlongOffset = p1V.clone().subtract(psP0V).dot(psUnitV);
          break;
        }
      }

      // This code stores information about the edges and their points.  The
      // underlyin point indices [and therefore their locations] may be
      // referenced by other sets, but the data structures here aren't shared,
      // so there can be multiple records with different distances and edges for
      // a given point index, where different sets cross at an angle at the
      // point.
      if (!group) {
        p0AlongOffset = 0;
        p1AlongOffset = p1V.clone().subtract(p0V).dot(edge.unitV);
        group = {
          unitV: edge.unitV,
          p0V: p0V,
          points: {}
        };
        problemSetsForSet.push(group);
      }
      if (!group.points[edge.p0]) {
        group.points[edge.p0] = {
          index: edge.p0,
          distance: p0AlongOffset,
          followingEdges: []
        }
      }
      if (!group.points[edge.p1]) {
        group.points[edge.p1] = {
          index: edge.p1,
          distance: p1AlongOffset,
          followingEdges: []
        }
      }
      // Track the direction of the edge from p0 for later code that needs to
      // know whether we've processed past it or not.  The direction from p1 is
      // just the opposite.
      assert(group);
      assert(p0AlongOffset != p1AlongOffset);
      if (p0AlongOffset < p1AlongOffset) {
        group.points[edge.p0].followingEdges.push(edge);
      } else {
        group.points[edge.p1].followingEdges.push(edge);
      }
    }
    problemSets = problemSets.concat(problemSetsForSet);
  }
  return problemSets;
}

function doRepair(problemSets, edgeData) {
  var s, set;
  for (s in problemSets) {
    set = problemSets[s];

    // Get a list of points in this set sorted by distance along the unit
    // vector.
    var points = [];
    var p;
    for (p in set.points) {
      assert(set.points[p].followingEdges.length <= 2);
      points.push(set.points[p]);
    }
    points.sort(function(a, b) { return a.distance - b.distance; });
    var i;
    for (i = 0; i < points.length; ++i) {
      var j, k;

      // Each fixup starting point should have two following edges.  If this
      // point has zero, it's a finishing point.  If it's got any other number,
      // something's wrong.
      var point = points[i];
      if (!point.followingEdges.length) {
        continue;
      }
      if (point.followingEdges.length == 1 &&
          point.followingEdges[0].faces.length == 2) {
        continue;
      }
      if(point.followingEdges.length != 2){
        continue;
      }

      assert(point.followingEdges.length == 2);
      assert(point.followingEdges[0].faces.length ==
             point.followingEdges[1].faces.length);
      assert(point.followingEdges[0].faces.length == 1);
      assert(i + 2 < points.length); // Can't have this problem with < 3 points.

      // The next point [point i + 1] must be on one of those edges.  The
      // other edge [ending at point K] is the one we need to break.
      var breakPoint = points[i + 1];
      var e0 = point.followingEdges[0];
      var e1 = point.followingEdges[1];
      assert(e0.p0 == point.index || e0.p1 == point.index);
      assert(e1.p0 == point.index || e1.p1 == point.index);
      assert(e0.p0 == breakPoint.index || e0.p1 == breakPoint.index ||
             e1.p0 == breakPoint.index || e1.p1 == breakPoint.index);
      var edgeToBreak;
      var edgeToKeep;
      if (e1.p0 == breakPoint.index || e1.p1 == breakPoint.index) {
        edgeToBreak = e0;
        edgeToKeep = e1;
      } else {
        edgeToBreak = e1;
        edgeToKeep = e0;
      }
      var otherPointIndex;
      if (edgeToBreak.p0 == point.index) {
        otherPointIndex = edgeToBreak.p1;
      } else {
        otherPointIndex = edgeToBreak.p0;
      }

      // Find the face from that edge and fix it.
      assert(edgeToBreak.faces.length == 1);
      var faceToHeal = edgeToBreak.faces[0];

      // We have to modify the face along this edge, so we need to find where in
      // the face's array of points this edge occurs.
      var insertAfter = -1;
      for (var b = 0; b < faceToHeal.length; ++b) {
        var next = (b + 1) % faceToHeal.length;
        var pointBefore = faceToHeal[b];
        var pointAfter = faceToHeal[next];
        if ((pointBefore == edgeToBreak.p0 ||
             pointBefore == edgeToBreak.p1) &&
            (pointAfter == edgeToBreak.p0 ||
             pointAfter == edgeToBreak.p1)) {
          insertAfter = b;
          break;
        }
      }
      assert(insertAfter != -1);

      // Insert the point in the face.
      faceToHeal.splice(insertAfter + 1, 0, breakPoint.index);
      // Add a reference to the altered face to the existing edge now linked
      // from the other face.  We'll probably never refer to it, but it keeps
      // the data structures clean.
      edgeToKeep.faces.push(faceToHeal);
      // Remove the old edge.
      if (point.followingEdges[0] == edgeToBreak) {
        point.followingEdges.splice(0, 1);
      } else {
        assert(point.followingEdges[1] == edgeToBreak);
        point.followingEdges.splice(1, 1);
      }
      // Look up or create the new lower edge.  If it exists already, the local
      // problem may be totally fixed, or we may have a complex case that we'll
      // work on more next time through the loop.  If not, it's a nonmanifold
      // edge, and we need to continue on fixing this local problem.
      assert(otherPointIndex != point.index);
      var newEdge = edgeData.edgeForPoints(breakPoint.index, otherPointIndex);
      if (!newEdge) {
        // Here's a new nonmanifold edge; we'll detect and fix it next
        // iteration.
        newEdge = edgeData.addEdge(breakPoint.index, otherPointIndex,
            faceToHeal);
        breakPoint.followingEdges.push(newEdge);
      } else {
        newEdge.faces.push(faceToHeal);
      }
      edgeData.deleteEdge(edgeToBreak);
    }
  }
}

function triangulate(index) {
  var faces = [];
  for (var i = 0; i < index.faces.length; ++i) {
    var face = index.faces[i];
    if (face.length == 3) {
      // Copy, just to keep it clean.
      faces.push(face);
      continue;
    }
    assert(face.length > 3);
    if (face.length > 4) {
      // Copy it, because we'll need to process it multiple times.
      face = face.slice();
    }
    var units = [];
    for (var j = 0; j < face.length; ++j) {
      var p0 = index.points[face[j]];
      var p1 = index.points[face[(j + 1) % face.length]];
      units.push(p1.clone().subtract(p0).normalize());
    }
    var dots = [];
    for (var j = 0; j < face.length; ++j) {
      var dot = units[j].dot(units[(j + 1) % units.length]);
      dots.push(dot);
    }
    var findSplitPoint = function () {
      // When you have a bunch of collinear points, you need to split at the end
      // of that line.  Also, beware that line wrapping around the end.
      // SplitPoint will be the first of the three points of the new triangle,
      // as the dot array at i is the dot of i->(i+1) and (i+1)->(i+2).
      var maxDot = -2;
      var maxDotIndex = -1;
      var foundFlat = false;
      for (var j = 0; j < face.length; ++j) {
        var dot = dots[j];
        if (maxDotIndex == -1 || dot >= maxDot ||
            (foundFlat && roughly(1, dot))) {
          maxDot = dot;
          maxDotIndex = j;
        } else if (foundFlat) {
          return j;
        }
        if (roughly(1, dot)) {
          foundFlat = true;
        }
      }
      assert(maxDot > -1);
      return maxDotIndex;
    }
    var splitPoint = findSplitPoint();
    while (face.length > 3) {
      var i1 = (splitPoint + 1) % face.length;
      var i2 = (splitPoint + 2) % face.length;
      faces.push([face[splitPoint], face[i1], face[i2]]);
      face.splice(i1, 1);
      if (face.length > 3) {
        dots.splice(i1, 1);
        splitPoint = findSplitPoint();
      }
    }
    faces.push(face);
  }
  return { points: index.points, faces: faces};
}

function getRepairedTriangularShape(mesh) {
  var index = getIndexedObject(mesh);
  // index has {
  //             points: array of Point3D
  //             faces: array of arrays of point indices

  // Generate tables mapping edge -> [face] and edge -> (p0, p1).
  var edgeData = new EdgeData();
  var i;
  for (i in index.faces) {
    edgeData.addFace(index.faces[i]);
  }

  // Find the set of edges that belong to only one face
  var edgeList = edgeData.edgeList();
  var nonManifoldEdges = [];
  for (i in edgeList) {
    var e = edgeList[i];
    if (e.faces.length != 2) {
      nonManifoldEdges.push(e);
    }
  }

  if (!nonManifoldEdges.length) {
    log("Design is clean.");
    return undefined; 
  }

  // for that set, break it into connected subsets
  // map from point->set of edges.
  var partitioner = new Partitioner();
  var e;
  for (e in nonManifoldEdges) {
    partitioner.addEdge(nonManifoldEdges[e]);
  }

  // For each subset, group them by collinearity to find the individual problem
  // edge sets to fix.
  var connectedSets = partitioner.setList();
  var problemSets = groupCollinear(index, connectedSets);
  log("Found " + nonManifoldEdges.length + " non-manifold edge(s), "
      + connectedSets.length + " connected set(s), "
      + problemSets.length + " individual problem sets.");

  // This modifies the entries in index.faces in-place by reference.
  doRepair(problemSets, edgeData);

  return triangulate(index);
}

function _repairNonmanifoldEdges(mesh) {
  var start = new Date();
  log("RepairNonmanifoldEdges begin: input triangles " + mesh._impl._triangles.length/3);
  var shape = getRepairedTriangularShape(mesh);
  var newMesh;
  if(shape){
    newMesh = new Mesh3D();
    shape.faces.map(
        function (face, pos) {
          var vertices = face.map(
              function(pointIndex) {
                return shape.points[pointIndex];
              });
          newMesh.triangle(vertices[0].x, vertices[0].y, vertices[0].z,
                  vertices[1].x, vertices[1].y, vertices[1].z,
                  vertices[2].x, vertices[2].y, vertices[2].z);
        });
  }
  else{
    newMesh = mesh; // Return the original mesh if there is no fix applied.
  }
  
  log("RepairNonmanifoldEdges end: used "+(new Date()-start)+" ms, output triangles " + newMesh._impl._triangles.length/3);
  return newMesh;
}

return _repairNonmanifoldEdges;
})();

/**
The repair option
@enum RepairOptionEnum
@type String
@static
@private
**/
var RepairOptionEnum = {
    
    /**
    @property NONMANIFOLDE_EDGES
    @readonly
    **/
    NONMANIFOLD_EDGES : 1
};

/**
Mesh inspector namespace
@class MeshInspector
@static
@private
**/
var MeshInspector = {
  /**
  Repair the passed in mesh and return the repaired one.
  @method repair
  @param {Mesh3D} mesh
  @param {Array[RepairOptionEnum]} options
  @return {Mesh3D}
  @static
  @private
  **/
  repair: function(mesh, options){
    if(options.indexOf(RepairOptionEnum.NONMANIFOLD_EDGES) !== -1){
      return repairNonmanifoldEdges(mesh);
    }
  }
}

//curve2d.js
/**   
A base class for all 2D curve types.
It points at a certain curve in the path2D by the index,  and helps to navigate through the curve list within Path2D
@class Curve2D
@since 1.1.0
**/
var Curve2D = function(index, path){

  /**
  The index of the curve inside the Path2D
  @private 
  @property {Number} index
  **/
  this.index = index || 0;

  /**
  The Path2D object that the curve holds
  @private 
  @property {Path2D} path
  **/
  this.path = path;

};

Curve2D.prototype = {
    
    /**
    Removes this curve from the owning Path2D.
    @method remove
    @since 1.1.0
    @chainable
    **/
    remove: function(){
        this.path._impl._removeCurve(this.index);
        return this;
    },

    /**
    Gets the next curve which can be an instance of Line2D or Bezier2D
    @method next
    @since 1.1.0
    @return {Curve2D}
    @example

    // Iterate the Path2D data using Curve2D
    var curve2DObj = path2d.firstCurve();
    while (curve2DObj) {
        if (curve2DObj instanceof Line2D) {
          ...
        } else if (curve2DObj instanceof Bezier2D) {
          ...
        }
        curve2DObj = curve2DObj.next();
    }
    **/
    next: function(){
        var nextIdx = this.path._impl._nextCurve(this.index);
        return this.path.curveAt(nextIdx);
    },

    /**
    Gets the prev curve which can be an instance of Line2D or Bezier2D
    @method prev
    @since 1.1.0
    @return {Curve2D}
    **/
    prev: function(){
        var lastIdx = this.path._impl._prevCurve(this.index);
        return this.path.curveAt(lastIdx);
    },

    /**
    Checks whether this curve is removed
    @method isRemoved
    @since 1.1.0
    @return {Boolean}
    **/
    isRemoved: function(){
        return this.path._impl._isRemoved(this.index);
    }

}
//point2d.js
/**   
A point in 2D Space.
@param {Number} x The X component of the point.
@param {Number} y The Y component of the point.
@class Point2D
@since 1.1.0
@constructor
**/
var Point2D = function(x, y){

    /**
    The X position of the point
    @property {Number} x
    @since 1.1.0
    **/
    this.x = x;


    /**
    The Y position of the point
    @property {Number} y
    @since 1.1.0
    **/
    this.y = y;

};

Point2D.prototype = {    

    /**
    Creates a copy of the object and returns it.
    @method clone
    @return {Point2D}
    @since 1.1.0
    **/
    clone: function(){
        return new Point2D(this.x, this.y);
    },

    /**
    Returns true if the objects are equal within tolerance (1e-6), otherwise false.
    @method equals
    @param {Point2D|Object} other An object to compare this object to.
    @return {Boolean}
    @since 1.1.0
    **/
    equals: function(point){
        return resabs(this.x, point.x) && 
               resabs(this.y, point.y);
    },

    /**
    Moves the point in the direction specified.
    @method move
    @param {Vector2D|Number|Array[Number]} direction A direction of movement defined by a Vector2D, an Array with 2 values (X and Y), or a number representing the X offset.
    @param {Number} [y] The Y offset to move in, when only the X offset is specified as the first argument.
    @chainable
    @since 1.1.0
    @example

    // Move the point by given a Vector2D object
    var vec = new Vector2D(-1, -1);
    point.move(vec);

    @example

    // Move the point by given a 2-element array
    var arr = [-1, -1];
    point.move(arr);

    @example

    // Move the point by given x, y offsets
    var xoffset = -1,
        yoffset = -1;
    point.move(xoffset, yoffset);

    **/
    move: function(dir, y){
        if (dir instanceof Vector2D) {
            this.x += dir.x;
            this.y += dir.y;
        } else if (Array.isArray(dir) && dir.length === 2) {
            this.x += dir[0];
            this.y += dir[1];
        } else if (typeof(dir) === 'number' && typeof(y) === 'number'){
            this.x += dir;
            this.y += y;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;
    },

    /**
    Rotates the point around an optionally specified point.  If no origin is specified then 0,0 is assumed. 
    Right-handed system is used implying the positive angles result in counter-clockwise orientations.
    @method rotate
    @param {Number} angle The angle of rotation in radians
    @param {Point2D|Number|Array[Number]} [origin] An optional origin of rotation defined by a Point2D, an Array with 2 values (X and Y), or a number representing the X value.
    @param {Number} [y] The Y position to rotate around, when only the X offset is specified in the previous argument.
    @chainable
    @since 1.1.0
    @example

    // Rotate the point by given angle around the default 0,0 point as origin
    point.rotate(Math.PI/2);

    @example

    // Rotate the point by given angle and the origin specified in a 2-element array
    point.rotate(Math.PI/2, [1, 1]);

    @example

    // Rotate the point by given angle and the origin specified in the 2nd and 3rd arguments
    point.rotate(Math.PI/2, 1, 1);
    **/
    rotate: function(angle, origin, y) {

        var originX = 0;
        var originY = 0;
        
        if (typeof(angle) !== 'number'){
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        if (undefined !== origin) {
            if (origin instanceof Point2D) {
                originX = origin.x;
                originY = origin.y;
            } else if (Array.isArray(origin) && origin.length === 2){
                originX = origin[0];
                originY = origin[1];
            } else if (typeof(origin) === 'number' && typeof(y) === 'number'){
                originX = origin;
                originY = y;
            } else {
                Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
            }
        }

        var cosA = Math.cos(angle);
        var sinA = Math.sin(angle);

        var newX = cosA * (this.x - originX) - sinA * (this.y - originY) + originX;
        var newY = sinA * (this.x - originX) + cosA * (this.y - originY) + originY;

        this.x = newX;
        this.y = newY;

        return this;
    },

    /**
    Calculates the distance to another point
    @method distanceTo
    @param {Point2D} point the other point
    @return {Number}
    @since 1.1.0
    **/
    distanceTo: function(point) {
        var distSquared = (point.x - this.x) * (point.x - this.x) +
                          (point.y - this.y) * (point.y - this.y);

        return Math.sqrt(distSquared);
    },

    /**
    Scales the location of the point.
    @method scale
    @param {Vector2D|Array[Number]|Number} scale A scale defined by a Vector2D, an Array with 2 values (X and Y), or a number representing the X scale (and Y scale if no additional parameter is specified.)
    @param {Number} [y] An option Y scale to use if an X scale was specified as the first argument.  If this argument is not specified then uniform scaling is assumed.
    @chainable
    @since 1.1.0
    @example

    // Scale the point by given one scale number uniformly
    point.scale(0.5);

    @example

    // Scale the point by given X and Y scale numbers
    point.scale(0.5, 0.75);

    @example

    // Scale the point by given a Vector2D object
    var vec = new Vector2D(0.5, 0.75);
    point.scale(vec);

    @example

    // Scale the point by given a 2-element array with X and Y scale numbers
    point.scale([0.5, 0.75]);
    **/
    scale: function(scale, y){
        if (scale instanceof Vector2D) {
            this.x *= scale.x;
            this.y *= scale.y;
        } else if (Array.isArray(scale) && scale.length === 2) {
            this.x *= scale[0];
            this.y *= scale[1];
        } else if (typeof(scale) === 'number') {
            var yScale = scale;
            if (typeof(y) === 'number'){
                yScale = y;
            }
            this.x *= scale;
            this.y *= yScale;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;
    },

    /** 
    Transforms the point by a transformation matrix.
    @method transform
    @param {Matrix2D|Array[Number]} matrix A Matrix or an Array of 9 numbers.
    @return {Point2D}
    @since 1.1.0
    @chainable  
    @example

    // Transform the point (x, y) by given a 9-element array 
    tm = [a, b, 0, c, d, 0, e, f, 1] representing following matrix
    [a b 0] 
    [c d 0]
    [e f 1]  
    new coordinates would be (a*x + c*y + e, b*x + d*y + f)

    point.transform(tm);

    @example

    // Transform the point by given a Matrix2D object
    point.transform(tm);
    **/
    transform: function(tm) {

        if (Array.isArray(tm) && tm.length === 9) {
            var newX = this.x * tm[0] + this.y * tm[3] + tm[6];
            var newY = this.x * tm[1] + this.y * tm[4] + tm[7];
            this.x = newX;
            this.y = newY;
        } else if (tm instanceof Matrix2D) {
            var newX = this.x * tm.elements[0] + this.y * tm.elements[3] + tm.elements[6];
            var newY = this.x * tm.elements[1] + this.y * tm.elements[4] + tm.elements[7];
            this.x = newX;
            this.y = newY;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        
        return this;
    },

    /**
    @implements IDebuggable
    @method debug
    @since 1.6.0
    **/
    debug: function() {
        Debug.point(this.x, this.y, 0.0);
    }
}

initializeObjectMethods(Point2D, 'Point2D');

Library.exports.Point2D = Point2D;

//point3d.js
/**   
A point in 3D Space.
@param {Number} x The X component of the point.
@param {Number} y The Y component of the point.
@param {Number} z The Z component of the point.
@class Point3D
@since 1.1.0
@constructor
**/
var Point3D = function(x, y, z){

    /**
    The X position of the point
    @property {Number} x
    @since 1.1.0
    **/
    this.x = x;

    /**
    The Y position of the point
    @property {Number} y
    @since 1.1.0
    **/
    this.y = y;

    /**
    The Z position of the point
    @property {Number} z
    @since 1.1.0
    **/
    this.z = z;

};

Point3D.prototype = {    

    /**
    Creates a copy of the object and returns it.
    @method clone
    @return {Point3D}
    @since 1.1.0
    **/
    clone: function(){
        return new Point3D(this.x, this.y, this.z);
    },

    /**
    Returns true if the objects are equal within tolerance (1e-6), otherwise false.
    @method equals
    @param {Point3D|Object} other An object to compare this object to.
    @return {Boolean}
    @since 1.1.0
    **/
    equals: function(point){
        return resabs(this.x, point.x) && 
               resabs(this.y, point.y) && 
               resabs(this.z, point.z);
    },

    /** 
    Transforms the point by a transformation matrix, or an array containing the elements of a transformation matrix.
    @method transform
    @param {Matrix3D|Array[Number]} matrix A Matrix3D or an Array of 16 numbers to construct a Matrix3D from.
    @return {Point3D}
    @since 1.1.0
    @chainable
    **/
    transform: function(matrix){
        if (Array.isArray(matrix) && matrix.length === 16) {
            var newX = this.x * matrix[0] + this.y * matrix[4] + this.z * matrix[8] + matrix[12];
            var newY = this.x * matrix[1] + this.y * matrix[5] + this.z * matrix[9] + matrix[13];
            var newZ = this.x * matrix[2] + this.y * matrix[6] + this.z * matrix[10] + matrix[14];
            this.x = newX;
            this.y = newY;
            this.z = newZ;
        } else if (matrix instanceof Matrix3D) {
            var elements = matrix.elements;
            var newX = this.x * elements[0] + this.y * elements[4] + this.z * elements[8] + elements[12];
            var newY = this.x * elements[1] + this.y * elements[5] + this.z * elements[9] + elements[13];
            var newZ = this.x * elements[2] + this.y * elements[6] + this.z * elements[10] + elements[14];
            this.x = newX;
            this.y = newY;
            this.z = newZ
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        return this;
    },

    /**
    Calculates the distance to another point
    @method distanceTo
    @param {Point3D} point the other point
    @return {Number}
    @since 1.12.0
    **/
    distanceTo: function(point) {
        var distSquared = (point.x - this.x) * (point.x - this.x) +
                          (point.y - this.y) * (point.y - this.y) +
                          (point.z - this.z) * (point.z - this.z);

        return Math.sqrt(distSquared);
    },

    /**
    @implements IDebuggable
    @method debug
    @since 1.6.0
    **/
    debug: function() {
        Debug.point(this.x, this.y, this.z);
    }

}

initializeObjectMethods(Point3D, 'Point3D');

Library.exports.Point3D = Point3D;

//vector2d.js
/**   
A vector in 2D Space.
@param {Number} x The X magnitude of the vector.
@param {Number} y The Y magnitude of the vector.
@class Vector2D
@since 1.1.0
@constructor
**/
var Vector2D = function(x, y){

    /**
    The X magnitude of the vector.
    @property {Number} x
    @since 1.1.0
    **/
    this.x = x;

    /**
    The Y magnitude of the vector.
    @property {Number} y
    @since 1.1.0
    **/
    this.y = y;

};

Vector2D.prototype = {

    /**
    Creates a copy of this object and returns it.
    @method clone
    @return {Vector2D}
    @since 1.1.0
    **/
    clone: function(){
        return new Vector2D(this.x, this.y);
    },

    /**
    Returns true if the objects are equal, otherwise false.
    @method equals
    @param {Vector2D|Object} other An object to compare this object to.
    @return {Boolean}
    @since 1.1.0
    **/
    equals: function(vec){
        return resabs(this.x, vec.x) && 
               resabs(this.y, vec.y); 
    },

    /**
    The length of the vector.
    @method length
    @return {Number}
    @since 1.1.0
    **/
    length: function(){
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    /**
    Rotates this vector by the angle specified.
    Right-handed system is used implying the positive angles result in counter-clockwise orientations.
    @method rotate
    @param {Number} angle The angle of rotation in radians by clockwise
    @chainable
    **/
    rotate: function(angle){

        var cosA = Math.cos(angle);
        var sinA = Math.sin(angle);

        var newX = cosA * this.x - sinA * this.y;
        var newY = sinA * this.x + cosA * this.y; 

        this.x = newX;
        this.y = newY;

        return this;
    }, 

    /**
    Reduces the length of this vector to be 1.0 but maintains the X/Y ratio.
    @method normalize
    @chainable
    @since 1.1.0
    **/
    normalize: function(){
        var len = this.length();
        if (len !== 0) {
            this.x /= len;
            this.y /= len;
        }
        return this;
    },

    /**
    Calculates the counter-clockwise angle from this vector to a specified vector.  The returned value is in the range [ 0 , &pi; ] and ( -&pi; , 0 ).
    @method angle
    @param {Vector2D} other the other vector
    @return {Number}
    @since 1.1.0
    @example

    // Calculate the angle counter-clockwise to the specified vector
    var vec1 = new Vector2D(1, 1);
    var vec2 = new Vector2D(-1, 0);
    var vec3 = new Vector2D(0, -1);
    vec1.angle(vec2); //returns 3 * PI / 4;
    vec1.angle(vec3); //returns - 3 * PI / 4;
    **/
    angle: function(other){
        var angle = 0;
        var len1 = this.length();
        var len2 = other.length();
        if (len1 !== 0 && len2 !== 0) {
            var dot = this.dot(other);
            var cosA = dot / (len1 * len2);
            angle = Math.acos(cosA);

            var cross = this.cross(other);
            if (cross < 0) {
                angle = -angle;
            }
        }
        return angle;
    },

    /**
    Calculates the dot product of this vector with another vector.
    @method dot
    @param {Vector2D} other the other vector
    @return {Number}
    @since 1.1.0
    **/
    dot: function(other){
        return this.x * other.x + this.y * other.y;
    },

    /**
    Calculates the cross product of this vector with another vector.  Returns a new vector representing the cross product.
    @method cross
    @param {Vector2D} other the other vector
    @return {Number}
    @since 1.1.0
    **/
    cross: function(other){
        return this.x * other.y - this.y * other.x;
    },

    /**
    Scales the vector magnitude.
    @method scale
    @param {Vector2D|Array[Number]|Number} scale A scale defined by a Vector2D, an Array with 2 values (X and Y), or a number representing the X scale (and Y scale if no additional parameter is specified.)
    @param {Number} [y] An option Y scale to use if an X scale was specified as the first argument.  If this argument is not specified then uniform scaling is assumed.
    @chainable
    @since 1.1.0
    @example

    // Scale the vector by given one scale number uniformly
    vector.scale(0.5);

    @example

    // Scale the vector by given X and Y scale numbers
    vector.scale(0.5, 0.75);

    @example

    // Scale the vector by given a Vector2D object
    var vec = new Vector2D(0.5, 0.75);
    vector.scale(vec);

    @example

    // Scale the vector by given a 2-element array with X and Y scale numbers
    vector.scale([0.5, 0.75]);
    **/
    scale: function(scale, y){
        if (scale instanceof Vector2D) {
            this.x *= scale.x;
            this.y *= scale.y;
        } else if (Array.isArray(scale) && scale.length === 2) {
            this.x *= scale[0];
            this.y *= scale[1];
        } else if (typeof(scale) === 'number') {
            var yScale = scale;
            if (typeof(y) === 'number') {
                yScale = y;
            }
            this.x *= scale;
            this.y *= yScale;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;
    },

    /** 
    Transforms this vector by a transformation matrix.  Only the rotation and scaling from the matrix are applied.
    @method transform
    @param {Matrix2D|Array[Number]} matrix A Matrix or an Array of 9 numbers.
    @since 1.1.0
    @chainable
    @example

    // Transform the vector by given a 9-element array 
    tm = [a, b, 0, c, d, 0, e, f, 1] representing following matrix, only rotation and scaling part applied
    [a b 0] 
    [c d 0]
    [0 0 1]  
    new vector would be (a*x + c*y, b*x + d*y)

    vector.transform(tm);

    @example

    // Transform the vector by given a Matrix2D object
    vector.transform(tm);
    **/
    transform: function(tm) {

        if (Array.isArray(tm) && tm.length === 9) {
            var newX = this.x * tm[0] + this.y * tm[3];
            var newY = this.x * tm[1] + this.y * tm[4];
            this.x = newX;
            this.y = newY;
        } else if (tm instanceof Matrix2D) {
            var newX = this.x * tm.elements[0] + this.y * tm.elements[3];
            var newY = this.x * tm.elements[1] + this.y * tm.elements[4];
            this.x = newX;
            this.y = newY;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        
        return this;
    },

    /**
    @implements IDebuggable
    @method debug
    @since 1.6.0
    **/
    debug: function() {
        Debug.line(
            0.0, 0.0, 0.0,
            this.x, this.y, 0.0
        );
    }

}

initializeObjectMethods(Vector2D, 'Vector2D');

Library.exports.Vector2D = Vector2D;

//vector3d.js
/**   
A vector in 3D Space.
@param {Number} x The X magnitude of the vector.
@param {Number} y The Y magnitude of the vector.
@param {Number} z The Z magnitude of the vector.
@class Vector3D
@since 1.1.0
@constructor
**/
var Vector3D = function(x, y, z){

    /**
    The X magnitude of the vector.
    @property {Number} x
    @since 1.1.0
    **/
    this.x = x;

    /**
    The Y magnitude of the vector.
    @property {Number} y
    @since 1.1.0
    **/
    this.y = y;

    /**
    The Z magnitude of the vector.
    @property {Number} z
    @since 1.1.0
    **/
    this.z = z;

};

Vector3D.prototype = {

    /**
    Creates a copy of this object and returns it.
    @method clone
    @return {Vector3D}
    @since 1.1.0
    **/
    clone: function(){
        return new Vector3D(this.x, this.y, this.z);
    },

    /**
    Returns true if the objects are equal, otherwise false.
    @method equals
    @param {Vector3D|Object} other An object to compare this object to.
    @return {Boolean}
    @since 1.1.0
    **/
    equals: function(vec){
        return resabs(this.x, vec.x) && 
               resabs(this.y, vec.y) && 
               resabs(this.z, vec.z); 
    },

    /**
    The length of the vector.
    @method length
    @return {Number}
    @since 1.1.0
    **/
    length: function(){
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },

    /** 
    Transforms the vector by a transformation matrix, or an array containing the elements of a transformation matrix.
    @method transform
    @param {Matrix3D|Array[Number]} matrix A Matrix3D or an Array of 16 numbers to construct a Matrix3D from.
    @since 1.1.0
    @chainable  
    **/
    transform: function(matrix){
        if (Array.isArray(matrix) && matrix.length === 16) {
            var newX = this.x * matrix[0] + this.y * matrix[4] + this.z * matrix[8];
            var newY = this.x * matrix[1] + this.y * matrix[5] + this.z * matrix[9];
            var newZ = this.x * matrix[2] + this.y * matrix[6] + this.z * matrix[10];
            this.x = newX;
            this.y = newY;
            this.z = newZ;
        } else if (matrix instanceof Matrix3D) {
            var elements = matrix.elements;
            var newX = this.x * elements[0] + this.y * elements[4] + this.z * elements[8];
            var newY = this.x * elements[1] + this.y * elements[5] + this.z * elements[9];
            var newZ = this.x * elements[2] + this.y * elements[6] + this.z * elements[10];
            this.x = newX;
            this.y = newY;
            this.z = newZ
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        return this;
    },

    /**
    Normalize this vector
    @method normalize
    @chainable
    @since 1.1.0
    **/
    normalize: function() {
        var len = this.length();
        if (len !== 0) {
            this.x /= len;
            this.y /= len;
            this.z /= len;
        }
        return this;
    },

    /**
    Negate this vector
    @method negate
    @chainable
    @since 1.13.0
    **/
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;        
        return this;
    },

    /**
    Return the cross result of this vector and the passed one.
    @method cross
    @param {Vector3D|Array[Number]} vec A Vector3D or an Array of 3 numbers to construct a Vector3D from.
    @return {Vector3D}
    @since 1.1.0
    **/
    cross: function(vec) {
        var dest = [];
        if (Array.isArray(vec) && vec.length === 3) {
            dest[0] = this.y*vec[2] - this.z*vec[1];
            dest[1] = this.z*vec[0] - this.x*vec[2];
            dest[2] = this.x*vec[1] - this.y*vec[0];
        } else if (vec instanceof Vector3D) {
            dest[0] = this.y*vec.z - this.z*vec.y;
            dest[1] = this.z*vec.x - this.x*vec.z;
            dest[2] = this.x*vec.y - this.y*vec.x;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return new Vector3D(dest[0], dest[1], dest[2]);
    },

    /**
    Return the dot result of this vector and the passed one.
    @method dot
    @param {Vector3D|Array[Number]} vec A Vector3D or an Array of 3 numbers to construct a Vector3D from.
    @return {Number}
    @since 1.1.0
    **/
    dot: function(vec) {
        if (Array.isArray(vec) && vec.length === 3) {
            return this.x*vec[0] + this.y*vec[1] + this.z*vec[2];
        } else if (vec instanceof Vector3D) {
            return this.x*vec.x + this.y*vec.y + this.z*vec.z;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
    },

    /**
    Scales the vector magnitude.
    @method scale
    @param {Vector3D|Array[Number]|Number} scale A scale defined by a Vector3D, an Array with 3 values (X, Y and Z), or a number representing the X scale (and Y, Z scale if no additional parameter is specified.)
    @param {Number} [y] An option Y scale to use if an X scale was specified as the first argument.  If this argument is not specified then uniform scaling is assumed.
    @param {Number} [z] An option Z scale to use if an X scale was specified as the first argument.  If this argument is not specified then uniform scaling is assumed.
    @chainable
    @since 1.12.0
    @chainable
     @example

    // Scale the vector by given one scale number uniformly
    vector.scale(0.5);

    @example

    // Scale the vector by given X and Y scale numbers
    vector.scale(0.5, 0.75, 0.85);

    @example

    // Scale the vector by given a Vector3D object
    var vec = new Vector3D(0.5, 0.75, 0.85);
    vector.scale(vec);
    **/
    scale: function(scale, y, z) {
        if (scale instanceof Vector3D) {
            this.x *= scale.x;
            this.y *= scale.y;
            this.z *= scale.z;
        } else if (Array.isArray(scale) && scale.length === 3) {
            this.x *= scale[0];
            this.y *= scale[1];
            this.z *= scale[2];
        } else if (typeof(scale) === 'number') {
            var yScale = scale;
            var zScale = scale;
            if (typeof(y) === 'number' && typeof(z) === 'number') {
                yScale = y;
                zScale = z;
            }
            this.x *= scale;
            this.y *= yScale;
            this.z *= zScale;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;
    },

    /**
    Subtracts the vector by the input vector.
    @method subtract
    @param {Vector3D|Array[Number]} vec A Vector3D or an Array of 3 numbers to construct a Vector3D from.
    @return {Vector3D}
    @since 1.12.0
    @chainable
    **/
    subtract: function(vec) {
        if (Array.isArray(vec) && vec.length === 3) {
            this.x -= vec[0];
            this.y -= vec[1];
            this.z -= vec[2];
        } else if (vec instanceof Vector3D) {
            this.x -= vec.x;
            this.y -= vec.y;
            this.z -= vec.z;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;
    },

    /**
    Adds the vector by the input vector.
    @method add
    @param {Vector3D|Array[Number]} vec A Vector3D or an Array of 3 numbers to construct a Vector3D from.
    @return {Vector3D}
    @since 1.12.0
    @chainable
    **/
    add: function(vec) {
        if (Array.isArray(vec) && vec.length === 3) {
            this.x += vec[0];
            this.y += vec[1];
            this.z += vec[2];
        } else if (vec instanceof Vector3D) {
            this.x += vec.x;
            this.y += vec.y;
            this.z += vec.z;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;

    },

    /**
    @implements IDebuggable
    @method debug
    @since 1.6.0
    **/
    debug: function() {
        Debug.line(
            0.0, 0.0, 0.0,
            this.x, this.y, this.z
        );
    }
}

initializeObjectMethods(Vector3D, 'Vector3D');

Library.exports.Vector3D = Vector3D;

//matrix2d.js
/**   
A 3x3 Transformation matrix intended to be used with 2D geometries.
<ul>
  <li>Transformation methods are assumed to be right-handed.</li>
  <li>Elements are stored in row-major form when accessed or modified:</li>
  <li style="list-style: none;"><img src="{@ResourceUrl:matrix2elements.gif}"/></li>
  <li>Scaling is stored diagonally, translation is stored in the last row:</li>
  <li style="list-style: none;"><img src="{@ResourceUrl:matrix2.gif}"/></li>
</ul>
@param {Array[Number]} [elements] A 9-element array of matrix elements.  If not provided, then a default identity matrix is prepared.
@see Bezier2D#transform
@see Line2D#transform
@see Point2D#transform
@see Vector2D#transform
@class Matrix2D
@since 1.1.0
@constructor
**/
var Matrix2D = function(elements){

    /**
    The Row-Major Array of 9 numbers repressenting the transformation matrix.
    @property elements
    @type Array[Number]
    @since 1.1.0
    **/
    if (Array.isArray(elements) && elements.length === 9) {
        this.elements = elements;
    } else if (undefined == elements) {
        this.elements = [1,0,0, 0,1,0, 0,0,1];
    } else {
        Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
    }

};

Matrix2D.prototype = {

    /**
    Creates a copy of this object and returns it.
    @method clone
    @return {Matrix2D}
    @since 1.1.0
    **/
    clone: function() {
        return new Matrix2D(this.elements.slice());
    },

    /**
    Returns true if the objects are equal within tolerance (1e-6), otherwise false.
    @method equals
    @param {Matrix2D|Object} other An object to compare this object to.
    @return {Boolean}
    @since 1.1.0
    **/
    equals: function(other){
        return  resabs(this.elements[0], other.elements[0]) &&
                resabs(this.elements[1], other.elements[1]) &&
                resabs(this.elements[2], other.elements[2]) &&
                resabs(this.elements[3], other.elements[3]) &&
                resabs(this.elements[4], other.elements[4]) &&
                resabs(this.elements[5], other.elements[5]) &&
                resabs(this.elements[6], other.elements[6]) &&
                resabs(this.elements[7], other.elements[7]) &&
                resabs(this.elements[8], other.elements[8]);
    }, 

    /** 
    Calculates the determinant of the matrix and returns it.
    @method determinant
    @return {Number}
    @since 1.1.0
    **/
    determinant: function() {
        return (this.elements[0] * this.elements[4] * this.elements[8] +
                this.elements[1] * this.elements[5] * this.elements[6] +
                this.elements[2] * this.elements[3] * this.elements[7] -
                this.elements[2] * this.elements[4] * this.elements[6] -
                this.elements[1] * this.elements[3] * this.elements[8] -
                this.elements[0] * this.elements[5] * this.elements[7]); 

    },

    /** 
    Inverts this transformation matrix.
    @method invert
    @chainable
    @since 1.1.0
    **/
    invert: function() {

        var det = this.determinant();
        if (0 !== det) {
            var adjValues = []; 
            adjValues[0] = this.elements[4] * this.elements[8] - 
                           this.elements[5] * this.elements[7];
            adjValues[1] = this.elements[2] * this.elements[7] - 
                           this.elements[1] * this.elements[8];
            adjValues[2] = this.elements[1] * this.elements[5] - 
                           this.elements[2] * this.elements[4];
            adjValues[3] = this.elements[5] * this.elements[6] - 
                           this.elements[3] * this.elements[8];
            adjValues[4] = this.elements[0] * this.elements[8] - 
                           this.elements[2] * this.elements[6];
            adjValues[5] = this.elements[2] * this.elements[3] - 
                           this.elements[0] * this.elements[5];
            adjValues[6] = this.elements[3] * this.elements[7] - 
                           this.elements[4] * this.elements[6];
            adjValues[7] = this.elements[1] * this.elements[6] - 
                           this.elements[0] * this.elements[7];
            adjValues[8] = this.elements[0] * this.elements[4] - 
                           this.elements[1] * this.elements[3];
  
            var inv = 1.0 / det;
            for (var i = 0; i < this.elements.length; i++) {
                this.elements[i] = inv * adjValues[i];
            };
        }
        return this;
    },

    /** 
    Transforms this matrix by another transformation matrix. The transformation matrix is stored as row major.
    @method transform
    @param {Matrix2D|Array[Number]} matrix A Matrix or an Array of 9 numbers. 
    @since 1.1.0
    @chainable
    **/
    transform: function(matrix) {
        
        var tranElements = [];
        if (matrix instanceof Matrix2D) {
            tranElements = matrix.elements;
        } else if (Array.isArray(matrix) && matrix.length === 9) {
            tranElements = matrix;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        var elements = this.elements.slice();
        
        this.elements[0] = elements[0] * tranElements[0] + 
                           elements[1] * tranElements[3] + 
                           elements[2] * tranElements[6];

        this.elements[1] = elements[0] * tranElements[1] + 
                           elements[1] * tranElements[4] + 
                           elements[2] * tranElements[7];

        this.elements[2] = elements[0] * tranElements[2] + 
                           elements[1] * tranElements[5] + 
                           elements[2] * tranElements[8];

        this.elements[3] = elements[3] * tranElements[0] + 
                           elements[4] * tranElements[3] + 
                           elements[5] * tranElements[6];

        this.elements[4] = elements[3] * tranElements[1] + 
                           elements[4] * tranElements[4] + 
                           elements[5] * tranElements[7];

        this.elements[5] = elements[3] * tranElements[2] + 
                           elements[4] * tranElements[5] + 
                           elements[5] * tranElements[8];

        this.elements[6] = elements[6] * tranElements[0] + 
                           elements[7] * tranElements[3] + 
                           elements[8] * tranElements[6];

        this.elements[7] = elements[6] * tranElements[1] + 
                           elements[7] * tranElements[4] + 
                           elements[8] * tranElements[7];

        this.elements[8] = elements[6] * tranElements[2] + 
                           elements[7] * tranElements[5] + 
                           elements[8] * tranElements[8];

        return this;
    },

    /**
    Modifies all elements of this matrix to repressent an identity matrix.
    @method identity
    @since 1.1.0
    @chainable
    **/
    identity: function(){
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        return this;
    },

    /**
    Modifies the elements of this matrix to repressent the scaling specified by the arguments.  Caller may want to make it an identity matrix, prior to calling this method.<br/>
    @method scaling
    @since 1.1.0
    @param {Vector2D|Number|Array[Number]} scale A scale by a Vector2D, an Array with 2 values (X and Y), or a number repressenting the X scale.
    @param {Number} [y] The Y scale, when only the X scale is specified as the first argument.
    @chainable
    **/
    scaling: function(scale, y) {
        if (scale instanceof Vector2D) {
            this.elements[0] = scale.x;
            this.elements[4] = scale.y;
        } else if (Array.isArray(scale) && scale.length === 2) {
            this.elements[0] = scale[0];
            this.elements[4] = scale[1];
        } else if (typeof(scale) === 'number' && typeof(y) === 'number'){
            this.elements[0] = scale;
            this.elements[4] = y;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;
    },

    /**
    Modifies the elements of this matrix to repressent the translation specified by the arguments.  Caller may want to make it an identity matrix, prior to calling this method.<br/>
    @method translation
    @since 1.1.0
    @param {Vector2D|Number|Array[Number]} direction A direction of movement defined by a Vector2D, an Array with 2 values (X and Y), or a number repressenting the X offset.
    @param {Number} [y] The Y offset to move in, when only the X offset is specified as the first argument.
    @chainable
    **/
    translation: function(dir, y) {
        if (dir instanceof Vector2D) {
            this.elements[6] = dir.x;
            this.elements[7] = dir.y;
        } else if (Array.isArray(dir) && dir.length === 2) {
            this.elements[6] = dir[0];
            this.elements[7] = dir[1];
        } else if (typeof(dir) === 'number' && typeof(y) === 'number'){
            this.elements[6] = dir;
            this.elements[7] = y;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;
    },

    /**
    Modifies the elements of this matrix to repressent the rotation specified by the arguments.  Caller may want to make it an identity matrix, prior to calling this method.<br/>
    <img src="{@ResourceUrl:matrix2rotation.gif}"/>
    @method rotation
    @since 1.1.0
    @param {Number} angle The angle of rotation in radians (counter-clockwise / right-handed).
    @param {Point2D|Number|Array[Number]} [origin] An optional origin of rotation defined by a Point2D, an Array with 2 values (X and Y), or a number repressenting the X value.
    @param {Number} [y] The Y position to rotate around, when only the X offset is specified in the previous argument.
    @chainable
    **/
    rotation: function(angle, origin, y){

        var originX = 0;
        var originY = 0;

        if (typeof(angle) !== 'number') {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        if (undefined !== origin) {
            if (origin instanceof Point2D) {
                originX = origin.x;
                originY = origin.y;
            } else if (Array.isArray(origin) && origin.length === 2){
                originX = origin[0];
                originY = origin[1];
            } else if (typeof(origin) === 'number' && typeof(y) === 'number'){
                originX = origin;
                originY = y;
            } else {
                Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
            }
        }

        // Translate to origin (0, 0)
        if (originX !== 0 || originY !== 0){
            this.transform([1, 0, 0, 0, 1, 0, -originX, -originY, 1]);
        }

        // Rotate by angle counter clockwise
        var cosA = Math.cos(angle);
        var sinA = Math.sin(angle);
        this.transform([cosA, sinA, 0, -sinA, cosA, 0, 0, 0, 1]);

        // Translate back to the specified origin
        if (originX !== 0 || originY !== 0){
            this.transform([1, 0, 0, 0, 1, 0, originX, originY, 1]);
        }

        return this;
    }
}

initializeObjectMethods(Matrix2D, 'Matrix2D');

Library.exports.Matrix2D = Matrix2D;

//matrix3d.js
/**   
A 4x4 Transformation matrix intended to be used with 3D geometries.
<ul>
  <li>Transformation methods are assumed to be right-handed.</li>
  <li>Elements are stored in row-major form when accessed or modified:</li>
  <li style="list-style: none;"><img src="{@ResourceUrl:matrix3elements.gif}"/></li>
  <li>Scaling is stored diagonally, translation is stored in the last row:</li>
  <li style="list-style: none;"><img src="{@ResourceUrl:matrix3.gif}"/></li>
</ul>
@param {Array[Number]} [elements] A 16-element array of matrix elements.  If not provided, then a default identity matrix is prepared.
@see Point3D#transform
@see Vector3D#transform
@class Matrix3D
@since 1.1.0
@constructor
**/
var Matrix3D = function(elements){

    /**
    The Row-Major Array of 16 numbers repressenting the transformation matrix.
    @property elements
    @type Array[Number]
    @since 1.1.0
    **/
    if (Array.isArray(elements) && elements.length === 16) {
        this.elements = elements;
    } else if (undefined == elements) {
        this.elements = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
    } else {
        Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
    }

};

Matrix3D.prototype = {

    /**
    Creates a copy of this object and returns it.
    @method clone
    @return {Matrix3D}
    @since 1.1.0
    **/
    clone: function() {
        return new Matrix3D(this.elements.slice());
    },

    /**
    Returns true if the objects are equal within tolerance (1e-6), otherwise false.
    @method equals
    @param {Matrix3D|Object} other An object to compare this object to.
    @return {Boolean}
    @since 1.1.0
    **/
    equals: function(other){
        return  resabs(this.elements[0], other.elements[0]) &&
                resabs(this.elements[1], other.elements[1]) &&
                resabs(this.elements[2], other.elements[2]) &&
                resabs(this.elements[3], other.elements[3]) &&
                resabs(this.elements[4], other.elements[4]) &&
                resabs(this.elements[5], other.elements[5]) &&
                resabs(this.elements[6], other.elements[6]) &&
                resabs(this.elements[7], other.elements[7]) &&
                resabs(this.elements[8], other.elements[8]) &&
                resabs(this.elements[9], other.elements[9]) &&
                resabs(this.elements[10], other.elements[10]) &&
                resabs(this.elements[11], other.elements[11]) &&
                resabs(this.elements[12], other.elements[12]) &&
                resabs(this.elements[13], other.elements[13]) &&
                resabs(this.elements[14], other.elements[14]) &&
                resabs(this.elements[15], other.elements[15]);
    }, 

    /** 
    Calculates the determinant of the matrix and returns it.
    @method determinant
    @return {Number}
    @since 1.1.0
    **/
    determinant: function() {

        var adjoint = [];
        var cofactor =[];
        var elements = this.elements;

        cofactor[0] = elements[10] * elements[15] - elements[11] * elements[14];
        cofactor[1] = elements[9] * elements[15] - elements[11] * elements[13];
        cofactor[2] = elements[9] * elements[14] - elements[10] * elements[13];
        cofactor[3] = elements[8] * elements[15] - elements[11] * elements[12];
        cofactor[4] = elements[8] * elements[14] - elements[10] * elements[12];
        cofactor[5] = elements[8] * elements[13] - elements[9] * elements[12];

        adjoint[0] = elements[5] * cofactor[0] - elements[6] * cofactor[1] + elements[7] * cofactor[2];
        adjoint[1] = elements[6] * cofactor[3] - elements[4] * cofactor[0] - elements[7] * cofactor[4];
        adjoint[2] = elements[4] * cofactor[1] - elements[5] * cofactor[3] + elements[7] * cofactor[5];
        adjoint[3] = elements[5] * cofactor[4] - elements[4] * cofactor[2] - elements[6] * cofactor[5];


        return elements[0] * adjoint[0] + elements[1] * adjoint[1] +
               elements[2] * adjoint[2] + elements[3] * adjoint[3];

    },

    /** 
    Inverts this transformation matrix.
    @method invert
    @chainable
    @since 1.1.0
    **/
    invert: function() {
        
        // Get the adjoint matrix
        var adjoint = [];
        var cofactor =[];
        var elements = this.elements;

        cofactor[0] = elements[10] * elements[15] - elements[11] * elements[14];
        cofactor[1] = elements[9] * elements[15] - elements[11] * elements[13];
        cofactor[2] = elements[9] * elements[14] - elements[10] * elements[13];
        cofactor[3] = elements[8] * elements[15] - elements[11] * elements[12];
        cofactor[4] = elements[8] * elements[14] - elements[10] * elements[12];
        cofactor[5] = elements[8] * elements[13] - elements[9] * elements[12];

        adjoint[0] = elements[5] * cofactor[0] - elements[6] * cofactor[1] + elements[7] * cofactor[2];
        adjoint[4] = elements[6] * cofactor[3] - elements[4] * cofactor[0] - elements[7] * cofactor[4];
        adjoint[8] = elements[4] * cofactor[1] - elements[5] * cofactor[3] + elements[7] * cofactor[5];
        adjoint[12] = elements[5] * cofactor[4] - elements[4] * cofactor[2] - elements[6] * cofactor[5];

        adjoint[1] = elements[2] * cofactor[1] - elements[1] * cofactor[0] - elements[3] * cofactor[2];
        adjoint[5] = elements[0] * cofactor[0] - elements[2] * cofactor[3] + elements[3] * cofactor[4];
        adjoint[9] = elements[1] * cofactor[3] - elements[0] * cofactor[1] - elements[3] * cofactor[5];
        adjoint[13] = elements[0] * cofactor[2] - elements[1] * cofactor[4] + elements[2] * cofactor[5];

        cofactor[6] = elements[2] * elements[7] - elements[3] * elements[6];
        cofactor[7] = elements[1] * elements[7] - elements[3] * elements[5];
        cofactor[8] = elements[1] * elements[6] - elements[2] * elements[5];
        cofactor[9] = elements[0] * elements[7] - elements[3] * elements[4];
        cofactor[10] = elements[0] * elements[6] - elements[2] * elements[4];
        cofactor[11] = elements[0] * elements[5] - elements[1] * elements[4];

        adjoint[2] = elements[13] * cofactor[6] - elements[14] * cofactor[7] + elements[15] * cofactor[8];
        adjoint[6] = elements[14] * cofactor[9] - elements[12] * cofactor[6] - elements[15] * cofactor[10];
        adjoint[10] = elements[12] * cofactor[7] - elements[13] * cofactor[9] + elements[15] * cofactor[11];
        adjoint[14] = elements[13] * cofactor[10] - elements[12] * cofactor[8] - elements[14] * cofactor[11];

        adjoint[3] = elements[10] * cofactor[7] - elements[9] * cofactor[6] - elements[11] * cofactor[8];
        adjoint[7] = elements[8] * cofactor[6] - elements[10] * cofactor[9] + elements[11] * cofactor[10];
        adjoint[11] = elements[9] * cofactor[9] - elements[8] * cofactor[7] - elements[11] * cofactor[11];
        adjoint[15] = elements[8] * cofactor[8] - elements[9] * cofactor[10] + elements[10] * cofactor[11];

        var det = elements[0] * adjoint[0] + elements[1] * adjoint[4] +
                  elements[2] * adjoint[8] + elements[3] * adjoint[12];
        if (0 !== det) {
            var inv = 1.0 / det;
            for (var i = 0; i < 16; i++) {
                this.elements[i] = adjoint[i] * inv;
            }
        }
        
        return this;
    },

    /** 
    Transforms this matrix by another transformation matrix. The input matrix is stored as row major.
    @method transform
    @param {Matrix3D|Array[Number]} matrix A Matrix or an Array of 16 numbers.
    @since 1.1.0
    @chainable
    **/
    transform: function(matrix) {

        var otherElements = [];
        if (matrix instanceof Matrix3D) {
            otherElements = matrix.elements;
        } else if (Array.isArray(matrix) && matrix.length === 16) {
            otherElements = matrix;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        var elements = this.elements.slice();

        this.elements[0] = elements[0]*otherElements[0] + elements[1]*otherElements[4] +
                           elements[2]*otherElements[8] + elements[3]*otherElements[12];
        this.elements[1] = elements[0]*otherElements[1] + elements[1]*otherElements[5] +
                           elements[2]*otherElements[9] + elements[3]*otherElements[13];
        this.elements[2] = elements[0]*otherElements[2] + elements[1]*otherElements[6] +
                           elements[2]*otherElements[10] + elements[3]*otherElements[14];
        this.elements[3] = elements[0]*otherElements[3] + elements[1]*otherElements[7] +
                           elements[2]*otherElements[11] + elements[3]*otherElements[15];


        this.elements[4] = elements[4]*otherElements[0] + elements[5]*otherElements[4] +
                           elements[6]*otherElements[8] + elements[7]*otherElements[12];
        this.elements[5] = elements[4]*otherElements[1] + elements[5]*otherElements[5] +
                           elements[6]*otherElements[9] + elements[7]*otherElements[13];
        this.elements[6] = elements[4]*otherElements[2] + elements[5]*otherElements[6] +
                           elements[6]*otherElements[10] + elements[7]*otherElements[14];
        this.elements[7] = elements[4]*otherElements[3] + elements[5]*otherElements[7] +
                           elements[6]*otherElements[11] + elements[7]*otherElements[15];

        this.elements[8] = elements[8]*otherElements[0] + elements[9]*otherElements[4] +
                           elements[10]*otherElements[8] + elements[11]*otherElements[12];
        this.elements[9] = elements[8]*otherElements[1] + elements[9]*otherElements[5] +
                           elements[10]*otherElements[9] + elements[11]*otherElements[13];
        this.elements[10] = elements[8]*otherElements[2] + elements[9]*otherElements[6] +
                           elements[10]*otherElements[10] + elements[11]*otherElements[14];
        this.elements[11] = elements[8]*otherElements[3] + elements[9]*otherElements[7] +
                           elements[10]*otherElements[11] + elements[11]*otherElements[15];

        this.elements[12] = elements[12]*otherElements[0] + elements[13]*otherElements[4] +
                           elements[14]*otherElements[8] + elements[15]*otherElements[12];
        this.elements[13] = elements[12]*otherElements[1] + elements[13]*otherElements[5] +
                           elements[14]*otherElements[9] + elements[15]*otherElements[13];
        this.elements[14] = elements[12]*otherElements[2] + elements[13]*otherElements[6] +
                           elements[14]*otherElements[10] + elements[15]*otherElements[14];
        this.elements[15] = elements[12]*otherElements[3] + elements[13]*otherElements[7] +
                           elements[14]*otherElements[11] + elements[15]*otherElements[15];
        return this;

    },

    /**
    Modifies all elements of this matrix to repressent an identity matrix.
    @method identity
    @since 1.1.0
    @chainable
    **/
    identity: function(){
        this.elements = [1, 0, 0, 0, 
                         0, 1, 0, 0, 
                         0, 0, 1, 0, 
                         0, 0, 0, 1];
        return this;
    },

    /**
    Modifies the elements of this matrix to represent the scaling specified by the arguments.  Caller may want to make it an identity matrix, prior to calling this method.<br/>
    @method scaling
    @since 1.1.0
    @param {Vector3D|Number|Array[Number]} scale A scale by a Vector3D, an Array with 3 values (X, Y, Z), or a number representing the X scale.
    @param {Number} [y] The Y scale, when only the X scale is specified as the first argument.
    @param {Number} [z] The Z scale, when only the X scale is specified as the first argument.
    @chainable
    **/
    scaling: function(scale, y, z){
        if (scale instanceof Vector3D) {
            this.elements[0] = scale.x;
            this.elements[5] = scale.y;
            this.elements[10] = scale.z;
        } else if (Array.isArray(scale) && scale.length === 3) {
            this.elements[0] = scale[0];
            this.elements[5] = scale[1];
            this.elements[10] = scale[2];
        } else if (typeof(scale) === 'number' &&
                   typeof(y) === 'undefined') {
            this.elements[0] = scale;
            this.elements[5] = scale;
            this.elements[10] = scale;
        } else if (typeof(scale) === 'number' &&
                   typeof(y) === 'number' &&
                   typeof(z) === 'number') {
            this.elements[0] = scale;
            this.elements[5] = y;
            this.elements[10] = z;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;
    },

    /**
    Modifies the elements of this matrix to represent the translation specified by the arguments.  Caller may want to make it an identity matrix, prior to calling this method.<br/>
    @method translation
    @since 1.1.0
    @param {Vector3D|Number|Array[Number]} direction A direction of movement defined by a Vector3D, an Array with 3 values (X and Y), or a number repressenting the X offset.
    @param {Number} [y] The Y offset to move in, when only the X offset is specified as the first argument.
    @param {Number} [z] The Z offset to move in, when only the X offset is specified as the first argument.
    @chainable
    **/
    translation: function(dir, y, z){
        if (dir instanceof Vector3D) {
            this.elements[12] = dir.x;
            this.elements[13] = dir.y;
            this.elements[14] = dir.z;
        } else if (Array.isArray(dir) && dir.length === 3) {
            this.elements[12] = dir[0];
            this.elements[13] = dir[1];
            this.elements[14] = dir[2];
        } else if (typeof(dir) === 'number' &&
                   typeof(y) === 'undefined') {
            this.elements[12] = dir;
            this.elements[13] = dir;
            this.elements[14] = dir;
        } else if (typeof(dir) === 'number' &&
                   typeof(y) === 'number' &&
                   typeof(z) === 'number') {
            this.elements[12] = dir;
            this.elements[13] = y;
            this.elements[14] = z;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        return this;
    },

    /**
    Modifies the elements of this matrix to represent the rotation around the X axis (on the YZ plane) specified by the arguments.  Caller may want to make it an identity matrix, prior to calling this method.<br/>
    @method rotationX
    @since 1.1.0
    @param {Number} angle The angle of rotation in radians (counter-clockwise / right-handed).
    @chainable
    **/
    rotationX: function(angle){

        if (typeof(angle) !== 'number') {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE); 
        }

        var sinA = Math.sin(angle);
        var cosA = Math.cos(angle);

        this.elements[5] = cosA;
        this.elements[6] = sinA;
        this.elements[9] = -sinA;
        this.elements[10] = cosA;

        return this;
    },

    /**
    Modifies the elements of this matrix to repressent the rotation around the Y axis (on the XZ plane) specified by the arguments.  Caller may want to make it an identity matrix, prior to calling this method.<br/>
    @method rotationY
    @since 1.1.0
    @param {Number} angle The angle of rotation in radians (counter-clockwise / right-handed).
    @chainable
    **/
    rotationY: function(angle){

        if (typeof(angle) !== 'number') {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE); 
        }

        var sinA = Math.sin(angle);
        var cosA = Math.cos(angle);

        this.elements[0] = cosA;
        this.elements[2] = -sinA;
        this.elements[8] = sinA;
        this.elements[10] = cosA;

        return this;
    },

    /**
    Modifies the elements of this matrix to repressent the rotation around the Z axis (on the XY plane) specified by the arguments.  Caller may want to make it an identity matrix, prior to calling this method.<br/>
    @method rotationZ
    @since 1.1.0
    @param {Number} angle The angle of rotation in radians (counter-clockwise / right-handed).
    @chainable
    **/
    rotationZ: function(angle){

        if (typeof(angle) !== 'number') {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE); 
        }

        var sinA = Math.sin(angle);
        var cosA = Math.cos(angle);

        this.elements[0] = cosA;
        this.elements[1] = sinA;
        this.elements[4] = -sinA;
        this.elements[5] = cosA;

        return this;
    },

    /**
    Specifies a rotation matrix that translates an object based on the origin and aligns it based on the X, Y and Z axes supplied.  The X, Y and Z axes should be orthogonal to eachother.
    @method coordinateSystem
    @param {Point3D} origin Specifies where the point (0,0,0) should be located after applying the matrix.
    @param {Vector3D} xAxis Specifies where the axis (1,0,0) should be directed after applying this matrix.
    @param {Vector3D} yAxis Specifies where the axis (0,1,0) should be directed after applying this matrix.
    @param {Vector3D} zAxis Specifies where the axis (0,0,1) should be directed after applying this matrix.
    @chainable
    @since 1.6.0
    **/
    coordinateSystem: function(origin, xAxis, yAxis, zAxis) {

        this.elements[0] = xAxis.x;
        this.elements[1] = xAxis.y;
        this.elements[2] = xAxis.z;
        this.elements[3] = 0.0;

        this.elements[4] = yAxis.x;
        this.elements[5] = yAxis.y;
        this.elements[6] = yAxis.z;
        this.elements[7] = 0.0;

        this.elements[8]  = zAxis.x;
        this.elements[9]  = zAxis.y;
        this.elements[10] = zAxis.z;
        this.elements[11] = 0.0;

        this.elements[12] = origin.x;
        this.elements[13] = origin.y;
        this.elements[14] = origin.z;
        this.elements[15] = 1.0;

        return this;
    },

    /** 
     Overrides the default serialization process of JSON.stringify method, and 
     returns the serialized JSON.
     @method toJSON
     @return {JSON}
     @since 1.16.0 
     **/
    toJSON: function() {
        return this.elements;
    }
}

initializeObjectMethods(Matrix3D, 'Matrix3D');

Library.exports.Matrix3D = Matrix3D;

//line2d.js
/**  
A 2D line respresented by a start point and end point.
@class Line2D
@extends Curve2D
@since 1.1.0
@see Path2D
@see Path2D#lineTo
**/
var Line2D = function(index, path){
    
    // Invoke base class...
    Curve2D.call(this, index, path);

    /**
    Gets or sets the start point of the line  
    @property {Point2D} start
    **/
    Object.defineProperty(this, "start",{ 
        get : function () {
            return this.path._impl._startPointOfCurve(this.index); 
        },
        set : function (point) { 
            return this.path._impl._startPointOfCurve(this.index, point);
        },
        enumerable : true
    });

    /**
    Gets or sets the start point of the line  
    @property {Point2D} end
    **/
    Object.defineProperty(this, "end", { 
        get : function () {
            return this.path._impl._endPointOfCurve(this.index); 
        },
        set : function (point) { 
            return this.path._impl._endPointOfCurve(this.index, point);
        },
        enumerable : true
    })

};

Line2D.prototype = new Curve2D();

initializeObjectMethods(Line2D, 'Line2D');

/**
Calculates the minimum distance from the line to a given point.
@method distanceTo
@param {Point2D} point the given point for calculating the distance to
@return {Number} 
@since 1.1.0
**/
Line2D.prototype.distanceTo = function(point){
    
    var distSqr = function(start, end){
        return (start.x - end.x) * (start.x - end.x) + (start.y - end.y) * (start.y - end.y);
    };
    var start = this.start;
    var end = this.end;
    var lengthSqr = distSqr(start, end);
    if (lengthSqr === 0) {
        return Math.sqrt(distSqr(start, point));
    }
    var t = ((point.x - start.x) * (end.x - start.x) 
           + (point.y - start.y) * (end.y - start.y)) / lengthSqr;
    if (t < 0) {
        return Math.sqrt(distSqr(point, start));
    }
    if (t > 1) {
        return Math.sqrt(distSqr(point, end));
    }
    return Math.sqrt(distSqr(point, { x: start.x + t * (end.x - start.x),
                                  y: start.y + t * (end.y - start.y) }));
};


/**
Moves the curve in the direction specified.
@method move
@param {Vector2D|Number|Array[Number]} direction A direction of movement defined by a Vector2D, an Array with 2 values (X and Y), or a number repressenting the X offset.
@param {Number} [y] The Y offset to move in, when only the X offset is specified as the first argument.
@chainable
**/
Line2D.prototype.move = function(dir, y){
    
    this.start = this.start.move(dir, y);
    this.end = this.end.move(dir, y);

    return this;
};

/** 
Transforms the line by a transformation matrix.
@method transform
@param {Matrix2D|Array[Number]} matrix A Matrix or an Array of 9 numbers.
@since 1.1.0
@chainable
**/
Line2D.prototype.transform = function(tm){

    this.start = this.start.transform(tm);
    this.end = this.end.transform(tm);
    return this;
};

Library.exports.Line2D = Line2D;



//bezier2d.js
/**   
A 2D Quadtratic or Cubic B&eacute;zier Curve determined by the number of control points.  
If there are 2 control points specified, then it's considered a Cubic B&eacute;zier. 
If a single control point is specified, then it's considered a Quadratic B&eacute;zier.
Higher-degree b&eacute;zier curves are not supported at this time.
@class Bezier2D
@extends Curve2D
@since 1.1.0
@see Path2D
@see Path2D#bezierCurveTo
@see Path2D#quadraticCurveTo
**/
var Bezier2D = function(index, path){

  // Invoke base class...
  Curve2D.call(this, index, path);
  
  /**
  Gets or sets the start point of the B&eacute;zier curve. 
  @property {Point2D} start
  **/
  Object.defineProperty(this, "start",{ 
        get : function () {
            return this.path._impl._startPointOfCurve(this.index); 
        },
        set : function (point) { 
            return this.path._impl._startPointOfCurve(this.index, point);
        },
        enumerable : true
    });

  /**
  Gets or sets the end point of the B&eacute;zier curve. 
  @property {Point2D} end
  @example

  // Set the end point
  var point = new Point2D(x, y);
  bezier2DObj.end = point;
  **/
  Object.defineProperty(this, "end", { 
        get : function () {
            return this.path._impl._endPointOfCurve(this.index); 
        },
        set : function (point) { 
            return this.path._impl._endPointOfCurve(this.index, point);
        },
        enumerable : true
  });

  /**
  Gets or sets the control points of the B&eacute;zier curve.
  @property {Array[Point2D]} controlPoints

  @example
  // Set the control points 
  var controlPoints = [point1, point2]; 
  bezier2DObj.controlPoints = controlPoints;
  **/
  Object.defineProperty(this, "controlPoints", { 
        get : function () {
            return this.path._impl._controlPointsOfCurve(this.index); 
        },
        set : function (points) { 
            return this.path._impl._controlPointsOfCurve(this.index, points);
        },
        enumerable : true
  });

};

Bezier2D.prototype = new Curve2D();

initializeObjectMethods(Bezier2D, 'Bezier2D');

/**
Gets the minimum distance from the B&eacute;zier curve to the given point.
The first parameter is the given point, the second tolerance is optional within which the calculation is stopped. A default tolerance is used if not specified basing on the maximum calculation precision of our system.
@param {Point2D} point the given point for calculating the distance to
@param {Number} [tol] the optional tolerance within which to stop calculation 
@method distanceTo
@return {Number}
@since 1.1.0
**/
Bezier2D.prototype.distanceTo = function(point, tol){

    var tolerance = tol ? tol : weldThreshold();

    var distance = Number.MAX_VALUE;
    var result = {};
    result['dist'] = distance;

    var startPnt = this.start;
    var endPnt = this.end;
    var ctrlPnts = this.controlPoints;
    var ctrlPntCount = ctrlPnts.length;

    // Get the shortest distance beween the curve points and given point
    var ctrlPnt1 = {}, ctrlPnt2 = {};
    if (1 === ctrlPntCount) {
      var ctrlPnt = ctrlPnts[0];
      // Convert quadratic bezier to higher order one
      ctrlPnt1.x = startPnt.x + (2.0/3.0) * (ctrlPnt.x - startPnt.x);
      ctrlPnt1.y = startPnt.y + (2.0/3.0) * (ctrlPnt.y - startPnt.y);
      ctrlPnt2.x = endPnt.x + (2.0/3.0) * (ctrlPnt.x - endPnt.x);
      ctrlPnt2.y = endPnt.y + (2.0/3.0) * (ctrlPnt.y - endPnt.y);
    } else if (2 === ctrlPntCount) {
      ctrlPnt1 = ctrlPnts[0];
      ctrlPnt2 = ctrlPnts[1];
    } else {
      Plugin.panic("Bezier2D has an unsupported number of control points.");
    }

    this.path._impl._bezierDistToPoint(result, tolerance,
                                     startPnt.x, startPnt.y,
                                     ctrlPnt1.x, ctrlPnt1.y,
                                     ctrlPnt2.x, ctrlPnt2.y,
                                     endPnt.x, endPnt.y,
                                     point.x, point.y, 0);

    return result['dist'];
};

/**
Moves the curve in the direction specified.
@method move
@param {Vector2D|Number|Array[Number]} direction A direction of movement defined by a Vector2D, an Array with 2 values (X and Y), or a number repressenting the X offset.
@param {Number} [y] The Y offset to move in, when only the X offset is specified as the first argument.
@chainable
**/
Bezier2D.prototype.move = function(dir, y){
    
    this.start = this.start.move(dir, y);
    this.end = this.end.move(dir, y);

    var ctrlPoints = this.controlPoints;
    var newCtrlPoints = [];
    for (var i = 0; i < ctrlPoints.length; i++) {
        newCtrlPoints.push(ctrlPoints[i].move(dir, y));
    };
    this.controlPoints = newCtrlPoints;
    return this;
};

/**
Rotates the curve around an optionally specified point.  If no origin is specified then 0,0 is assumed.
Right-handed system is used implying the positive angles result in counter-clockwise orientations.
@method rotate
@param {Number} angle The angle of rotation
@param {Point2D|Number|Array[Number]} [origin] An optional origin of rotation defined by a Point2D, an Array with 2 values (X and Y), or a number repressenting the X value.
@param {Number} [y] The Y position to rotate around, when only the X offset is specified in the previous argument.
@chainable
**/
Bezier2D.prototype.rotate = function(angle, origin, y) {

    this.start = this.start.rotate(angle, origin, y);
    this.end = this.end.rotate(angle, origin, y);

    var ctrlPoints = this.controlPoints;
    var newCtrlPoints = [];
    for (var i = 0; i < ctrlPoints.length; i++) {
        newCtrlPoints.push(ctrlPoints[i].rotate(angle, origin, y));
    };
    this.controlPoints = newCtrlPoints;

    return this;
};

/** 
Transforms the Bezier by a transformation matrix.
@method transform
@param {Matrix2D|Array[Number]} matrix A Matrix or an Array of 9 numbers.
@since 1.1.0
@chainable
**/
Bezier2D.prototype.transform = function(tm) {

    this.start = this.start.transform(tm);
    this.end = this.end.transform(tm);

    var ctrlPoints = this.controlPoints;
    var newCtrlPoints = [];
    for (var i = 0; i < ctrlPoints.length; i++) {
        newCtrlPoints.push(ctrlPoints[i].transform(tm));
    };
    this.controlPoints = newCtrlPoints;

    return this;
};

/*
 * Export it for public use
 */
Library.exports.Bezier2D = Bezier2D;

//path2d.js

/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@private
@class _Path2D
**/
var _Path2D = function() {

    /**
    Raw Curve Data, and it has the format as 
    <curve type>|<curve data><curve data>|<curve type>|<curve data><curve data>..
    @private 
    @property _curveData
    **/
    this._curveData = [];

    /**
    The start offsets of each curve    
    @private 
    @property _curveStarts 
    **/
    this._curveStarts = [];

};

_Path2D.prototype = {

    /**
    Get the ploygons from the path
    For example, if there were 2 1x1 closed squares on a Path2D, at 0,0 and 2,2, 
    it would return two arrays, each with 10 numbers representing 5 points 
    (first and last are identical so client knows it's a closed path):
    [[0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0], [2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 2.0, 2.0, 2.0]]
    @private       
    @method toPolygons
    @param {Number} tolerance coordinate x of end point
    **/
    _toPolygons: function(tolerance) {

        var tol = tolerance || tessTolerance();

        var polygons = [];
        var polygon = [];
        var curveData = this._curveData;
        var currPnt = {}; 
        // Iterate the curve to generate the polygon array
        for (var i = 0; i < this._curveStarts.length; i++) {            
            var start = this._curveStarts[i];
            switch (curveData[start]) {
                case CurveTypeEnum.MoveTo || CurveTypeEnum.MoveToEx:
                    if (polygon.length > 2){ // Only push the polygon with at least 2 points
                        polygons.push(polygon);    
                    }
                    polygon = []; // Start the new ploygon once meeting MoveTo or MoveToEx

                    currPnt.x = curveData[start+1];
                    currPnt.y = curveData[start+2];
                    polygon.push(currPnt.x, currPnt.y);
                    break;
                case CurveTypeEnum.LineTo:
                    currPnt.x = curveData[start+1];
                    currPnt.y = curveData[start+2];
                    polygon.push(currPnt.x, currPnt.y);
                    break;
                case CurveTypeEnum.QuadraticCurveTo:
                    var ctlPnt = {}, ctlPnt1 = {}, ctlPnt2 = {}, tPnt = {};
                    ctlPnt.x = curveData[start+1];
                    ctlPnt.y = curveData[start+2];
                    tPnt.x = curveData[start+3];
                    tPnt.y = curveData[start+4];

                    // Quadratic beziers can be expressed as cubics with a zero cubic term.
                    // The start and end points are of course same, and the cubic control points are computed as:
                    //    cubic_p1 = quad_p0 + 2/3 *(quad_p1 - quad_p0)
                    //    cubic_p2 = quad_p2 + 2/3 *(quad_p1 - quad_p2)
                    ctlPnt1.x = currPnt.x + (2.0/3.0) * (ctlPnt.x - currPnt.x);
                    ctlPnt1.y = currPnt.y + (2.0/3.0) * (ctlPnt.y - currPnt.y);
                    ctlPnt2.x = tPnt.x + (2.0/3.0) * (ctlPnt.x - tPnt.x);
                    ctlPnt2.y = tPnt.y + (2.0/3.0) * (ctlPnt.y - tPnt.y);

                    this._cubicBezierRecursive(polygon, tol, 
                                              currPnt.x, currPnt.y,
                                              ctlPnt1.x, ctlPnt1.y, // ctrl point 1
                                              ctlPnt2.x, ctlPnt2.y, // ctrl point 2
                                              tPnt.x, tPnt.y, // target point
                                              0);
                    currPnt.x = tPnt.x;
                    currPnt.y = tPnt.y;
                    break;

                case CurveTypeEnum.BezierCurveTo:                
                    this._cubicBezierRecursive(polygon, tol, 
                                              currPnt.x, currPnt.y,
                                              curveData[start+1], curveData[start+2], // ctrl Pnt 1
                                              curveData[start+3], curveData[start+4], // ctrl Pnt 2
                                              curveData[start+5], curveData[start+6], // target Pnt
                                              0);
                    currPnt.x = curveData[start+5];
                    currPnt.y = curveData[start+6];
                    break;
                default:
                    break;
            }
        }
        
        // Append the last polygon
        if (polygon.length > 0){
            polygons.push(polygon);            
        }

        return polygons;
    },

    /**
    Calculates the distance from point to segment.
    @private
    @method distPtToSeg
    @param {Number} x coordinate x of point
    @param {Number} y coordinate y of point
    @param {Number} px coordinate x of start point
    @param {Number} py coordinate y of start point
    @param {Number} qx coordinate x of end point
    @param {Number} qy coordinate y of end point
    @return {Number} Returns the distance
    **/
    _distPtToSeg: function(x, y, px, py, qx, qy) {
        var pqx = qx - px;
        var pqy = qy - py;
        var dx = x - px;
        var dy = y - py;
        var d = pqx *pqx + pqy*pqy;
        var t = pqx*dx + pqy*dy;
        if (d > 0) {
            t /= d;
        }
        if (t < 0) {
            t = 0;
        } else if (t > 1) {
            t = 1;
        }
        dx = px + t*pqx - x;
        dy = py + t*pqy - y;
        return dx*dx + dy*dy;
    },


    /**
    Discretize cubic Bezier curve.
    @private
    @method _cubicBezierRecursive
    @param {Array} contour the contour      
    @param {Number} tol tolerance
    @param {Number} x1 coordinate x of start point
    @param {Number} y1 coordinate x of start point
    @param {Number} x2 coordinate x of control point #1
    @param {Number} y2 coordinate x of control point #1
    @param {Number} x3 coordinate x of control point #2
    @param {Number} y3 coordinate y of control point #2
    @param {Number} x4 coordinate x of end point
    @param {Number} y4 coordinate y of end point
    @param {Number} level recursive level
    **/
    _cubicBezierRecursive: function(polygon, tol, x1, y1, x2, y2, x3, y3, x4, y4, level) {
        if (level > 18) {
            return;
        }
        var x12 = (x1 + x2) * 0.5;
        var y12 = (y1 + y2) * 0.5;
        var x23 = (x2 + x3) * 0.5;
        var y23 = (y2 + y3) * 0.5;
        var x34 = (x3 + x4) * 0.5;
        var y34 = (y3 + y4) * 0.5;
        var x123 = (x12 + x23) * 0.5;
        var y123 = (y12 + y23) * 0.5;
        var x234 = (x23 + x34) * 0.5;
        var y234 = (y23 + y34) * 0.5;
        var x1234 = (x123 + x234) * 0.5;
        var y1234 = (y123 + y234) * 0.5;
        var d = this._distPtToSeg(x1234, y1234, x1,y1, x4,y4);

        if (d > tol*tol) {
            this._cubicBezierRecursive(polygon, tol, x1,y1, x12,y12, x123,y123, x1234,y1234, level+1);
            this._cubicBezierRecursive(polygon, tol, x1234, y1234, x234,y234, x34,y34, x4,y4, level+1);
        } else {
            polygon.push(x4, y4);
        }
    },
    

    /**
    Get the distance from a given point to cubic Bezier curve.
    @private
    @method _bezierDistToPoint
    @param {Number} distance
    @param {Number} x1 coordinate x of start point
    @param {Number} y1 coordinate x of start point
    @param {Number} x2 coordinate x of control point #1
    @param {Number} y2 coordinate x of control point #1
    @param {Number} x3 coordinate x of control point #2
    @param {Number} y3 coordinate y of control point #2
    @param {Number} x4 coordinate x of end point
    @param {Number} y4 coordinate y of end point
    @param {Number} tx coordinate x of target point
    @param {Number} ty coordinate y of target point
    @param {Number} level recursive level
    @return {Object} the result object
    **/
    _bezierDistToPoint: function(result, tol, x1, y1, x2, y2, x3, y3, x4, y4, tx, ty, level) {
        if (level > 18) {
            return;
        }
        var x12 = (x1 + x2) * 0.5;
        var y12 = (y1 + y2) * 0.5;
        var x23 = (x2 + x3) * 0.5;
        var y23 = (y2 + y3) * 0.5;
        var x34 = (x3 + x4) * 0.5;
        var y34 = (y3 + y4) * 0.5;
        var x123 = (x12 + x23) * 0.5;
        var y123 = (y12 + y23) * 0.5;
        var x234 = (x23 + x34) * 0.5;
        var y234 = (y23 + y34) * 0.5;
        var x1234 = (x123 + x234) * 0.5;
        var y1234 = (y123 + y234) * 0.5;

        var d = Math.sqrt((x1234 - tx) * (x1234 - tx) + (y1234 - ty) * (y1234 - ty));

        if (d < tol) {
            result['dist'] = d;
            return;
        }

        if (d < result['dist']) {
            result['dist'] = d;
        }

        this._bezierDistToPoint(result, tol, x1, y1, x12, y12, x123, y123, x1234, y1234, tx, ty, level+1);
        this._bezierDistToPoint(result, tol, x1234, y1234, x234, y234, x34, y34, x4, y4, tx, ty, level+1);
    },

    /**
    Check whether the point (x, y) is the same as last curve's end point
    To avoid the duplicated point to be added
    @private       
    @method _coincideWithEndPoint
    **/
    _coincideWithEndPoint: function(x, y){
        var pnt = new Point2D(x, y);
        var lastCurve = this._curveStarts.length - 1;
        if (lastCurve > -1){           
            var start = this._curveStarts[lastCurve];
            var endPntPos = -1;

            switch (this._curveData[start]) {
                case CurveTypeEnum.LineTo || CurveTypeEnum.MoveTo || CurveTypeEnum.MoveToEx:
                    endPntPos = start+1;       
                    break;
                case CurveTypeEnum.QuadraticCurveTo:
                    endPntPos = start+3;
                    break;
                case CurveTypeEnum.BezierCurveTo:
                    endPntPos = start+5;
                    break;
                default:
                    break;
            }

            if (endPntPos > -1) {
                var endPnt = new Point2D(this._curveData[endPntPos], this._curveData[endPntPos+1]);
                if (pnt.distanceTo(endPnt) < weldThreshold()) {
                    return true;
                }
            }
        }
        return false;
    },

    /**
    Check whether this curve is removed, not an actual curve
    @private
    @method isRemoved
    **/
    _isRemoved: function(idx){
        if (idx < 0 || idx > this._curveStarts.length - 1) {
            return true;
        }
 
        var start = this._curveStarts[idx];
        var type = this._curveData[start];
        if (type === CurveTypeEnum.MoveTo ||
            type === CurveTypeEnum.MoveToEx){
            return true;
        }

        return false;
    },

    /**
    Remove the given curve
    @private       
    @method _removeCurve      
    **/
    _removeCurve: function(idx){
        var start = this._curveStarts[idx];
        var curveData = this._curveData;
        switch (curveData[start]) {
                case CurveTypeEnum.LineTo:
                    curveData[start] = CurveTypeEnum.MoveTo;
                    break;
                case CurveTypeEnum.QuadraticCurveTo:
                    curveData[start] = CurveTypeEnum.MoveToEx;
                    curveData[start+1] = curveData[start+3];
                    curveData[start+2] = curveData[start+4];
                    curveData[start+3] = 2;
                    curveData[start+4] = 0;
                    break;
                case CurveTypeEnum.BezierCurveTo:
                    curveData[start] = CurveTypeEnum.MoveToEx;
                    curveData[start+1] = curveData[start+5];
                    curveData[start+2] = curveData[start+6];
                    curveData[start+3] = 4;
                    curveData[start+4] = 0;
                    curveData[start+5] = 0;
                    curveData[start+6] = 0;
                    break;
                default:
                    break;
        }
    },

    /**
    Get the next curve given the curve index
    @private       
    @method _nextCurve      
    **/
    _nextCurve: function(idx){  
        var start = idx ? idx : -1;

        var curveCount = this._curveStarts.length;
        if (idx >= curveCount){
            return -1;
        }

        var curveData = this._curveData;
        for (var i = start + 1; i < curveCount; i++){
            var start = this._curveStarts[i];
            if (curveData[start] === CurveTypeEnum.LineTo ||
                curveData[start] === CurveTypeEnum.QuadraticCurveTo ||
                curveData[start] === CurveTypeEnum.BezierCurveTo){
                return i;
            }
        }

        return -1;
    },

    /**
    Get the prev curve given the curve index. If the idx is not speficifed then default to the last curve
    @private       
    @method _prevCurve      
    **/
    _prevCurve: function(idx){  

        var curveCount = this._curveStarts.length;
        var start = idx ? idx : curveCount;

        if (idx >= curveCount || idx < 1){
            return -1;
        }

        var curveData = this._curveData;
        for (var i = start - 1; i > -1; i--){
            var start = this._curveStarts[i];
            if (curveData[start] === CurveTypeEnum.LineTo ||
                curveData[start] === CurveTypeEnum.QuadraticCurveTo ||
                curveData[start] === CurveTypeEnum.BezierCurveTo){
                return i;
            }
        }

        return -1;
    },


    /**
    Get the end point's offset for the specified curve
    @private
    @method _endPosOfCurve
    **/
    _endPosOfCurve: function(idx) {

        var start = this._curveStarts[idx];
        var curveType = this._curveData[start];

        var endPntPos = -1; 
        if (curveType === CurveTypeEnum.LineTo || 
            curveType === CurveTypeEnum.MoveTo || 
            curveType === CurveTypeEnum.MoveToEx){ 
            endPntPos = start+1;
        } else if (curveType === CurveTypeEnum.QuadraticCurveTo) {
            endPntPos = start+3; 
        } else if (curveType === CurveTypeEnum.BezierCurveTo) {
            endPntPos = start+5; 
        }

        return endPntPos;
    },

    /**
    Check whether this path is closed
    @private
    @method isClosed
    **/
    _isClosed: function(){
        var curveCount = this._curveStarts.length;
        var curveData = this._curveData;

        if (curveCount > 1) {
            var endPosOfFirstCurve = this._endPosOfCurve(0);
            var endPosOfLastCurve = this._endPosOfCurve(curveCount - 1);

            if((curveData[endPosOfFirstCurve] === curveData[endPosOfLastCurve]) && 
               (curveData[endPosOfFirstCurve+1] === curveData[endPosOfLastCurve+1])) {
                return true;
            }
        } 
        return false;
    },

    /**
    Set/get the given curve's end point 
    @private       
    @method _endOfCurve      
    **/
    _endPointOfCurve: function(idx, point){

        var endPntPos = this._endPosOfCurve(idx); 

        if (endPntPos < 0 || endPntPos > this._curveData.length - 2)
            return;

        if (point) {
            // Set the joint curve's end point as well
            var curveCount = this._curveStarts.length;
            if (0 === idx || curveCount - 1 === idx) {
                if (this._isClosed()){
                    var endPntPosOfJointCurve = this._endPosOfCurve(curveCount - 1 - idx);
                    this._curveData[endPntPosOfJointCurve] = point.x;
                    this._curveData[endPntPosOfJointCurve+1] = point.y;
                }
            }             
            this._curveData[endPntPos] = point.x;
            this._curveData[endPntPos+1] = point.y; 
         
            return;

        } else {
            return new Point2D(this._curveData[endPntPos], this._curveData[endPntPos+1]);
        }

    },

    /**
    Set/get the given curve's start point 
    For set, it defaultly update the end point of last curve which acts as the start point for current curve
    @private       
    @method _endOfCurve      
    **/
    _startPointOfCurve: function(idx, point){
        var lastCurve = idx-1;
        if (lastCurve < 0 || lastCurve > this._curveStarts.length - 1)
            return;

        return this._endPointOfCurve(lastCurve, point);
    },

    /**
    Set/get the given curve's control points 
    For set, it defaultly update the end point of last curve which acts as the start point for current curve
    @private       
    @method _endOfCurve      
    **/
    _controlPointsOfCurve: function(idx, points){

        var me = this;

        var ctrlPosOfCurve = function(idx){
            var start = me._curveStarts[idx];
            var curveType = me._curveData[start];

            var ctrlPntPos = -1; 
            var ctrlPntCount = 0;
            if (curveType === CurveTypeEnum.QuadraticCurveTo) {
                ctrlPntPos = start+1;
                ctrlPntCount = 1;   
            }else if (curveType === CurveTypeEnum.BezierCurveTo) {
                ctrlPntPos = start+1;
                ctrlPntCount = 2;
            }
            return [ctrlPntPos, ctrlPntCount];
        }; 

        var ctrlPntInfo = ctrlPosOfCurve(idx); 
        if (ctrlPntInfo[0] === -1)
            return;

        if (points){
            if(points.length === ctrlPntInfo[1]){
                for (var i=0; i < points.length; i++){
                    this._curveData[ctrlPntInfo[0]+i*2] = points[i].x;
                    this._curveData[ctrlPntInfo[0]+i*2+1] = points[i].y;
                }
            }
            return;
        } else {
            var ctrlPoints = [];
            var pointCount = ctrlPntInfo[1];
            for (var i=0; i < pointCount; i++){
                ctrlPoints.push(new Point2D(this._curveData[ctrlPntInfo[0]+i*2], 
                                            this._curveData[ctrlPntInfo[0]+i*2+1]));
            }
            return ctrlPoints;
        }
    }

};

/** 
2D paths are vector shapes on a 2D plane, such as the graphic objects 
you would find in a vector-based graphics program like Adobe Illustrator. 
They can be extruded to create 3D shapes using the Solid.extrude() function.
The Path2D API is equivalent to the HTML5 Canvas API's methods for creating paths.

Create an object that represents a 2D path. 
Call this constructor with JavaScript's standard new keyword: new Path2D() By default, the path is empty. 
Add line and curve segments to the path using the methods described below.
@param {JSON} [json] JSON received from the toJSON method.  Throws exception if JSON not valid.
@class Path2D
@since 1.0.0
@constructor
@see Bezier2D
@see Line2D
@throws
**/
var Path2D = function(json) {

    /**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @private 
    @property {_Path2D} _impl
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Path2D()
    });

    // Load a copy because we don't want to end up altering
    // data that might be shared and this is a bit tricky 
    // because we don't know whether it's shared in all cases
    // because we access parameters using defaultValue for
    // both the presets as well as the instances.  For preset
    // values we would want a copy.  For instances we would
    // not necessarily need a copy, but probably should to
    // allow cancel workflows in the future anyway.
    if (json && json.data && json.starts) {
        this._impl._curveData = json.data.slice(0),
        this._impl._curveStarts = json.starts.slice(0)
    }

};

Path2D.prototype = { 

    /** 
    Sets the path's current point to the point (x, y).
    The current point is used by a path's line-drawing methods 
    as the starting point for each added line segment. By default, 
    the current point of a newly created path lies at (0, 0).
    @method moveTo
    @since 1.0.0
    @param {Number} x coordinate x of end point
    @param {Number} y coordinate y of end point
    @chainable
    **/     
    moveTo: function(x, y) {
        if (arguments.length !== 2 || 
            typeof(arguments[0]) !== 'number' || 
            typeof(arguments[1]) !== 'number'){
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        var _impl = this._impl;
        if (!_impl._coincideWithEndPoint(x, y)){            
            _impl._curveStarts.push(_impl._curveData.length);
            _impl._curveData.push(CurveTypeEnum.MoveTo);
            _impl._curveData.push(x, y);        
        }
        return this;
    },

    /**
    Creates a straight line from the path's current point to the point (x, y). 
    After adding the line, sets the path's current point to the line's end point.     
    @method lineTo
    @since 1.0.0
    @param {Number} x coordinate x of end point
    @param {Number} y coordinate y of end point
    @chainable
    **/     
    lineTo: function(x, y) {
        if (arguments.length !== 2 || 
            typeof(arguments[0]) !== 'number' || 
            typeof(arguments[1]) !== 'number'){
            Plugin.warning(ERROR_ARGUMENTS_MESSAGE);
            return this;
        }

        var _impl = this._impl;
        if (!_impl._coincideWithEndPoint(x, y)){            
            _impl._curveStarts.push(_impl._curveData.length);
            _impl._curveData.push(CurveTypeEnum.LineTo);
            _impl._curveData.push(x, y);
        }
        return this;
    },

    /**
    Creates a cubic B&eacute;zier curve from the path's current point to the point (x, y), 
    with two control points at (cp1x, cp1y) and (cp2x, cp2y) that control the curvature 
    of the resulting curve. After adding the line, sets the path's current point to this line's end point.
    @method bezierCurveTo
    @since 1.0.0
    @param {Number} cp1x coordinate x of first control point
    @param {Number} cp1y coordinate y of first control point
    @param {Number} cp2x coordinate x of second control point
    @param {Number} cp2y coordinate y of second control point
    @param {Number} x coordinate x of end point
    @param {Number} y coordinate y of end point
    @chainable
    **/
    bezierCurveTo: function(cp1x, cp1y, cp2x, cp2y, x, y) {
        if (arguments.length !== 6 || 
            typeof(arguments[0]) !== 'number' ||
            typeof(arguments[1]) !== 'number' ||
            typeof(arguments[2]) !== 'number' ||
            typeof(arguments[3]) !== 'number' ||
            typeof(arguments[4]) !== 'number' || 
            typeof(arguments[5]) !== 'number'){
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        var _impl = this._impl;
        if (!_impl._coincideWithEndPoint(x, y)){            
            _impl._curveStarts.push(_impl._curveData.length);
            _impl._curveData.push(CurveTypeEnum.BezierCurveTo);
            _impl._curveData.push(cp1x, cp1y, cp2x, cp2y, x, y);        
        }
        return this;
    },
     
     /**
     Creates a quadratic B&eacute;zier curve from the path's current point to the point (x, y), 
     with a control point at (cpx, cpy) that controls the curvature of the resulting curve. 
     After adding the line, sets the path's current point to this line's end point.
     @method quadraticCurveTo
     @since 1.0.0
     @param {Number} cpx coordinate x of the control point
     @param {Number} cpy coordinate y of the control point
     @param {Number} x coordinate x of end point
     @param {Number} y coordinate y of end point
     @chainable
     **/
    quadraticCurveTo: function(cpx, cpy, x, y) {
        if (arguments.length !== 4 || 
            typeof(arguments[0]) !== 'number' ||
            typeof(arguments[1]) !== 'number' ||
            typeof(arguments[2]) !== 'number' || 
            typeof(arguments[3]) !== 'number'){
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        var _impl = this._impl;
        if (!_impl._coincideWithEndPoint(x, y)){          
          _impl._curveStarts.push(_impl._curveData.length);
          _impl._curveData.push(CurveTypeEnum.QuadraticCurveTo);
          _impl._curveData.push(cpx, cpy, x, y);
        }
        return this;
    },

     /** 
     Closes the path by creating a line segment from the path's current point to the start point of the path.
     @method close  
     @since 1.0.0
     @chainable
     **/     
    close: function() {
        var _impl = this._impl;
        var curveCount = _impl._curveStarts.length;
        // Find the last MoveTo record and add the LineTo to that point 
        // Ignore the case where the current curve type is MoveTo
        for (var i = curveCount - 1; i >= 0; i--) {
            var start = _impl._curveStarts[i];
            if (CurveTypeEnum.MoveTo === _impl._curveData[start]) {
                if (curveCount - 1 !== i){                
                    this.lineTo(_impl._curveData[start+1], _impl._curveData[start+2]);
                    break;
                } else {
                    break;
                }
            }
        };

        return this;
    }, 


    /** 
    Gets an array of connected path outlines.  If the first and last points are the same then the path is closed.
    @method toPolygons  
    @param {Number} [tolerance] A chord height deviation to use for discretizing nonlinear curves.
    @return {Array[Array[Number]]}
    @since 1.1.0
    @example

    // Iterate the polygons generated from the path2d
    var polygons = path2DObj.toPolygons();
    for (var i = 0; i < polygons.length; i++) {
        var polygon = polygons[i];
        for (var j = 0; j < polygon.length; j+=2) {
            var x = polygon[j];
            var y = polygon[j+1];
            ...
        }
    }

    **/
    toPolygons: function(tolerance){
        return this._impl._toPolygons(tolerance);
    },

    /**
    Returns a collection of curves whose distances to the given point is less than tolerance.
    If the given point is close to a control point of a Bezier curve, the Bezier curve will be selected too.
    The result curves are sorted on the distance to the given point from farthest to closest
    @method curvesByPoint
    @param {Point2D} point A reference point to use for finding the curves.
    @param {Number} tolerance A maximum distance from the reference point that curves can be.
    @return {Array[Line2D|Bezier2D]}
    @since 1.1.0
    **/
    curvesByPoint: function(point, tolerance){

        var curves = [];
        var curve = this.firstCurve();

        while (curve) {
            var selected = false;
            var dist = curve.distanceTo(point);
            if (dist <= tolerance){
                selected = true;
            } else if (curve instanceof Bezier2D) {
                // If point is close to control points, select the curve too.
                var ctrlPnts = curve.controlPoints;
                var ctrlPntCount = ctrlPnts.length;
                for (var i = 0; i < ctrlPntCount; i++) {
                    dist = point.distanceTo(ctrlPnts[i]);
                    if (dist <= tolerance) {
                        selected = true;
                        break;
                    }
                };
            }

            if (selected) {
                var curveObj = {
                    'dist': dist,
                    'curve': curve
                }
                curves.push(curveObj);
            }
            curve = curve.next();
        }

        // Sort the curves from farthest to closest
        curves.sort(function (o1, o2) {
            return o2.dist - o1.dist;
        });

        for (var i = 0; i < curves.length; i++) {
            curves[i] = curves[i].curve;
        };

        return curves;
    },

    /**
    Constructs the curve at the given index        
    @method curveAt
    @param {Number} idx the index of curve
    @return {Line2D|Bezier2D}
    @since 1.1.0      
    **/
    curveAt: function(idx) {
        var _impl = this._impl;

        if (idx < 0 || idx > _impl._curveStarts.length - 1){
            return undefined;
        }

        var start = _impl._curveStarts[idx];
        var curveType = _impl._curveData[start];

        var curve = undefined;
        if (curveType === CurveTypeEnum.LineTo){ 
            curve = new Line2D(idx, this);
        } else if (curveType === CurveTypeEnum.QuadraticCurveTo ||
                   curveType === CurveTypeEnum.BezierCurveTo) {
            curve = new Bezier2D(idx, this); 
        }
        return curve;
    },

    /**
    Gets the first curve of the path    
    @method firstCurve
    @return {Line2D|Bezier2D}
    @since 1.1.0
    **/
    firstCurve: function(){
        var firstIdx = this._impl._nextCurve();
        return this.curveAt(firstIdx);
    },

    /**
    Gets the last curve of the path    
    @method lastCurve
    @return {Line2D|Bezier2D}
    @since 1.1.0
    **/
    lastCurve: function(){
        var lastIdx = this._impl._prevCurve();
        return this.curveAt(lastIdx);
    },

    /**
    Returns the JSON repressentation of the object that can be serialized.  
    The resulting JSON can be passed into the constuctor later on to reconstruct the object.
    @method toJSON
    @since 1.1.0
    @return {JSON}
    @beta
    **/
    toJSON: function() {
        return {
            'data': this._impl._curveData,
            'starts': this._impl._curveStarts
        };
    },

    /** 
    Transforms the geometry on the path by a transformation matrix.
    @method transform
    @param {Matrix2D|Array[Number]} matrix A Matrix or an Array of 9 numbers.
    @since 1.0.0
    @chainable 
    @example

        // Scale to 2X and translation by 5, 5
        var tm = [
                    2, 0, 0,
                    0, 2, 0,
                    5, 5, 1
                 ];
        path.transform(tm);
    
     @example

        // Scale to 2X and translation by 5, 5
        var tm = new Matrix2D();
        tm.identity().scaling(2).translation(5, 5);
        path.transform(tm);

    **/
    transform: function(tm) {

        var mtx;
        if (Array.isArray(tm) && tm.length === 9) {
            mtx = new Matrix2D(tm);
        } else if (tm instanceof Matrix2D) {
            mtx = tm;
        } else {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        // Prevent hundreds of object creations by reusing this...
        var pt = new Point2D(0, 0);

        var curveStarts = this._impl._curveStarts;
        var curveData = this._impl._curveData;
        for (var i = 0; i < curveStarts.length; i++) {            
            var start = curveStarts[i];
            switch (curveData[start]) {
                case CurveTypeEnum.LineTo:
                case CurveTypeEnum.MoveTo:
                case CurveTypeEnum.MoveToEx:
                    pt.x = curveData[start+1];
                    pt.y = curveData[start+2];
                    pt.transform(mtx);
                    curveData[start+1] = pt.x;
                    curveData[start+2] = pt.y;
                    break;

                case CurveTypeEnum.QuadraticCurveTo:

                    pt.x = curveData[start+1];
                    pt.y = curveData[start+2];
                    pt.transform(mtx);
                    curveData[start+1] = pt.x;
                    curveData[start+2] = pt.y;

                    pt.x = curveData[start+3];
                    pt.y = curveData[start+4];
                    pt.transform(mtx);
                    curveData[start+3] = pt.x;
                    curveData[start+4] = pt.y;
                    break;

                case CurveTypeEnum.BezierCurveTo:                

                    pt.x = curveData[start+1];
                    pt.y = curveData[start+2];
                    pt.transform(mtx);
                    curveData[start+1] = pt.x;
                    curveData[start+2] = pt.y;

                    pt.x = curveData[start+3];
                    pt.y = curveData[start+4];
                    pt.transform(mtx);
                    curveData[start+3] = pt.x;
                    curveData[start+4] = pt.y;

                    pt.x = curveData[start+5];
                    pt.y = curveData[start+6];
                    pt.transform(mtx);
                    curveData[start+5] = pt.x;
                    curveData[start+6] = pt.y;
                    break;

                default:
                    break;
            }
        }

        return this;
    },

    /**
    Clones the Path2D object
    @method clone
    @return {Path2D}
    @since 1.11.0
    **/
    clone:  function() {
        var path = new Path2D(); 
        path._impl._curveData = this._impl._curveData.slice(0);
        path._impl._curveStarts = this._impl._curveStarts.slice(0);
        return path;
    }

    /**
    Gets the winding order of the path.
    @method windingOrder
    @return {WindingOrder}
    @proposed
    **/
};

/**
The curve type stored in Path2D
Uses the command keyword in http://www.w3.org/TR/SVG11/paths.html#PathData
@enum CurveTypeEnum
@type String
@static
@private
**/
var CurveTypeEnum = {
    
    /**
    @default 'M'
    @property MoveTo
    @readonly
    **/
    MoveTo : 'M',
    
    /**
    @default 'L'
    @property LineTo
    @readonly
    **/
    LineTo : 'L',
    
    /**
    @default 'Q'
    @property QuadraticCurveTo
    @readonly
    **/
    QuadraticCurveTo : 'Q',
    
    /**
    @default 'B'
    @property BezierCurveTo
    @readonly
    **/
    BezierCurveTo : 'B',

    /**
    @default 'E'
    @property MoveToEx
    @readonly
    **/
    MoveToEx: 'E'

};

initializeObjectMethods(Path2D, 'Path2D');

Library.exports.Path2D = Path2D;


//plugin.js

/** 
Internal / Private data for namespace.  This is not exported so clients can not find it or use it.
@class _Plugin
@static
@private
**/
var _Plugin = {
   
    /** 
    Cache the warning strings in the string array in the form of ['warning 1', 'warning 2', ...]
    @private
    @property {Array} _warningBuffer
    **/
    _warningBuffer : Environment.getVariable(['outcomes', 'warnings'], []),
    
    /** 
    Cache the warning strings in the string array in the form of ['warning 1', 'warning 2', ...]
    @private
    @property {String} _warningBuffer
    **/
    _panicString : undefined,
    
    _addWarning: function(str){
        this._warningBuffer.push(str);       
        return this;
    },
    _panic: function(str){
        Environment.setVariable(['outcomes', 'panic'], str);
        var panicHandler = Environment.getVariable(['callbacks', 'panic']);
        if (panicHandler) {
          panicHandler(str);
        }        
        return this;
    }
    
}  

/** 
When a shape script runs, it is executed remotely in the Tinkercad cloud where it has access to the computing resources of a large cluster of server computers. When everything is going as expected, your script will only need to return the 3D solid it has generated.
In error situations and for debugging purposes, you may need to send back some other data as well. These functions allow you to return data from your Creative Platform Library back to the app.
@class Plugin
@since 1.0.0
@static
**/
var Plugin = {

     /** 
     Send the string str to the script editor as a warning. The script will continue to execute, but the warning will be printed in the editor and on the affected shape.
     @method warning
     @since 1.0.0
     @param {String} str The warning string.
     @chainable
     **/
    warning: function(str) {
        if(str && typeof str.toString === 'function'){
            _Plugin._addWarning(str.toString());
        }
        
        return this;
    },

     /** 
     Declare an unrecoverable error. Script execution is ended immediately, and the str string argument is returned to the editor.
     The result of the shape script will be in an error state. Unfinished results are not shown to the user. If your script has constructed a mesh, calling Plugin.panic() will discard it.
     @method panic
     @since 1.0.0
     @param {String} str The panic string.
     @chainable
     **/
    panic: function(str) {
        if(str && typeof str.toString === 'function'){
            _Plugin._panic(str.toString());
        }
        
        return this;
    }

};

// Create the IMPL such that clients can't see it
Object.defineProperty(Plugin, '_impl', {
       writable: false,
       enumerable: false,
       configurable: false,
       value: _Plugin
});

Library.exports.Plugin = Plugin;
initializeObjectMethods(Plugin, 'Plugin');

//solid.js

/**
Solids are Tinkercad's internal representation of 3D shapes.
The functions available on the Solid object are used to convert between shape representations.
Note that valid Solid objects can't be constructed using the new keyword.
Instead you can create Solids using the Solid.make() and Solid.extrude() methods.
Once a Solid object has been made from paths or meshes, its contents can't be edited.
However the solid can be transformed in space using a transformation matrix - see the transform() method below.
@class Solid
@static
@since 1.0.0
**/
var Solid = {

    /**
    Takes paths from the passed in array or Sketch2D instance and extrudes them to produce a solid
    @method extrude
    @since 1.0.0
    @param {Array[Path2D] | Sketch2D} param A specific subset of Path2D objects or an entire Sketch2D.
    @param {Number} height The height for extrusion.
    @return {Solid3D} Return the result solid object.
    **/
    extrude: function(param, height) {
        if( arguments.length !== 2 
           || !( Array.isArray(arguments[0]) || arguments[0] instanceof Sketch2D ) 
           || typeof(arguments[1]) !== 'number') {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        var mesh = Creation.extrude({
                geometry: param,
                distance: height,
                start: true,
                end: true,
                sides: true
            });

        var result = new Solid3D(mesh);
        return result;
    },

    /**
    Takes a Mesh3D object and converts it to a solid representation.
    You must call this function to produce a valid Solid object that
    can be the return value of the script's process() function.
    @method make
    @since 1.0.0
    @param {Mesh3D} mesh The input mesh data
    @return {Solid3D} Return the result solid object
    **/
    make: function(mesh) {

        var result = new Solid3D(mesh);
        return result;
    }

};

Library.exports.Solid = Solid;
initializeObjectMethods(Solid, 'Solid');

//solid3d.js

/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _Solid3D
@private
**/
var _Solid3D = function(mesh) {

     /** 
     The mesh data.
     @private
     @property _mesh
     **/
     this._mesh = mesh;

}; 
  
/**
Represents manifold geometry that is water-tight and may contain multiple lumps.
@class Solid3D
@since 1.0.0
@see Solid
@see Solid#make
@see Solid#extrude
**/
var Solid3D = function(mesh) {

    /**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @private 
    @property {_Solid3D} _impl
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Solid3D(mesh)
    });

    /**
    Returns the mesh object inside the solid instance.
    @property {Mesh3D} mesh
    @since 1.2.0
    **/
    Object.defineProperty(this, 'mesh', {
        get : function(){ 
            return this._impl._mesh;
        },
        enumerable : true
    });
};

Solid3D.prototype = { 

     /** 
     Transforms the solid object by the transformation matrix given in tm, 
     which must be a 16-element array of numbers or a Matrix3D instance.
     @method transform
     @since 1.0.0
     @param {Matrix3D|Array[Number]} matrix A Matrix3D instance or an array of 16 numbers
     @chainable

     @example

        // Scale to 2X and translation by 5, 5, 5
        var tm = [
                    2, 0, 0, 0,
                    0, 2, 0, 0,
                    0, 0, 2, 0,
                    5, 5, 5, 1
                 ];
        solid.transform(tm);
    
     @example

        // Scale to 2X and translation by 5, 5, 5
        var tm = new Matrix3D();
        tm.identity().scaling(2).translation(5, 5, 5);
        solid.transform(tm);

     **/
    transform: function(tm) {
        this._impl._mesh.transform(tm);
        return this;
    },

    /** 
     Overrides the default serialization process of JSON.stringify method, and 
     returns the serialized JSON with below format
     @example
     {
        "Verts":  [x1, y1, z1, x2, y2, z2, ...],
        "Tris":   [0, 1, 2, ...],
        "Bounds": [minX, minY, minZ, maxX, maxY, maxZ]
     }
     @method toJSON
     @since 1.6.0
     @return {String} 
     **/
    toJSON: function() {

        var mesh = this._impl._mesh;
        var meshData = {};
        if (mesh) {
            var bounds = mesh.bounds();
            if (bounds) {
                var bmin = bounds.min;
                var bmax = bounds.max;    
                meshData['Verts'] = mesh._impl._vertices;
                meshData['Tris'] = mesh._impl._triangles;
                meshData['Bounds'] = [bmin.x, bmin.y, bmin.z, bmax.x, bmax.y, bmax.z];
            }
        } 
        return meshData;
        
    }

};

initializeObjectMethods(Solid3D, 'Solid3D');

Library.exports.Solid3D = Solid3D;


//tess.js
/**
To achieve optimal precision, shapes are recomputed when they are scaled.
These utility functions allow you to control the level of tessellation based on contextual awareness.
@class Tess
@since 1.0.0
@static
**/

// Get the Tesselator
// In the node.js environment, the libtess2 is preferred for better performance
// In other cases like browser environment or libtess2 can't be loaded, the tess2.min.js is used
// Clients should call function "tessellator" to get the tessellator to use
var _Tessellator = undefined;

function _tessellator() {

    if (!_Tessellator) {
        // Tesselator...
        var tess = Environment.module('tess');
        if (tess) {
            // C++ Module
            _Tessellator = tess.Tess2;
        } else {
            // JavaScript
            _Tessellator = thirdPartyExports.Tess2;
        }
    }
    return _Tessellator;

}

var Tess = {

    /**
    Estimate circle divisions based on radius and tesselation tolerance
    @method circleDivisions
    @since 1.0.0
    @param {Number} radius the input radius length
    @return {Number} Return the number of divisions
    **/
    circleDivisions: function(radius) {

        if(typeof(radius) !== 'number' || radius < weldThreshold()) {
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        var divAngle = Math.acos(radius/(radius + Tess.tolerance())) * 2.0;
        var divisions = parseInt(Math.ceil(Math.PI*2/divAngle));
        divisions = parseInt((divisions+3)/4) * 4; // round to nearest 4
        return divisions<4 ? 4: divisions;

    },

    /**
    Get the tolerance for tessellation
    @method tolerance
    @since 1.0.0
    @return {Number} Return the number of tolerance
    **/
    tolerance: function() {
        return tessTolerance();
    },

    /**
    Extracts the boundaries from the contours.  If some contours overlap  eachother, the outcome is effected by the winding rule.
    @method boundariesFromContours
    @param {Array[Array[Number]]} contours This is an array of arrays, most likely obtained from {Sketch2D#toPolygons}.
    @param {WindingRule} [windingRule] The winding rule to use for boundary generation.  See documentation for {WindingRule} for more information.
    @return {Array[Array[Number]]}
    @see Sketch2D#toPolygons
    @see Tess#polygonsFromBoundaries
    @see WindingRule
    @since 1.17.0
    **/
    boundariesFromContours: function(contours, windingRule) {
        var rule = (undefined == windingRule) ? WindingRule.NonZero : windingRule;
        var boundaries = _Creation._extractBoundaryContours(contours, rule);
        return boundaries;
    },

    /**
    Given the boundaries from {Tess#boundariesFromContours}, this will generate the tesselation information.
    @method polygonsFromBoundaries
    @param {Array[Array[Number]]} boundaries The list of boundaries from {Tess#boundariesFromContours}.
    @return {Object} result Polygon information about
      @return {Array[Number]} result.vertices An array of vertex positions.
      @return {Array[Number]} result.triangleIndices An array of the triangle indices, where the size is the number of triangles * 3.
      @return {Array[Number]} result.boundaryIndices An array of boundary indices, where the size is the number of boundaries * 2.
    @since 1.17.0
    @see Sketch2D#toPolygons
    @see Tess#boundariesFromContours
    @see WindingRule
    **/
    polygonsFromBoundaries: function(boundaries) {

        var polygons = _Creation._extractPolygons(boundaries, WindingRule.NonZero);

        var vertices = polygons.vertices;
        var triangleIndices = [];
        var boundaryIndices = [];

        var element = 0;
        var elements = polygons.elements;
        var elementQty = elements.length;

        for (element = 0; element < elementQty; element += 6) {
            triangleIndices.push(elements[element], elements[element+1], elements[element+2]);
            for (var index = 0; index < 3; index++) {
                if (elements[element + index + 3] != -1){
                    continue;
                }
                var va = elements[element + index];
                var vb = elements[element + (index + 1) % 3];
                boundaryIndices.push(va);
                boundaryIndices.push(vb);
            }
        }

        return { 'vertices': vertices, 'triangleIndices': triangleIndices, 'boundaryIndices': boundaryIndices };
    }
};

Library.exports.Tess = Tess;
initializeObjectMethods(Tess, 'Tess');

//box2d.js
/**   
An axis-aligned repressentation of a 2D box.
@class Box2D
@since 1.1.0
@constructor
@see Sketch2D#bounds
**/
var Box2D = function(min, max){

    /**
    The bottom left point of the box 
    @property {Point2D} min
    @since 1.1.0
    **/
    this.min = min;


    /**
    The top right point of the box
    @property {Point2D} max
    @since 1.1.0
    **/
    this.max = max;

};

Box2D.prototype = {

    /**
    Gets the length of the box. It corresponds to the x dimension.
    @method length
    @return {Number} 
    @since 1.1.0
    **/
    length: function(){
        return (this.max.x - this.min.x);
    },

    /**
    Gets the width of the box. It corresponds to the y dimension.
    @method width
    @return {Number} 
    @since 1.1.0
    **/
    width: function(){
        return (this.max.y - this.min.y);
    },

    /**
    Computes and returns the midpoint of the box.
    @method center
    @return {Point2D}
    @since 1.6.0
    **/
    center: function() {
        return new Point2D(
                (this.max.x + this.min.x) * 0.5,
                (this.max.y + this.min.y) * 0.5
            );
    },

    /**
    Clones the Box2D.
    @method clone
    @return Box2D
    @since 1.6.0
    **/
    clone: function() {
        var min = this.min.clone();
        var max = this.max.clone();
        return new Box2D(min, max);
    },

    /**
    @implements IDebuggable
    @method debug
    @since 1.6.0
    **/
    debug: function() {
        var xmin = this.min.x;
        var ymin = this.min.y;
        var xmax = this.max.x;
        var ymax = this.max.y;

        Debug.line(xmin, ymin, 0.0, xmax, ymin, 0.0);
        Debug.line(xmax, ymin, 0.0, xmax, ymax, 0.0);
        Debug.line(xmax, ymax, 0.0, xmin, ymax, 0.0);
        Debug.line(xmin, ymax, 0.0, xmin, ymin, 0.0);
    }

}

initializeObjectMethods(Box2D, 'Box2D');

/*
 * Export it for public use
 */
Library.exports.Box2D = Box2D;

//box3d.js
/**
An axis-aligned 3D box.
@class Box3D
@constructor
@param {Point3D} min The bottom left point of the 
@param {Point3D} max The top right point of the 
@since 1.6.0
**/
var Box3D = function(min, max) {
    /**
    The bottom left point of the box 
    @property {Point3D} min
    **/
    this.min = min;

    /**
    The top right point of the box
    @property {Point3D} max
    **/
    this.max = max;
};

Box3D.prototype = {
    /**
    Gets the length of the box. It corresponds to the x dimension.
    @method length
    @return {Number}
    **/
    length: function() {
        return Math.max(this.max.x - this.min.x, 0);
    },

    /**
    Gets the width of the box. It corresponds to the y dimension.
    @method width
    @return {Number}
    **/
    width: function() {
        return Math.max(this.max.y - this.min.y, 0);
    },

    /**
    Gets the height of the box. It corresponds to the z dimension.
    @method height
    @return {Number}
    **/
    height: function() {
        return Math.max(this.max.z - this.min.z, 0);
    },

    /**
    Computes and returns the midpoint of the box.
    @method center
    @return {Point3D}
    **/
    center: function() {
        return new Point3D(
                (this.max.x + this.min.x) * 0.5,
                (this.max.y + this.min.y) * 0.5,
                (this.max.z + this.min.z) * 0.5
            );
    },

    /**
    Clones the Box3D.
    @method clone
    @return Box3D
    **/
    clone: function() {
        var min = this.min.clone();
        var max = this.max.clone();
        return new Box3D(min, max);
    },

    /**
    @implements IDebuggable
    @method debug
    **/
    debug: function() {
        var xmin = this.min.x;
        var ymin = this.min.y;
        var zmin = this.min.z;
        var xmax = this.max.x;
        var ymax = this.max.y;
        var zmax = this.max.z;

        // bottom
        Debug.line(xmin, ymin, zmin, xmax, ymin, zmin);
        Debug.line(xmax, ymin, zmin, xmax, ymax, zmin);
        Debug.line(xmax, ymax, zmin, xmin, ymax, zmin);
        Debug.line(xmin, ymax, zmin, xmin, ymin, zmin);

        // top
        Debug.line(xmin, ymin, zmax, xmax, ymin, zmax);
        Debug.line(xmax, ymin, zmax, xmax, ymax, zmax);
        Debug.line(xmax, ymax, zmax, xmin, ymax, zmax);
        Debug.line(xmin, ymax, zmax, xmin, ymin, zmax);

        // Front
        Debug.line(xmax, ymin, zmin, xmax, ymin, zmax);
        Debug.line(xmin, ymin, zmax, xmin, ymin, zmin);

        // back
        Debug.line(xmax, ymax, zmin, xmax, ymax, zmax);
        Debug.line(xmin, ymax, zmax, xmin, ymax, zmin);
    }
};

initializeObjectMethods(Box3D, 'Box3D');

/*
 * Export it for public use
 */
Library.exports.Box3D = Box3D;
//ray3d.js
/**
A 3D Ray.
@class Ray3D
@constructor
@param {Point3D} origin The origin of the ray.
@param {Vector3D} direction The direction of the ray, which should be a normalized unit vector.
@since 1.6.0
**/
var Ray3D = function(origin, direction) {
    /**
    The origin of the ray.
    @property {Point3D} origin
    @since 1.6.0
    **/
    this.origin = origin;

    /**
    The direction of the ray.
    @property {Vector3D} direction
    @since 1.6.0
    **/
    this.direction = direction;
};

Ray3D.prototype = {
    /**
    Clones the Ray3D.
    @method clone
    @return Ray3D
    @since 1.6.0
    **/
    clone: function() {
        var direction = this.direction.clone();
        var origin = this.origin.clone();
        return new Ray3D(origin, direction);
    },

    /**
    @implements IDebuggable
    @method debug
    @since 1.6.0
    **/
    debug: function() {
        var dir = this.direction;
        var o = this.origin;
        Debug.line(
            o.x, o.y, o.z,
            o.x + dir.x, o.y + dir.y, o.z + dir.z
        );
    }
};

initializeObjectMethods(Ray3D, 'Ray3D');

/*
 * Export it for public use
 */
Library.exports.Ray3D = Ray3D;
//sketch2d.js
/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _Sketch2D
@private
*/
var _Sketch2D = function() {

    /**
    The array of the Path2D objects.
    @private 
    @property {Array[Path2D]} paths
    **/
    this.paths = [];

};

_Sketch2D.prototype = {

    /**
    Calculates the bounds of Sketch2D object
    @method _bounds
    @private
    @return {Box2D} 
    **/
    _bounds: function(){

        var xmin = Number.MAX_VALUE;
        var xmax = -Number.MAX_VALUE;
        var ymin = Number.MAX_VALUE;
        var ymax = -Number.MAX_VALUE;

        for (var i = 0, pathCount = this.paths.length; i < pathCount; i++) {
            var polygons = this.paths[i].toPolygons();
            for (var j = 0, polyCount = polygons.length; j < polyCount; j++) {
                var polygon = polygons[j];
                for (var k = 0, polyLen = polygon.length; k < polyLen; k+=2) {
                    var x = polygon[k];
                    var y = polygon[k+1];

                    if (x < xmin) {
                        xmin = x;
                    } 
                    if (x > xmax) {
                        xmax = x;
                    }
                    if (y < ymin) {
                        ymin = y;
                    } 
                    if (y > ymax) {
                        ymax = y;
                    }
                };
            };
        };

        var bounds = undefined;
        if (xmin < xmax && ymin < ymax){
            bounds = new Box2D(new Point2D(xmin, ymin), new Point2D(xmax, ymax));
        }
        return bounds;
    }

};


/** 
Creates an object that represents a 2D sketch. It contains an array of Path2D objects.
@param {Array[Path2D]|JSON|Sketch2D} [other] An array of Path2D objects, JSON received from the toJSON method, or another Sketch2D object.  This will not create a copy if a Sketch2D is supplied.  Throws exception if JSON not valid.
@class Sketch2D
@constructor
@since 1.1.0
@throws
@markdown
**/
var Sketch2D = function(other) {

    /**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @property {_Sketch2D} _impl
    @private 
    @since 1.1.0
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Sketch2D()
    });
    
    /**
    The array of the Path2D objects.
    @property {Array[Path2D]} paths
    @since 1.1.0
    **/
    Object.defineProperty(this, 'paths', {
        get : function() { 
            // Return a copy of the paths array. So that clients can't modify it.
            var clone = this._impl.paths.slice(0);
            return clone; 
        },
        enumerable : true
    });

    // Load it from the JSON...
    if (other) {
        if (Array.isArray(other)) {
            // other is an array of Path2D objects
            var paths = this._impl.paths;
            for (var k = 0, npaths = other.length; k < npaths; k++) {
                var path = other[k];
                if (path instanceof Path2D) {
                    paths.push(path);
                }
            }
        } else if (other instanceof Sketch2D) {
            // Clone the Path2D objects.
            var paths = other._impl.paths;
            var implPaths = this._impl.paths;
            for(var k = 0; k < paths.length; k++){
                implPaths.push(paths[k].clone());
            }
        } else {
            for (var i = 0; i < other.paths.length; i++) {
                var path2D = new Path2D(other.paths[i]);
                this._impl.paths.push(path2D);
            }            
        }
    }
};

Sketch2D.prototype = { 

    /**
    Calculates the bounds of the Sketch2D object
    @method bounds
    @return {Box2D} 
    @since 1.1.0
    **/
    bounds: function() {
        return this._impl._bounds();
    },

    /** 
    Gets an array of connected path outlines for all the paths in the sketch.  
    If the first and last points are the same then the path is closed.
    @method toPolygons  
    @param {Number} [tolerance] A chord height deviation to use for discretizing nonlinear curves.
    @return {Array[Array[Number]]}
    @since 1.1.0
    **/
    toPolygons: function(tolerance) {
        var polygons = [];
        var paths = this._impl.paths;
        for (var i = 0; i < paths.length; i++) {
            var pathPolygons = paths[i].toPolygons(tolerance);
            for (var j = 0; j < pathPolygons.length; j++) {
                polygons.push(pathPolygons[j]);
            }
        }
        return polygons;
    },

    /**
    Returns the JSON representation of the object that can be serialized.  
    The resulting JSON can be passed into the constructor later on to reconstruct the object.
    @method toJSON
    @return {JSON}
    @since 1.1.0
    **/
    toJSON: function() {
        var results = [];
        var paths = this._impl.paths;
        for (var i = 0; i < paths.length; i++) {
            results.push(paths[i].toJSON());
        }
        return {
            'paths': results 
        };
    },

    /** 
    Transforms all the paths in the sketch by the transform.
    @method transform
    @param {Matrix2D|Array[Number]} matrix A Matrix or an Array of 9 numbers.
    @since 1.1.0
    @chainable  
    **/
    transform: function(tm) {
        var paths = this._impl.paths;
        for (var i = 0; i < paths.length; i++) {
            var path = paths[i];
            path.transform(tm);
        }
        return this;
    },

    /**
    Clones the Sketch2D object
    @method clone
    @return {Sketch2D}
    @since 1.11.0
    **/
    clone:  function() {
        var sketch2D = new Sketch2D();
        var paths = this._impl.paths;
        var implPaths = sketch2D._impl.paths;
        for(var i = 0; i < paths.length; i++){
            implPaths.push(paths[i].clone());
        }
        return sketch2D;
    },

    /** 
    Projects a boundary onto the sketch as an additional Path2D object.
    @method projectBoundary
    @param {Mesh3DBoundary} boundary A boundary to project onto the Sketch2D.
    @param {Matrix3D} projection The projection matrix to use for the projection.
    @chainable
    @since 1.13.0
    **/
    projectBoundary: function(boundary, projection) {
        if(!(boundary instanceof Mesh3DBoundary) || !(projection instanceof Matrix3D)){
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        // Transform vertices in boundary
        var mesh = boundary.mesh;
        var indices = boundary.vertexIndices;
        var elements = projection.elements;

        var transformPoint = function(index){
            var p = mesh.vertexByIndex(index);
            var pt = {x:p[0], y:p[1], z:p[2]};
            var x = pt.x * elements[0] + pt.y * elements[4] + pt.z * elements[8] + elements[12];
            var y = pt.x * elements[1] + pt.y * elements[5] + pt.z * elements[9] + elements[13];
            return {x:x, y:y};
        };

        var path = new Path2D();

        // Move to first point
        var p = transformPoint(indices[0]);
        path.moveTo(p.x, p.y);

        for(var i = 1, count = indices.length; i < count; i++) {
            // Line to other points
            p = transformPoint(indices[i]);
            path.lineTo(p.x, p.y);
        }

        if(indices[0] != indices[indices.length -1]){
            // Make sure to close the path
            p = transformPoint(indices[0]);
            path.lineTo(p.x, p.y);
        }

        this._impl.paths.push(path);

        return this;
    },

    /**
    Combines this sketch with supplied sketch(es) or paths.
    @method combine
    @param {Sketch2D|Array[Sketch2D]} sketches One or more sketches.
    @chainable
    @since 1.16.0
    **/
    combine: function(sketches) {
        var paths = this._impl.paths;
        if (Array.isArray(sketches)) {
            for (var i = 0, nsketches = sketches.length; i < nsketches; i++) {
                Array.prototype.push.apply(paths, sketches[i]._impl.paths);
            }
        } else {            
            Array.prototype.push.apply(paths, sketches._impl.paths);
        }
        return this;
    }
};

/**
The winding rule that determines the interior of the sketch.
@property {WindingRule} windingRule
@default WindingRule.NonZero
@since 1.17.0
**/
Object.defineProperty(Sketch2D.prototype, 'windingRule', {
    enumerable: true,
    configurable: false,
    get: function() {
        return this._impl.windingRule !== undefined ? this._impl.windingRule : WindingRule.NonZero;
    },
    set: function(val) {
        var valid = false;
        for (var key in WindingRule) {
            if (WindingRule[key] === val) {
                valid = true;
                break;
            }
        }
        if (!valid) {
            Plugin.panic("Invalid windingRule value.");
        }
        this._impl.windingRule = val;
    }
});

initializeObjectMethods(Sketch2D, 'Sketch2D');
Library.exports.Sketch2D = Sketch2D;

/* This registers the deserializer for the shape generator parameter */
Environment.setVariable(['parameters', 'sketch', 'deserializer'], function(json) {
    return new Sketch2D(json);
});
//selection.js
/**
A base selection class that is derived from.
@class Selection
@since 1.8.0
@see Mesh3DSelection
**/
var Selection = function() {
    /**
    The selector that was used to obtain the selection.
    @property {Selector} selector
    @optional
    **/
    this.selector = null;

    /**
    The relative distance from the selector source to this object to the collision.
    @property {Number} distance
    @optional
    **/
    this.distance = Number.MAX_VALUE;

    /**
    The point of the collision in local space from the selector.
    @property {Point3D} collision
    @optional
    **/
    this.collision = null;
};

//mesh3dselection.js
/**
A selection for a {Mesh3D} object.
@class Mesh3DSelection
@extends Selection
@constructor
@param {Mesh3D} mesh The {Mesh3D} object.
@param {Array[Number]} triangleIndices The indices of the triangles that this selection identifies.
@since 1.8.0
**/
var Mesh3DSelection = function(mesh, triangleIndices) {

    // Base class
    Selection.call(this);

    /**
    The mesh that this selection relates to.
    @property {Mesh3D} mesh
    **/
    this.mesh = mesh;

    /**
    The set of triangles on the mesh this selection relates to identified by the triangle indices.
    @property {Array[Number]} triangleIndices
    **/
    this.triangleIndices = triangleIndices;
};

Mesh3DSelection.prototype = {
    /**
    Computes the boundaries of the selection.
    @method boundaries
    @return {Array[Mesh3DBoundary]}
    @since 1.8.0
    **/
    boundaries: function() {
        return this.mesh.boundariesByTriangles(this.triangleIndices);
    },

    /**
    Expands the selection to all neighboring coplanar triangles in the mesh, until a non-coplanar triangle is discovered.
    @method expandByCoplanar
    @param {Number} tolerance The tolerance of triangle normal angles in radians.
    @since 1.13.0
    @chainable
    **/
    expandByCoplanar: function(tolerance){
        if(!this.mesh || !this.triangleIndices || this.triangleIndices.length === 0){
            return this;
        }

        if (tolerance === undefined) {
            tolerance = 10e-6;
        }

        var seed = this.triangleIndices[0];
        var pendingList = [seed];
        var visitedTriangles = {};
        var plane = [];

        var mesh = this.mesh;
        var meshImpl = mesh._impl;
        var vertices = meshImpl._vertices;
        var indices = meshImpl._triangles;

        var nseed = meshImpl._triangleNormal(indices, vertices, seed);
        var nseedNormal = new Vector3D(nseed[0], nseed[1], nseed[2]);
        var niNormal = new Vector3D();

        var t, angle;
        while(pendingList.length > 0){
            t = pendingList.shift();
            visitedTriangles[t] = true;
            plane.push(t);

            var adjacentTriangles = mesh.trianglesByTriangle(t, true);
            for(var i = 0; i < adjacentTriangles.length; i++){
                var tempt = adjacentTriangles[i];
                if(!visitedTriangles[tempt]){
                    var ni = meshImpl._triangleNormal(indices, vertices, tempt);
                    niNormal.x = ni[0];
                    niNormal.y = ni[1];
                    niNormal.z = ni[2];
                    if(nseedNormal.dot(niNormal) > 1 - tolerance){
                        pendingList.push(tempt);
                    }

                    visitedTriangles[tempt] = true;
                }
            }
        }

        this.triangleIndices = plane;
        return this;
    },

    /**
    Clones a new selection from this selection.
    @method clone
    @return Mesh3DSelection
    @since 1.8.0
    **/
    clone: function() {
        return new Mesh3DSelection(this.mesh, this.triangleIndices);
    },

    /**
    @implements IDebuggable
    @method debug
    @since 1.8.0
    **/
    debug: function() {
        var triangleList = [];
        var tis = this.triangleIndices;
        var mesh = this.mesh;
        for(var i = 0; i < tis.length; i++) {
            var t = mesh.triangleByIndex(tis[i]);
            var v0 = mesh.vertexByIndex(t[0]);
            var v1 = mesh.vertexByIndex(t[1]);
            var v2 = mesh.vertexByIndex(t[2]);
            triangleList.push(
                v0[0], v0[1], v0[2],
                v1[0], v1[1], v1[2],
                v2[0], v2[1], v2[2]
            );
        }
        Debug.triangles(triangleList);
    }
};

initializeObjectMethods(Mesh3DSelection, 'Mesh3DSelection');

Library.exports.Mesh3DSelection = Mesh3DSelection;

//mesh3dboundary.js
/**
A boundary within a {Mesh3D} object.
@class Mesh3DBoundary
@since 1.8.0
**/
var Mesh3DBoundary = function() {
    /**
    The counter-clockwise list of vertex indices that this boundary is represented by.
    @property {Array[Number]} vertexIndices
    **/
    this.vertexIndices = [];

    /**
    The mesh that this boundary relates to.
    @property {Mesh3D} mesh
    **/
    this.mesh = null;
};


Mesh3DBoundary.prototype = {
    /**
    @implements IDebuggable
    @method debug
    @since 1.8.0
    **/
    debug: function() {

        if(!this.mesh || this.vertexIndices.length < 3) {
            return;
        }

        var vertices = this.mesh._impl._vertices;
        var indices = this.vertexIndices.slice(0);

        // Ensure it's closed.
        if (indices[0] != indices[indices.length -1]) {
            indices.push(indices[0]);
        }

        for(var i = 0, count = indices.length - 1; i < count; i++) {
            var i0 = 3 * indices[i];
            var i1 = 3 * indices[i + 1];
            Debug.line(
                vertices[i0], vertices[i0 + 1], vertices[i0 + 2],
                vertices[i1], vertices[i1 + 1], vertices[i1 + 2]
            );
        }
    }
};

initializeObjectMethods(Mesh3DBoundary, 'Mesh3DBoundary');

Library.exports.Mesh3DBoundary = Mesh3DBoundary;
//selector.js
/**
This interface outlines the functions and operational guidelines that objects must adhere to if they can be selected.
@interface ISelectable
@since 1.8.0
**/
var ISelectable = function() {
};

ISelectable.prototype = {
    /**
    The object performs a selection on itself or elements within itself based on the criteria defined on the {Selector} and appends the results.
    @method select
    @param {Selector} selector The selector that defines the criteria for the selection.
    @required
    **/
    select: function(selector) {
    }
};


/**
The Selector can be used with any object that implements the {ISelectable} to select aspects of the object or its children.
@class Selector
@since 1.8.0
**/
var Selector = function() {
    /**
    When selecting based on a ray, this defines the ray in local object space.  In the future, as other techniques are added like Window Selection, there may be another member such as frustum which can be used to define an area.
    @property {Ray3D} ray
    @optional
    **/
    this.ray = null;

    /**
    A list of selections that satisfy the selector's properties.  This list is populated when an object implementing {ISelectable#select} is invoked.
    @property {Array[Selection]} selections
    **/
    this.selections = [];
};


Selector.prototype = {
    /**
    Returns the {Selector#selections} member sorted by distance, based upon the {Selection#distance} field such that the nearest item is returned first, and the furthest item last.
    @method selectionsByDistance
    @return {Array[Selection]}
    @since 1.8.0
    **/
    selectionsByDistance: function() {
        var sorter = function(a, b) {
            return a.distance > b.distance;
        };
        this.selections.sort(sorter);
        return this.selections;
    },

    /**
    @implements IDebuggable
    @method debug
    @since 1.8.0
    **/
    debug: function() {
        this.ray.debug();
        for(var i = 0, count = this.selections.length; i < count; i++) {
            this.selections[i].debug();
        }
    }
};

initializeObjectMethods(Selector, 'Selector');

Library.exports.Selector = Selector;

//creation.js
/**   
Internal / Private data for creation.  This is not exported so clients can not find it or use it.
@class _Creation
@private
**/
var _Creation = {

    /**
    Get contours from Sketch2D or Path2D array.
    @method _toContours
    @private
    @param {Array[Path2D]} paths A sketch or array of {Path2D}'s to get contours.
    @return {Array} Return contours
    **/
    _toContours: function(paths) {
        var contours = [];
        for (var i = 0, pathCount = paths.length; i < pathCount; i++) {
            var path = paths[i];
            var polygons = path.toPolygons();
            for (var j = 0, polyCount = polygons.length; j < polyCount; j++) {
                contours.push(polygons[j]);
            };
        };

        return contours;
    },

    /**
    Extract boundary contours of the input with given winding rule. The result contains 
    only the boundary separating the interior and exterior of the input contours. 
    @private
    @method _extractBoundaryContours
    @return {Array} Return contours
    **/
    _extractBoundaryContours: function(contours, windingRule) {
        var Tessellator = _tessellator();
        var elementType = Tessellator.BOUNDARY_CONTOURS;
        
        var polySize = 2, vertexSize = 2;
        var options = {
            contours: contours,
            windingRule: windingRule,
            elementType: Tessellator.BOUNDARY_CONTOURS,
            polySize: polySize,
            vertexSize: vertexSize,
            normal: [0, 0, 1]
        };
        var result = Tessellator.tesselate(options);

        contours = [];
        if (!result) {
            return contours;
        }

        var vertexCount = result.vertexCount;
        var vertices = result.vertices;
        var elements = result.elements;

        var verticesLength = vertices.length;
        var elementsLength = elements.length;
        var elementOffset = polySize;

        for (var elementIndex = 0; elementIndex < elementsLength; elementIndex += elementOffset) {
            var start = elements[elementIndex];
            var count = elements[elementIndex + 1];
            var contour = [];
            var startIndex = start * vertexSize;
            for (var vertexIndex = 0; vertexIndex < vertexSize * count; vertexIndex ++) {
                contour.push(vertices[startIndex + vertexIndex]);
            }
            contours.push(contour);
        }

        return contours;
    },

    /**
    Tessellate the contours to get polygons. Returns tessellation result.
    @method _extractPolygons
    @private
    **/
    _extractPolygons : function(contours, windingRule) {
        var Tessellator = _tessellator();
        
        // Triangulation.
        var options = {
            contours: contours,
            windingRule: windingRule,
            elementType: Tessellator.CONNECTED_POLYGONS,
            polySize: 3,
            vertexSize: 2,
            normal: [0, 0, 1]
        };

        return Tessellator.tesselate(options);
    },

    /**
    Calculate bounding box of specific 2D contour.
    @method _contourBounds
    @return {Array} Return bounds in array
    @private
    **/
    _contourBounds: function(contour) {
        var minX = Number.MAX_VALUE;
        var minY = Number.MAX_VALUE
        var maxX = -Number.MAX_VALUE;
        var maxY = -Number.MAX_VALUE;
        for (var i = 0, count = contour.length; i < count; i += 2) {
            var x = contour[i];
            var y = contour[i+1];
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
        }
        return [minX, minY, maxX, maxY];
    },



    /**
    Check inner contours are inside of outer contour.
    Return: 1 contain; -1 intersect or out
    @method _contourContainment
    @return {Number} Return containment
    @private
    **/
    _contourContainment: function(outer, inners) {

        // Check if a point is in the polygon.
        function pnpoly(x, y, contour) {
            var inside = false;
            var nvert = verts.length / 2;
            for (var i = 0, j = nvert - 1; i < nvert; j = i++) {
                var xi = contour[2*i];
                var yi = contour[2*i + 1];
                var xj = contour[2*j];
                var yj = contour[2*j + 1];
                var intersect = ((yi > y) != (yj > y)) && 
                                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) {
                    inside = !inside;
                }
            }
            return inside;
        }
 
        // Check the intersection between two line segments.
        function linesIntersect(px, py, p2x, p2y, qx, qy, q2x, q2y) {
            var r = [p2x-px, p2y-py];
            var s = [q2x-qx, q2y-qy];
            var pq = [qx-px, qy-py];

            var pqxr = pq[0]*r[1] - pq[1]*r[0];
            var pqxs = pq[0]*s[1] - pq[1]*s[0];
            var rxs = r[0]*s[1] - r[1]*s[0];

            if (pqxr == 0 && rxs == 0) {
                return ((qx - px < 0) != (qx - p2x < 0) != (q2x - px < 0) != (q2x - p2x < 0)) ||
                       ((qy - py < 0) != (qy - p2y < 0) != (q2y - py < 0) != (q2y - p2y < 0));
            }

            if (rxs == 0) {
                return false;
            }

            var u = pqxr / rxs;
            var t = pqxs / rxs;
            return (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);
        }

        // outer v.s inner
        function boundsContainment(minX, minY, maxX, maxY, minX1, minY1, maxX1, maxY1) {
            if (minX > minX1 && minY > minY1 && maxX < maxX1 && maxY < maxY1) {
                return 1
            }
            return -1;
        }

        var outbounds = this._contourBounds(outer);
        for(var i = 0, icount = inners.length; i < icount; i++) {
            var inner = inners[i];
            var bounds = this._contourBounds(inner);

            var containment = boundsContainment(
                    outbounds[0], outbounds[1],outbounds[2],outbounds[3],
                    bounds[0], bounds[1], bounds[2], bounds[3]
                );
            if(containment == 1 ) {
                if(pnpoly(bounds[0], bounds[1], outer) && pnpoly(bounds[0], bounds[3], outer) && 
                   pnpoly(bounds[2], bounds[3], outer) && pnpoly(bounds[2], bounds[1], outer)) {
                    continue;
                 }
            }

            for(var j = 0, jcount = outer.length; j < jcount; j+=2) {
                for(var k = 0, kcount = inner.length; k < kcount; k+=2) {
                    var intersects = linesIntersect(
                            outer[j], outer[j+1], outer[j+2], outer[j+3], 
                            inner[k], inner[k+1], inner[k+2], inner[k+3]
                        );
                    if(intersects) {
                        return -1;
                    }
                }
            }
        }

        return 1;
    },

    /**
    Extrude from polygons.
    @method _extrudeFromPolygons
    @private
    **/
    _extrudeFromPolygons : function(vertexCount, vertices, elements, height, start, end, sides, invertNormal) {

        var verticesArr = [];
        var triIndicesArr = [];

        var topHeight = Math.max(0.0, height);
        var bottomHeight = Math.min(0.0, height);

        var vertexSize  = 2;
        var polySize = 3;

        var verticesLength = vertices.length;
        var elementsLength = elements.length;
        var elementOffset = polySize * 2;

        // Top Vertices
        for (var vertexIndex = 0; vertexIndex < verticesLength; vertexIndex += vertexSize) {
            verticesArr.push(vertices[vertexIndex], vertices[vertexIndex + 1], topHeight);
        }
        // Top Indices
        if ((height < 0 && start) || (height >= 0 && end)) {
            for (var polyIndex = 0; polyIndex < elementsLength; polyIndex += elementOffset) {
                if (invertNormal) {
                    triIndicesArr.push(elements[polyIndex + 2], elements[polyIndex + 1], elements[polyIndex]);
                } else {
                    triIndicesArr.push(elements[polyIndex], elements[polyIndex + 1], elements[polyIndex +2]);
                }                
            }
        }

        // Bottom Vertices
        for (var vertexIndex = 0; vertexIndex < verticesLength; vertexIndex += vertexSize) {
            verticesArr.push(vertices[vertexIndex], vertices[vertexIndex + 1], bottomHeight);
        }
        // Bottom Indices
        if ((height < 0 && end) || (height >= 0 && start)) {
            for (var polyIndex = 0; polyIndex < elementsLength; polyIndex += elementOffset) {
                if (invertNormal) {
                    triIndicesArr.push(elements[polyIndex] + vertexCount, elements[polyIndex + 1] + vertexCount, elements[polyIndex + 2] + vertexCount);
                } else {
                    triIndicesArr.push(elements[polyIndex + 2] + vertexCount, elements[polyIndex + 1] + vertexCount, elements[polyIndex] + vertexCount);
                }                
            }
        }

        // Sides Faces
        if (sides) {
            for (var polyIndex = 0; polyIndex < elementsLength; polyIndex += elementOffset) {
                for (var index = 0; index < 3; index++) {
                    // Check neighbor
                    if (elements[polyIndex + index + 3] != -1){
                        continue;
                    }
                    var va = elements[polyIndex + index];
                    var vb = elements[polyIndex + (index + 1) % 3];

                    if (invertNormal) {
                        triIndicesArr.push(vb, vb + vertexCount, va + vertexCount);
                        triIndicesArr.push(va, vb, va + vertexCount);
                    } else {
                        triIndicesArr.push(va + vertexCount, vb + vertexCount, vb);
                        triIndicesArr.push(va + vertexCount, vb, va);
                    }                    
                }
            }
        }

        return {
            vertices: verticesArr,
            indices:  triIndicesArr
        }
    },

    /**
    Find a region with specific boundary and create an extrusion from contour in the boundary.
    @method _emboss
    @private
    @param {Array} boundary The border
    @param {Array} contours The boundary contours of the input geometry
    @param {Number} height The height
    @return {Array} Return patched surfaces
    **/
    _emboss : function(boundary, contours, height) {
        
        var me = this;
        var Tessellator = _tessellator();

        /**   
        Internal / Private data for class.
        @class _EmbossTool
        @static
        @private
        **/
        var _EmbossTool = {

            /**
            Extrude contours in boundary.
            @method _extrudeInBorder
            @private
            **/
            _extrudeInBorder : function(boundary, contours, height) {
                // top/side faces
                // Find add profiles and create top/side faces for them
                var extractedPolys = me._extractPolygons(contours, WindingRule.EvenOdd);
                var topnside = this._extrudePolygons(extractedPolys, height);

                // Bottom Faces
                for (var i = 0; i < boundary.length; i++) {                    
                    contours.push(boundary[i]);
                }
                extractedPolys = me._extractPolygons(contours, WindingRule.EvenOdd);
                var bottom = this._toPolygons(extractedPolys);

                return [
                    {
                        vertices: topnside.vertices,
                        indices: topnside.indices
                    },
                    {
                        vertices: bottom.vertices,
                        indices: bottom.indices
                    }
                ];
            },

            /**
            Extract polygons from contours.
            @method _toPolygons
            @private
            **/
            _toPolygons: function(tessResult) {
                if(!tessResult) {
                    return { vertices: [], indices:[] };
                }
                var vertices = tessResult.vertices;
                var elements = tessResult.elements;

                var verticesArr = [];
                var triIndicesArr = [];

                var vertexSize  = 2;
                var polySize = 3;

                var verticesLength = vertices.length;
                var elementsLength = elements.length;
                var elementOffset = polySize * 2;

                for (var vertexIndex = 0; vertexIndex < verticesLength; vertexIndex += vertexSize) {
                    verticesArr.push(vertices[vertexIndex], vertices[vertexIndex + 1], 0.0);
                }
                for (var polyIndex = 0; polyIndex < elementsLength; polyIndex += elementOffset) {
                    triIndicesArr.push(elements[polyIndex], elements[polyIndex + 1], elements[polyIndex +2]);
                }

                return {
                    vertices: verticesArr,
                    indices:triIndicesArr
                }
            },

            /**
            Extrude from polygons.
            @method _extrudePolygons
            @private
            **/
            _extrudePolygons : function(tessResult, height) {
                if(!tessResult) {
                    return { vertices: [], indices:[] };
                }

                var vertexCount = tessResult.vertexCount;
                var vertices = tessResult.vertices;
                var elements = tessResult.elements;
                return me._extrudeFromPolygons(vertexCount, vertices, elements, height, false, true, true, height < 0);
            }
        };

        // TODO: Contour containment check is disabled for now because it does not work with boundary with 
        // multiple paths.
        // if( this._contourContainment(boundary, contours) != 1) {
        //     Plugin.panic("The input design is not in the boundary.");
        // }

        return _EmbossTool._extrudeInBorder(boundary, contours, height);
    }
};

/** 
A useful set of functions to that allow different types of things to be created from various inputs.
@class Creation
@static
@since 1.6.0
@see Conversions
**/
var Creation = {
    /**
    Extrudes 2D geometry into a 3D mesh.
    @method extrude
    @param {Object} definition
        @param {Array[Path2D]|Sketch2D} definition.geometry A sketch or array of {Path2D}'s to extrude.
        @param {Number} definition.distance A positive or negative extrusion distance
        @param {Boolean} [definition.start=True] Indicates whether the starting face that is coincident with the original sketch should be tessellated.  
        @param {Boolean} [definition.end=True] Indicates whether the ending face at the distance specified be tessellated.
        @param {Boolean} [definition.sides=True] Indicates whether the side faces should be tessellated.
    @return {Mesh3D}
    @since 1.6.0
    **/
    extrude: function(definition) {
        var geometry = definition.geometry;
        var height = definition.distance;
        var tessStartFace = definition.start;
        var tessEndFace = definition.end;
        var tessSides = definition.sides;

        var geometryPaths, windingRule;
        if (geometry instanceof Sketch2D) {
            geometryPaths = geometry.paths;
            windingRule = geometry.windingRule;
        } else if (Array.isArray(geometry) && geometry.length > 0 && geometry[0] instanceof Path2D) {
            geometryPaths = geometry;            
        }
        if (geometryPaths === undefined) {
            Plugin.panic("The input geometry is invalid.")
        }

        var contours = _Creation._toContours(geometryPaths);
        if (contours.length === 0) {
            Plugin.panic("No valid contours found on input geometry.");
        }

        // Extract contours
        // It's used to get closed contours which separate the interior from the exterior.
        if (windingRule === undefined) { 
            windingRule = WindingRule.NonZero;
        }
        contours = _Creation._extractBoundaryContours(contours, windingRule);

        if (contours.length === 0) {
            Plugin.panic("No valid contours found on input geometry.");
        }

        // Triangulation.
        var result = _Creation._extractPolygons(contours, WindingRule.NonZero);
        var vertexCount = result.vertexCount;
        var vertices = result.vertices;
        var elements = result.elements;

        if (elements.length === 0) {
            Plugin.panic("The input geometry does not have valid profiles.");
        }

        var patch = _Creation._extrudeFromPolygons(vertexCount, vertices, elements, height, tessStartFace, tessEndFace, tessSides);
        return new Mesh3D().indexedTriangles(patch.vertices, patch.indices);
    },

    /**
    Embosses an area defined by a boundary with a specified geometry.  This algorithm does not result in a water tight mesh, the client must join
    this mesh with another mesh using {Mesh3D#combine} or {Mesh3D#combineByBoundaries} to produce a water tight mesh.  The design must reside
    within the boundary.  Typically the boundary is obtained by getting a set of coplanar triangles on a 3D mesh, then computing the {Mesh3DBoundary}
    from them and projecting it onto a {Sketch2D}.
    The input design must reside within the boundary, otherwise the result can be invalid.    
    @method emboss
    @since 1.17.0
    @param {Object} definition
        @param {Sketch2D} definition.boundary The boundary of the patch surface extents.
        @param {Sketch2D} definition.design The design that's embossed within the boundary.
        @param {Number} definition.distance A positive or negative emboss distance. Positive values result in an emboss, negative values in an engrave.
    @return {Mesh3D}
    **/
    emboss: function(definition) {
        var boundarySketch = definition.boundary;
        var design = definition.design;
        var distance = definition.distance;

        if (!(boundarySketch instanceof Sketch2D)) {
            Plugin.panic("The input boundary is not a Sketch2D object.");
        }
        var boundaries = _Creation._toContours(boundarySketch.paths);
        
        // if(boundaries.length != 1) {
        //     Plugin.panic("The input boundary is invalid.");
        // }

        if (!(design instanceof Sketch2D)) {
            Plugin.panic("The input design is not a Sketch2D object.");
        }
        var contours = _Creation._toContours(design.paths);
        if(contours.length < 1) {
            Plugin.panic("The input design is invalid.");
        }

        // Extract boundary contours of the input geomotry
        boundaries = _Creation._extractBoundaryContours(boundaries, boundarySketch.windingRule);
        contours = _Creation._extractBoundaryContours(contours, design.windingRule);

        if (contours.length === 0) {
            Plugin.panic("No valid contours found on input design.");
        }

        var surfaces = _Creation._emboss(boundaries, contours, distance);
        
        var patch = new Mesh3D();
        surfaces.forEach(function(surface) {
            patch.indexedTriangles(surface.vertices, surface.indices);
        });
        return patch;
    }
};

initializeObjectMethods(Creation, 'Creation');

Library.exports.Creation = Creation;

//conversions-svg.js
/**
Converts the 2D svg data into the paths of the Sketch2D.
@for Conversions
@method toSketch2DFromSVG
@since 1.1.0
@param {String} svgdata The string of the svg data, which is an XML string.
@return {Sketch2D} The new created Sketch2D object is returned if success. Otherwise, return undefined.
**/
Conversions.toSketch2DFromSVG = function(svgdata) {

    // This function depends on SvgParser, xml and Path2D.
    if ( !svgdata || svgdata.length < 5) {
        Debug.log("parseSVG: input string is empty (data len "+svgdata.byteLength+")");
        return;
    }

    // Trim leading white spaces before '<?xml'. Make sure to trim BOM and NBSP
    svgdata = svgdata.replace(/^[\s\uFEFF\xA0]+/g, '');
    if (svgdata.length === 0) {
        Debug.log("parseSVG: input string has only whitespace");
        return;
    }
    var head = svgdata.substr(0, 5);
    if (head !== "<?xml") {
        Debug.log("parseSVG: input string is not XML (missing header)");
        return;
    }

    var svgParser = new SvgParser();
    var svg = svgParser.buildSvg();
    var ctx = new svgParser.Context(svg, xml, Path2D);

    var ret = svg.loadXml(ctx,svgdata);
    if (!ret) {
        Plugin.panic("Failed to parse the svg data.");
    }

    if (ctx.paths.length == 0) {
        Plugin.panic("The imported SVG data seems to be empty.");
    }

    // Create the Sketch2D object.
    return new Sketch2D(ctx.paths);
};

/**
Converts text into the paths of the Sketch2D using given font svg.
@for Conversions
@method toSketch2DFromText
@since 1.1.0
@param {string} text The input string.
@param {string|Font} font The file content of a svg font, or a Font object.
@param {Number} [fontSize=25] The font size of the generated text. This parameter is used only if svg font content is passed in as the font, otherwise the size property on the font object determines the size of generated text.
@return {Sketch2D} The new created Sketch2D object is returned if success. Otherwise, return undefined.
**/
Conversions.toSketch2DFromText = function(text, font, fontSize) {

    // This function depends on Path2D and Font.
    if (!text || !font) {
        return undefined;
    }

    // Check for blank text
    if (text.replace(/^\s+|\s+$/g, '').length === 0) {
        return undefined;
    }

    if (typeof font === 'string') {
        if (fontSize && (typeof(fontSize) !== 'number' || resabs(fontSize, 0.0) || fontSize < 0.0)) {
            return undefined;
        }
        font = new Font(font, fontSize);
    }

    // Generates paths for each characters and transform them to the right position.
    var paths = [];
    var offset = 0;
    var transform = new Matrix2D().identity();
    for (var i = 0, nchars = text.length; i < nchars; i++) {
        var ch = text[i];
        var glyphPaths = font.glyphPaths(ch);
        if (offset && glyphPaths.length) {
            transform.translation(offset, 0);
            for (var j = 0, npaths = glyphPaths.length; j < npaths; j++) {
                glyphPaths[j].transform(transform);
            }
        }
        Array.prototype.push.apply(paths, glyphPaths);
        offset += font.glyphAdvance(ch);
    }

    return new Sketch2D(paths);
};

/**
Convert the paths of the Sketch2D object into svg data.
@for Conversions
@param {Sketch2D} sketch
@method toSVGFromSketch2D
@since 1.1.0
@return {String} The svg string
@proposed
**/

//conversions-stl.js
/**
Converts .STL formatted data into a mesh object.
@method toMesh3DFromSTL
@for Conversions
@since 1.1.0
@param {DataView} stldata The data for the STL file, most often obtained from resourceDataView.
@see Runtime.Library#resourceDataView
@return {Mesh3D} The new created Mesh3D object is returned.
**/
Conversions.toMesh3DFromSTL = function(stldata) {

    if (!(stldata instanceof DataView)) {
        Plugin.panic("The input STL data is not a DataView object.");
    }

    var mesh = new Mesh3D();
    if (StlParser.parseBinarySTL(stldata, mesh)) {
        return mesh;
    }

    if (StlParser.parseAsciiSTL(stldata, mesh)) {
        return mesh;
    }

    return undefined;

};

/**
Converts a mesh object to an .STL ASCII formatted stream.
@method toAsciiSTLFromMesh3D
@for Conversions
@since 1.3.0
@param {Mesh3D} mesh The Mesh3D object to be converted.
@return {String} The plain text data for the STL file.
**/
Conversions.toAsciiSTLFromMesh3D = function(mesh) {

    if (!(mesh instanceof Mesh3D)) {
        Plugin.panic("The input data is not a Mesh3D object.");
    }

    var vertices = mesh._impl._vertices;
    var indices = mesh._impl._triangles;

    var content = "";
    content += "solid ascii\n";
    var ilen = indices.length;
    for (var i = 0; i < ilen; i+=3) {
        var i0 = indices[i] * 3;
        var i1 = indices[i+1] * 3;
        var i2 = indices[i+2] * 3;
        var normal = mesh._impl._triangleNormal(indices, vertices, i);
        content += ("  facet normal " + normal[0] + " " + normal[1] + " " + normal[2] + "\n");
        content += "    outer loop\n";
        content += ("      vertex " + vertices[i0] + " " + vertices[i0 +1] + " " + vertices[i0 +2] + "\n");
        content += ("      vertex " + vertices[i1] + " " + vertices[i1 +1] + " " + vertices[i1 +2] + "\n");
        content += ("      vertex " + vertices[i2] + " " + vertices[i2 +1] + " " + vertices[i2 +2] + "\n");
        content += "    endloop\n";
        content += "  endfacet\n";
    }
    content += "endsolid\n";
    return content;
};

/**
Converts a mesh object to an .STL binary formatted stream.
@method toBinarySTLFromMesh3D
@for Conversions
@since 1.4.0
@param {Mesh3D} mesh The Mesh3D object to be converted.
@return {ArrayBuffer}
**/
Conversions.toBinarySTLFromMesh3D = function(mesh) {

    if (!(mesh instanceof Mesh3D)) {
        Plugin.panic("The input data is not a Mesh3D object.");
    }

    var vertices = mesh._impl._vertices;
    var indices = mesh._impl._triangles;

    var buffer = new ArrayBuffer(80+4+50*(indices.length/3));
    var dataView = new DataView(buffer);
    // header
    for(var i = 0; i < 80; i++){
        dataView.setInt8(i, 0);
    }

    var littleEndian = true;

    // number of triangles
    dataView.setUint32(80, indices.length/3, littleEndian);

    var byteOffset = 84, normal, x;
    var ilen = indices.length;
    for (var i = 0; i < ilen; i+=3) {
        // normal 
        normal = mesh._impl._triangleNormal(indices, vertices, i/3);
        dataView.setFloat32(byteOffset, normal[0], littleEndian);
        byteOffset+=4;
        dataView.setFloat32(byteOffset, normal[1], littleEndian);
        byteOffset+=4;
        dataView.setFloat32(byteOffset, normal[2], littleEndian);
        byteOffset+=4;

        // vertex
        for(var j = 0; j < 3; j++){
            x = indices[i+j] * 3;
            dataView.setFloat32(byteOffset, vertices[x], littleEndian);
            byteOffset+=4;
            dataView.setFloat32(byteOffset, vertices[x + 1], littleEndian);
            byteOffset+=4;
            dataView.setFloat32(byteOffset, vertices[x + 2], littleEndian);
            byteOffset+=4;
        }

        // attribute
        dataView.setUint16(byteOffset, 0, littleEndian);
        byteOffset+=2;
    }

    return buffer;
};
//conversions-base64.js
/**
Create a base-64 encoded ASCII string from ArrayBuffer.
@for Conversions
@method toBase64FromArrayBuffer
@since 1.4.0
@param {ArrayBuffer} arrayBuffer
@return {String} 
**/
Conversions.toBase64FromArrayBuffer = function(arrayBuffer) {
    // The code is browed from https://gist.github.com/jonleighton/958841
    var base64    = '';
    var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    var bytes         = new Uint8Array(arrayBuffer);
    var byteLength    = bytes.byteLength;
    var byteRemainder = byteLength % 3;
    var mainLength    = byteLength - byteRemainder;

    var a, b, c, d;
    var chunk;

    // Main loop deals with bytes in chunks of 3
    for (var i = 0; i < mainLength; i = i + 3) {
        // Combine the three bytes into a single integer
        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

        // Use bitmasks to extract 6-bit segments from the triplet
        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
        b = (chunk & 258048)   >> 12; // 258048   = (2^6 - 1) << 12
        c = (chunk & 4032)     >>  6; // 4032     = (2^6 - 1) << 6
        d = chunk & 63;               // 63       = 2^6 - 1

        // Convert the raw binary segments to the appropriate ASCII encoding
        base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
    }

    // Deal with the remaining bytes and padding
    if (byteRemainder == 1) {
        chunk = bytes[mainLength];

        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

        // Set the 4 least significant bits to zero
        b = (chunk & 3)   << 4 ;// 3   = 2^2 - 1

        base64 += encodings[a] + encodings[b] + '==';
    } else if (byteRemainder == 2) {
        chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
        b = (chunk & 1008)  >>  4; // 1008  = (2^6 - 1) << 4

        // Set the 2 least significant bits to zero
        c = (chunk & 15)    <<  2; // 15    = 2^4 - 1

        base64 += encodings[a] + encodings[b] + encodings[c] + '=';
    }

    return base64;
};

/**
Decode the base64 encoded string into ArrayBuffer.
@for Conversions
@method toArrayBufferFromBase64
@since 1.4.0
@param {string} base64 The input based64 encoded string.
@return {ArrayBuffer} 
**/
Conversions.toArrayBufferFromBase64 = function(base64) {
    // The code is borrowed from https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js
    
    var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    //get last chars to see if are valid
    var lkey1 = encodings.indexOf(base64.charAt(base64.length-1));      
    var lkey2 = encodings.indexOf(base64.charAt(base64.length-2));      

    var bytes = (base64.length/4) * 3;
    if (lkey1 == 64) bytes--; //padding chars, so skip
    if (lkey2 == 64) bytes--; //padding chars, so skip

    var arrayBuffer = new ArrayBuffer(bytes);
    var uarray = new Uint8Array(arrayBuffer);
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;
    var j = 0;

    base64 = base64.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    for (i=0; i<bytes; i+=3) {  
        //get the 3 octects in 4 ascii chars
        enc1 = encodings.indexOf(base64.charAt(j++));
        enc2 = encodings.indexOf(base64.charAt(j++));
        enc3 = encodings.indexOf(base64.charAt(j++));
        enc4 = encodings.indexOf(base64.charAt(j++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        uarray[i] = chr1;           
        if (enc3 != 64) uarray[i+1] = chr2;
        if (enc4 != 64) uarray[i+2] = chr3;
    }

    return arrayBuffer;  
}
//svgparser.js

/*
The code below are copied from //depot/labs_client/importers/svgparser.js, 
which is based on the canVG to parse the svg data.
This module depends on the xml parser. You must set it to the context. The following xml functions will be called during the sparsing progress
    var xdoc = xml.parseXml(svgString);
    var node = xdoc.root();
    node.name()
    node.childNodes()
    node.childNodes()[i]
    node.attrs()
    node.attrs()[i]
**************************************************************************/

var SvgParser = function(){
    // ---- rgbcolor.js ----
    /*
     * @author Stoyan Stefanov <sstoo@gmail.com>
     * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
     * @license Use it if you like it
     */

    function RGBColor(color_string)
    {
        this.ok = false;

        // strip any leading #
        if (color_string.charAt(0) == '#') { // remove # if any
            color_string = color_string.substr(1,6);
        }

        color_string = color_string.replace(/ /g,'');
        color_string = color_string.toLowerCase();

        // before getting into regexps, try simple matches
        // and overwrite the input
        var simple_colors = {
            aliceblue: 'f0f8ff',
            antiquewhite: 'faebd7',
            aqua: '00ffff',
            aquamarine: '7fffd4',
            azure: 'f0ffff',
            beige: 'f5f5dc',
            bisque: 'ffe4c4',
            black: '000000',
            blanchedalmond: 'ffebcd',
            blue: '0000ff',
            blueviolet: '8a2be2',
            brown: 'a52a2a',
            burlywood: 'deb887',
            cadetblue: '5f9ea0',
            chartreuse: '7fff00',
            chocolate: 'd2691e',
            coral: 'ff7f50',
            cornflowerblue: '6495ed',
            cornsilk: 'fff8dc',
            crimson: 'dc143c',
            cyan: '00ffff',
            darkblue: '00008b',
            darkcyan: '008b8b',
            darkgoldenrod: 'b8860b',
            darkgray: 'a9a9a9',
            darkgreen: '006400',
            darkkhaki: 'bdb76b',
            darkmagenta: '8b008b',
            darkolivegreen: '556b2f',
            darkorange: 'ff8c00',
            darkorchid: '9932cc',
            darkred: '8b0000',
            darksalmon: 'e9967a',
            darkseagreen: '8fbc8f',
            darkslateblue: '483d8b',
            darkslategray: '2f4f4f',
            darkturquoise: '00ced1',
            darkviolet: '9400d3',
            deeppink: 'ff1493',
            deepskyblue: '00bfff',
            dimgray: '696969',
            dodgerblue: '1e90ff',
            feldspar: 'd19275',
            firebrick: 'b22222',
            floralwhite: 'fffaf0',
            forestgreen: '228b22',
            fuchsia: 'ff00ff',
            gainsboro: 'dcdcdc',
            ghostwhite: 'f8f8ff',
            gold: 'ffd700',
            goldenrod: 'daa520',
            gray: '808080',
            green: '008000',
            greenyellow: 'adff2f',
            honeydew: 'f0fff0',
            hotpink: 'ff69b4',
            indianred : 'cd5c5c',
            indigo : '4b0082',
            ivory: 'fffff0',
            khaki: 'f0e68c',
            lavender: 'e6e6fa',
            lavenderblush: 'fff0f5',
            lawngreen: '7cfc00',
            lemonchiffon: 'fffacd',
            lightblue: 'add8e6',
            lightcoral: 'f08080',
            lightcyan: 'e0ffff',
            lightgoldenrodyellow: 'fafad2',
            lightgrey: 'd3d3d3',
            lightgreen: '90ee90',
            lightpink: 'ffb6c1',
            lightsalmon: 'ffa07a',
            lightseagreen: '20b2aa',
            lightskyblue: '87cefa',
            lightslateblue: '8470ff',
            lightslategray: '778899',
            lightsteelblue: 'b0c4de',
            lightyellow: 'ffffe0',
            lime: '00ff00',
            limegreen: '32cd32',
            linen: 'faf0e6',
            magenta: 'ff00ff',
            maroon: '800000',
            mediumaquamarine: '66cdaa',
            mediumblue: '0000cd',
            mediumorchid: 'ba55d3',
            mediumpurple: '9370d8',
            mediumseagreen: '3cb371',
            mediumslateblue: '7b68ee',
            mediumspringgreen: '00fa9a',
            mediumturquoise: '48d1cc',
            mediumvioletred: 'c71585',
            midnightblue: '191970',
            mintcream: 'f5fffa',
            mistyrose: 'ffe4e1',
            moccasin: 'ffe4b5',
            navajowhite: 'ffdead',
            navy: '000080',
            oldlace: 'fdf5e6',
            olive: '808000',
            olivedrab: '6b8e23',
            orange: 'ffa500',
            orangered: 'ff4500',
            orchid: 'da70d6',
            palegoldenrod: 'eee8aa',
            palegreen: '98fb98',
            paleturquoise: 'afeeee',
            palevioletred: 'd87093',
            papayawhip: 'ffefd5',
            peachpuff: 'ffdab9',
            peru: 'cd853f',
            pink: 'ffc0cb',
            plum: 'dda0dd',
            powderblue: 'b0e0e6',
            purple: '800080',
            red: 'ff0000',
            rosybrown: 'bc8f8f',
            royalblue: '4169e1',
            saddlebrown: '8b4513',
            salmon: 'fa8072',
            sandybrown: 'f4a460',
            seagreen: '2e8b57',
            seashell: 'fff5ee',
            sienna: 'a0522d',
            silver: 'c0c0c0',
            skyblue: '87ceeb',
            slateblue: '6a5acd',
            slategray: '708090',
            snow: 'fffafa',
            springgreen: '00ff7f',
            steelblue: '4682b4',
            tan: 'd2b48c',
            teal: '008080',
            thistle: 'd8bfd8',
            tomato: 'ff6347',
            turquoise: '40e0d0',
            violet: 'ee82ee',
            violetred: 'd02090',
            wheat: 'f5deb3',
            white: 'ffffff',
            whitesmoke: 'f5f5f5',
            yellow: 'ffff00',
            yellowgreen: '9acd32'
        };
        for (var key in simple_colors) {
            if (color_string == key) {
                color_string = simple_colors[key];
            }
        }
        // emd of simple type-in colors

        // array of color definition objects
        var color_defs = [
            {
                re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
                process: function (bits){
                    return [
                        parseInt(bits[1]),
                        parseInt(bits[2]),
                        parseInt(bits[3])
                    ];
                }
            },
            {
                re: /^(\w{2})(\w{2})(\w{2})$/,
                example: ['#00ff00', '336699'],
                process: function (bits){
                    return [
                        parseInt(bits[1], 16),
                        parseInt(bits[2], 16),
                        parseInt(bits[3], 16)
                    ];
                }
            },
            {
                re: /^(\w{1})(\w{1})(\w{1})$/,
                example: ['#fb0', 'f0f'],
                process: function (bits){
                    return [
                        parseInt(bits[1] + bits[1], 16),
                        parseInt(bits[2] + bits[2], 16),
                        parseInt(bits[3] + bits[3], 16)
                    ];
                }
            }
        ];

        // search through the definitions to find a match
        for (var i = 0; i < color_defs.length; i++) {
            var re = color_defs[i].re;
            var processor = color_defs[i].process;
            var bits = re.exec(color_string);
            if (bits) {
                var channels = processor(bits);
                this.r = channels[0];
                this.g = channels[1];
                this.b = channels[2];
                this.ok = true;
            }

        }

        // validate/cleanup values
        this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
        this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
        this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

        // some getters
        this.toRGB = function () {
            return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
        }
        this.toHex = function () {
            var r = this.r.toString(16);
            var g = this.g.toString(16);
            var b = this.b.toString(16);
            if (r.length == 1) r = '0' + r;
            if (g.length == 1) g = '0' + g;
            if (b.length == 1) b = '0' + b;
            return '#' + r + g + b;
        }

        // help
        this.getHelpXML = function () {

            var examples = new Array();
            // add regexps
            for (var i = 0; i < color_defs.length; i++) {
                var example = color_defs[i].example;
                for (var j = 0; j < example.length; j++) {
                    examples[examples.length] = example[j];
                }
            }
            // add type-in colors
            for (var sc in simple_colors) {
                examples[examples.length] = sc;
            }

            var xml = document.createElement('ul');
            xml.setAttribute('id', 'rgbcolor-examples');
            for (var i = 0; i < examples.length; i++) {
                try {
                    var list_item = document.createElement('li');
                    var list_color = new RGBColor(examples[i]);
                    var example_div = document.createElement('div');
                    example_div.style.cssText =
                            'margin: 3px; '
                            + 'border: 1px solid black; '
                            + 'background:' + list_color.toHex() + '; '
                            + 'color:' + list_color.toHex()
                    ;
                    example_div.appendChild(document.createTextNode('test'));
                    var list_item_value = document.createTextNode(
                        ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                    );
                    list_item.appendChild(example_div);
                    list_item.appendChild(list_item_value);
                    xml.appendChild(list_item);

                } catch(e){}
            }
            return xml;

        }

    }



    /*
     * mat3 - 3x3 Matrix
     */
    var mat3 = {};

    mat3.create = function(mat) {
            var dest = new Array(9);        
            if(mat) {
                    dest[0] = mat[0];
                    dest[1] = mat[1];
                    dest[2] = mat[2];
                    dest[3] = mat[3];
                    dest[4] = mat[4];
                    dest[5] = mat[5];
                    dest[6] = mat[6];
                    dest[7] = mat[7];
                    dest[8] = mat[8];
            }
            return dest;
    };

    mat3.set = function(dest, mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
            return dest;
    };

    mat3.identity = function(dest) {
            dest[0] = 1;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            dest[4] = 1;
            dest[5] = 0;
            dest[6] = 0;
            dest[7] = 0;
            dest[8] = 1;
            return dest;
    };

    mat3.transpose = function(dest, mat) {
            // If we are transposing ourselves we can skip a few steps but have to cache some values
            if(mat == dest) { 
                    var a01 = mat[1], a02 = mat[2], a12 = mat[5];
                    mat[1] = mat[3];
                    mat[2] = mat[6];
                    mat[3] = a01;
                    mat[5] = mat[7];
                    mat[6] = a02;
                    mat[7] = a12;
                    return mat;
            }        
            dest[0] = mat[0];
            dest[1] = mat[3];
            dest[2] = mat[6];
            dest[3] = mat[1];
            dest[4] = mat[4];
            dest[5] = mat[7];
            dest[6] = mat[2];
            dest[7] = mat[5];
            dest[8] = mat[8];
            return dest;
    };

    mat3.multiply = function (dest, mat, mat2) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[3], a11 = mat[4], a12 = mat[5],
            a20 = mat[6], a21 = mat[7], a22 = mat[8],

            b00 = mat2[0], b01 = mat2[1], b02 = mat2[2],
            b10 = mat2[3], b11 = mat2[4], b12 = mat2[5],
            b20 = mat2[6], b21 = mat2[7], b22 = mat2[8];

        dest[0] = b00 * a00 + b01 * a10 + b02 * a20;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22;
        dest[3] = b10 * a00 + b11 * a10 + b12 * a20;
        dest[4] = b10 * a01 + b11 * a11 + b12 * a21;
        dest[5] = b10 * a02 + b11 * a12 + b12 * a22;
        dest[6] = b20 * a00 + b21 * a10 + b22 * a20;
        dest[7] = b20 * a01 + b21 * a11 + b22 * a21;
        dest[8] = b20 * a02 + b21 * a12 + b22 * a22;

        return dest;
    };

    mat3.transformPoint = function(dest, mat, vec) {
            var x = vec[0], y = vec[1];
            dest[0] = mat[0]*x + mat[3]*y + mat[6];
            dest[1] = mat[1]*x + mat[4]*y + mat[7];
            return dest;
    };





    // ---- SVG parser (based on CanVG) ----



    function Context(svg, xmlParser, Path2D) {
        this.xmlParser = xmlParser;
        this.Path2D = Path2D;
        this.paths = [];
        this.transformStack = [];
        this.styleStack = [];
        this.transformation = mat3.create();
        this.bbox = new svg.BoundingBox();
        this.lastPt = [0,0];

        mat3.identity(this.transformation);

        // Set context state to default values, see
        // http://www.w3.org/TR/2dcontext for more information
        this.setDefaults = function() {
            this.strokeStyle    = '#000000';
            this.fillStyle      = '#000000';
            this.globalAlpha    = 1.0;
            this.lineWidth      = 1.0;
            this.lineCap        = 'butt';
            this.lineJoin       = 'miter';
            this.miterLimit     = 10.0;
            this.shadowOffsetX  = 0;
            this.shadowOffsetY  = 0;
            this.shadowBlur     = 0; 
            this.shadowColor    = 'rgba(0,0,0,0)';
            this.globalCompositeOperation = 'source-over'; 
            this.font           = '10px sans-serif';
            this.textAlign      = 'start';
            this.textBaseline   = 'alphabetic';
        }
        this.setDefaults();

        this.getStyleObj = function() {
            var style = {};
            style.strokeStyle   = this.strokeStyle;
            style.fillStyle     = this.fillStyle;
            style.globalAlpha   = this.globalAlpha;
            style.lineWidth     = this.lineWidth;
            style.lineCap       = this.lineCap;
            style.lineJoin      = this.lineJoin;
            style.miterLimit    = this.miterLimit; 
            style.shadowOffsetX = this.shadowOffsetX; 
            style.shadowOffsetY = this.shadowOffsetY;
            style.shadowBlur    = this.shadowBlur;
            style.shadowColor   = this.shadowColor;
            style.globalCompositeOperation = this.globalCompositeOperation;
            style.font          = this.font;
            style.textAlign     = this.textAlign;
            style.textBaseline  = this.textBaseline;
            return style;           
        } 

        this.curPath = function() {
            return this.paths[this.paths.length-1];
        }

        // void save();
        this.save = function(x,y) {
            var copy = mat3.create();
            mat3.set(copy, this.transformation);
            this.transformStack.push(copy);
            var style = this.getStyleObj(); 
            this.styleStack.push(style);
        }

        // void restore();
        this.restore = function(x,y) {
            this.transformation = this.transformStack.pop();
            var t = this.transformation;
            var style = this.styleStack.pop();
        }       

        // void beginPath();
        this.beginPath = function () {
            this.paths.push(new this.Path2D);
        } 

            // void closePath();
        this.closePath = function () {
            //log("closePath");
            var curPath = this.curPath();
            curPath.close();
        } 

        this.clip = function () {
            Debug.log('! clip not implemented');
        }

        this.stroke = function() {
            //log("stroke");
        }

        this.fill = function() {
            //log("fill");
        }

        // void moveTo(double x, double y);
        this.moveTo = function(x,y) {
            var v = [x,y];
            mat3.transformPoint(v, this.transformation, v);
            var curPath = this.curPath();
            curPath.moveTo(v[0],-v[1]);

            this.bbox.addPoint(v[0],-v[1]);
            this.lastPt[0] = v[0];
            this.lastPt[1] = -v[1];
        }

        // void lineTo(double x, double y);
        this.lineTo = function(x,y) {
            var v = [x,y];
            mat3.transformPoint(v, this.transformation, v);
            var curPath = this.curPath();
            curPath.lineTo(v[0],-v[1]);

            this.bbox.addPoint(v[0],-v[1]);
            this.lastPt[0] = v[0];
            this.lastPt[1] = -v[1];
        }

        // void quadraticCurveTo(double cpx, double cpy, double x, double y);
        this.quadraticCurveTo = function(cpx, cpy, x, y) {
            var v = [x,y];
            mat3.transformPoint(v, this.transformation, v);
            var cv = [cpx, cpy];
            mat3.transformPoint(cv, this.transformation, cv);
            var curPath = this.curPath();
            curPath.quadraticCurveTo(cv[0], -cv[1], v[0], -v[1]);

            this.bbox.addQuadraticCurve(this.lastPt[0], this.lastPt[1], cv[0], -cv[1], v[0], -v[1]);
            this.lastPt[0] = v[0];
            this.lastPt[1] = -v[1];
        }

        // void bezierCurveTo(double cp1x, double cp1y, double cp2x, double cp2y, double x, double y);
        this.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
            var v = [x,y];
            mat3.transformPoint(v, this.transformation, v);
            var cv1 = [cp1x, cp1y];
            mat3.transformPoint(cv1, this.transformation, cv1);
            var cv2 = [cp2x, cp2y];
            mat3.transformPoint(cv2, this.transformation, cv2);
            var curPath = this.curPath();
            curPath.bezierCurveTo(cv1[0], -cv1[1], cv2[0], -cv2[1], v[0], -v[1]);

            this.bbox.addBezierCurve(this.lastPt[0], this.lastPt[1], cv1[0], -cv1[1], cv2[0], -cv2[1], v[0], -v[1]);
            this.lastPt[0] = v[0];
            this.lastPt[1] = -v[1];
        }
            
        // void rotate(double angle);
        this.rotate = function(angle) {
            var mat = mat3.create([  Math.cos(angle), Math.sin(angle),  0, 
                                    -Math.sin(angle), Math.cos(angle),  0,
                                                    0,                  0,  1 ]);
            mat3.multiply(this.transformation, this.transformation, mat);
        }

        // scale(double x, double y); 
        this.scale = function(x, y) {
            //log('scale ('+x+', '+y+')');
            var mat = mat3.create([x,0,0,0,y,0,0,0,1]);
            mat3.multiply(this.transformation, this.transformation, mat);
        }

            // void setTransform(double a, double b, double c, double d, double e, double f);
        this.setTransform = function(a, b, c, d, e, f) {
            //log('setTransform ('+a+', '+b+', '+c+', '+d+', '+e+', '+f+')');
            var mat = mat3.create([a,c,e,b,d,f,0,0,1]); // test this?
            mat3.transpose(mat, mat);
            this.transformation = mat;
        }

        // void translate(double x, double y);
        this.translate = function(x, y) {
            var mat = mat3.create([1, 0, 0, 0, 1, 0, x, y, 1]);
            mat3.multiply(this.transformation, this.transformation, mat);
        }

        // void transform(double a, double b, double c, double d, double e, double f);
        this.transform = function(a, b, c, d, e, f) {
            var mat = mat3.create([a, b, 0, c, d, 0, e, f, 1]);
            mat3.multiply(this.transformation, this.transformation, mat);
        }
     
        //  void arc(double x, double y, double radius, double startAngle, double endAngle, optional boolean anticlockwise); 
        this.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
            function sq(a) { return a*a; }
            // Approximate elliptical arc with bezier curves, 
            // see http://www.spaceroots.org/documents/ellipse/index.html   
            var n_curves = Math.ceil(Math.abs(endAngle-startAngle)/Math.PI*4);
            for (var i = 0; i<n_curves; i++) {
                var rx = radius;
                var ry = radius;

                var n1 = startAngle + i*(endAngle-startAngle)/n_curves;
                var n2 = startAngle + (i+1)*(endAngle-startAngle)/n_curves;
                
                var ALPHA = Math.sin(n2-n1)*(Math.sqrt(4+3*sq(Math.tan((n2-n1)/2)))-1)/3;

                // P1 = E(n1)
                // P2 = E(n2)
                // C1 = P1 + aE'(n1)
                // C2 = P2 + aE'(n2)
                var th = 0; // ellipse angle
                var cth = Math.cos(th);
                var sth = Math.sin(th);
                
                var p1x = x + rx*cth*Math.cos(n1) - ry*sth*Math.sin(n1); 
                var p1y = y + rx*sth*Math.cos(n1) + ry*cth*Math.sin(n1);
                var p2x = x + rx*cth*Math.cos(n2) - ry*sth*Math.sin(n2); 
                var p2y = y + rx*sth*Math.cos(n2) + ry*cth*Math.sin(n2);
                var c1x = p1x + ALPHA*(-rx*cth*Math.sin(n1) - ry*sth*Math.cos(n1)); 
                var c1y = p1y + ALPHA*(-rx*sth*Math.sin(n1) + ry*cth*Math.cos(n1));
                var c2x = p2x - ALPHA*(-rx*cth*Math.sin(n2) - ry*sth*Math.cos(n2)); 
                var c2y = p2y - ALPHA*(-rx*sth*Math.sin(n2) + ry*cth*Math.cos(n2));

                            this.bezierCurveTo(c1x, c1y, c2x, c2y, p2x, p2y);
            }
        } 
    }


    function buildSvg() {
        var svg = { };

        svg.opts = {};
        
        svg.FRAMERATE = 30;
        svg.MAX_VIRTUAL_PIXELS = 30000;
        
        // globals
        svg.init = function(ctx) {
            svg.Definitions = {};
            svg.Styles = {};
            svg.Animations = [];
            svg.Images = [];
            svg.ctx = ctx;
            svg.ViewPort = new (function () {
                this.viewPorts = [];
                this.Clear = function() { this.viewPorts = []; }
                this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
                this.RemoveCurrent = function() { this.viewPorts.pop(); }
                this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
                this.width = function() { return this.Current().width; }
                this.height = function() { return this.Current().height; }
                this.ComputeSize = function(d) {
                    if (d != null && typeof(d) == 'number') return d;
                    if (d == 'x') return this.width();
                    if (d == 'y') return this.height();
                    return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);            
                }
            });
        }
        svg.init();
        
        // trim
        svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }
        
        // compress spaces
        svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }
        
        // ajax
        /*
        svg.ajax = function(url) {
            var AJAX;
            if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
            else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
            if(AJAX){
               AJAX.open('GET',url,false);
               AJAX.send(null);
               return AJAX.responseText;
            }
            return null;
        } 
        
        
        // parse xml
        svg.parseXml = function(xmlString) {    
            var xmlDoc = xml.parseXml(xmlString);
            return xmlDoc;  
        }
        */

        svg.Property = function(name, value) {
            this.name = name;
            this.value = value;

            this.hasValue = function() {
                return (this.value != null && this.value !== '');
            }
                            
            // return the numerical value of the property
            this.numValue = function() {
                if (!this.hasValue()) return 0;
                
                var n = parseFloat(this.value);
                if ((this.value + '').match(/%$/)) {
                    n = n / 100.0;
                }
                return n;
            }
            
            this.valueOrDefault = function(def) {
                if (this.hasValue()) return this.value;
                return def;
            }
            
            this.numValueOrDefault = function(def) {
                if (this.hasValue()) return this.numValue();
                return def;
            }
            
            /* EXTENSIONS */
            var that = this;
            
            // color extensions
            this.Color = {
                // augment the current color value with the opacity
                addOpacity: function(opacity) {
                    var newValue = that.value;
                    if (opacity != null && opacity != '') {
                        var color = new RGBColor(that.value);
                        if (color.ok) {
                            newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacity + ')';
                        }
                    }
                    return new svg.Property(that.name, newValue);
                }
            }
            
            // definition extensions
            this.Definition = {
                // get the definition from the definitions table
                getDefinition: function() {
                    var name = that.value.replace(/^(url\()?#([^\)]+)\)?$/, '$2');
                    return svg.Definitions[name];
                },
                
                isUrl: function() {
                    return that.value.indexOf('url(') == 0
                },
                
                getFillStyle: function(e) {
                    var def = this.getDefinition();
                    
    /*                  // gradient
                    if (def != null && def.createGradient) {
                        return def.createGradient(svg.ctx, e);
                    }
                    
                    // pattern
                    if (def != null && def.createPattern) {
                        return def.createPattern(svg.ctx, e);
                    }*/
                    
                    return null;
                }
            }
            
            // length extensions
            this.Length = {
                DPI: function(viewPort) {
                    return 96.0; // TODO: compute?
                },
                
                EM: function(viewPort) {
                    var em = 12;
                    
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    if (fontSize.hasValue()) em = fontSize.Length.toPixels(viewPort);
                    
                    return em;
                },
            
                // get the length as pixels
                toPixels: function(viewPort) {
                    if (!that.hasValue()) return 0;
                    var s = that.value+'';
                    if (s.match(/em$/)) return that.numValue() * this.EM(viewPort);
                    if (s.match(/ex$/)) return that.numValue() * this.EM(viewPort) / 2.0;
                    if (s.match(/px$/)) return that.numValue();
                    if (s.match(/pt$/)) return that.numValue() * 1.25;
                    if (s.match(/pc$/)) return that.numValue() * 15;
                    if (s.match(/cm$/)) return that.numValue() * this.DPI(viewPort) / 2.54;
                    if (s.match(/mm$/)) return that.numValue() * this.DPI(viewPort) / 25.4;
                    if (s.match(/in$/)) return that.numValue() * this.DPI(viewPort);
                    if (s.match(/%$/)) return that.numValue() * svg.ViewPort.ComputeSize(viewPort);
                    return that.numValue();
                }
            }
            
            // time extensions
            this.Time = {
                // get the time as milliseconds
                toMilliseconds: function() {
                    if (!that.hasValue()) return 0;
                    var s = that.value+'';
                    if (s.match(/s$/)) return that.numValue() * 1000;
                    if (s.match(/ms$/)) return that.numValue();
                    return that.numValue();
                }
            }
            
            // angle extensions
            this.Angle = {
                // get the angle as radians
                toRadians: function() {
                    if (!that.hasValue()) return 0;
                    var s = that.value+'';
                    if (s.match(/deg$/)) return that.numValue() * (Math.PI / 180.0);
                    if (s.match(/grad$/)) return that.numValue() * (Math.PI / 200.0);
                    if (s.match(/rad$/)) return that.numValue();
                    return that.numValue() * (Math.PI / 180.0);
                }
            }
        }
        
        // fonts
        svg.Font = new (function() {
            this.Styles = ['normal','italic','oblique','inherit'];
            this.Variants = ['normal','small-caps','inherit'];
            this.Weights = ['normal','bold','bolder','lighter','100','200','300','400','500','600','700','800','900','inherit'];
            
            this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) { 
                var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
                return { 
                    fontFamily: fontFamily || f.fontFamily, 
                    fontSize: fontSize || f.fontSize, 
                    fontStyle: fontStyle || f.fontStyle, 
                    fontWeight: fontWeight || f.fontWeight, 
                    fontVariant: fontVariant || f.fontVariant,
                    toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') } 
                } 
            }
            
            var that = this;
            this.Parse = function(s) {
                var f = {};
                var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
                var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
                var ff = '';
                for (var i=0; i<d.length; i++) {
                    if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
                    else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;  }
                    else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
                    else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
                    else { if (d[i] != 'inherit') ff += d[i]; }
                } if (ff != '') f.fontFamily = ff;
                return f;
            }
        });
        
        // points and paths
        svg.ToNumberArray = function(s) {
            var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
            for (var i=0; i<a.length; i++) {
                a[i] = parseFloat(a[i]);
            }
            return a;
        }       
        svg.Point = function(x, y) {
            this.x = x;
            this.y = y;
            
            this.angleTo = function(p) {
                return Math.atan2(p.y - this.y, p.x - this.x);
            }
            
            this.applyTransform = function(v) {
                var xp = this.x * v[0] + this.y * v[2] + v[4];
                var yp = this.x * v[1] + this.y * v[3] + v[5];
                this.x = xp;
                this.y = yp;
            }
        }
        svg.CreatePoint = function(s) {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1]);
        }
        svg.CreatePath = function(s) {
            var a = svg.ToNumberArray(s);
            var path = [];
            for (var i=0; i<a.length; i+=2) {
                path.push(new svg.Point(a[i], a[i+1]));
            }
            return path;
        }
        
        // bounding box
        svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;
            
            this.x = function() { return this.x1; }
            this.y = function() { return this.y1; }
            this.width = function() { return this.x2 - this.x1; }
            this.height = function() { return this.y2 - this.y1; }
            
            this.addPoint = function(x, y) {    
                if (x != null) {
                    if (isNaN(this.x1) || isNaN(this.x2)) {
                        this.x1 = x;
                        this.x2 = x;
                    }
                    if (x < this.x1) this.x1 = x;
                    if (x > this.x2) this.x2 = x;
                }
            
                if (y != null) {
                    if (isNaN(this.y1) || isNaN(this.y2)) {
                        this.y1 = y;
                        this.y2 = y;
                    }
                    if (y < this.y1) this.y1 = y;
                    if (y > this.y2) this.y2 = y;
                }
            }           
            this.addX = function(x) { this.addPoint(x, null); }
            this.addY = function(y) { this.addPoint(null, y); }
            
            this.addBoundingBox = function(bb) {
                this.addPoint(bb.x1, bb.y1);
                this.addPoint(bb.x2, bb.y2);
            }
            
            this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
                var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
                var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
            }
            
            this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
                var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
                this.addPoint(p0[0], p0[1]);
                this.addPoint(p3[0], p3[1]);
                
                for (var i=0; i<=1; i++) {
                    var f = function(t) { 
                        return Math.pow(1-t, 3) * p0[i]
                        + 3 * Math.pow(1-t, 2) * t * p1[i]
                        + 3 * (1-t) * Math.pow(t, 2) * p2[i]
                        + Math.pow(t, 3) * p3[i];
                    }
                    
                    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    var c = 3 * p1[i] - 3 * p0[i];
                    
                    if (a == 0) {
                        if (b == 0) continue;
                        var t = -c / b;
                        if (0 < t && t < 1) {
                            if (i == 0) this.addX(f(t));
                            if (i == 1) this.addY(f(t));
                        }
                        continue;
                    }
                    
                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0) continue;
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                        if (i == 0) this.addX(f(t1));
                        if (i == 1) this.addY(f(t1));
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                        if (i == 0) this.addX(f(t2));
                        if (i == 1) this.addY(f(t2));
                    }
                }
            }
            
            this.isPointInBox = function(x, y) {
                return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
            }
            
            this.addPoint(x1, y1);
            this.addPoint(x2, y2);
        }
        
        // transforms
        svg.Transform = function(v) {   
            var that = this;
            this.Type = {}
        
            // translate
            this.Type.translate = function(s) {
                this.p = svg.CreatePoint(s);            
                this.apply = function(ctx) {
                    ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                }
            }
            
            // rotate
            this.Type.rotate = function(s) {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property('angle', a[0]);
                this.cx = a[1] || 0;
                this.cy = a[2] || 0;
                this.apply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(this.angle.Angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.applyToPoint = function(p) {
                    var a = this.angle.Angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                    p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
                }           
            }
            
            this.Type.scale = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
                }               
            }
            
            this.Type.matrix = function(s) {
                this.m = svg.ToNumberArray(s);
                this.apply = function(ctx) {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform(this.m);
                }                   
            }
            
            this.Type.SkewBase = function(s) {
                this.base = that.Type.matrix;
                this.base(s);
                this.angle = new svg.Property('angle', s);
            }
            this.Type.SkewBase.prototype = new this.Type.matrix;
            
            this.Type.skewX = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, 0, Math.tan(this.angle.Angle.toRadians()), 1, 0, 0];
            }
            this.Type.skewX.prototype = new this.Type.SkewBase;
            
            this.Type.skewY = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, Math.tan(this.angle.Angle.toRadians()), 0, 1, 0, 0];
            }
            this.Type.skewY.prototype = new this.Type.SkewBase;
        
            this.transforms = [];
            
            this.apply = function(ctx) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].apply(ctx);
                }
            }
            
            this.applyToPoint = function(p) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].applyToPoint(p);
                }
            }
            
            var data = svg.trim(svg.compressSpaces(v)).split(/\s(?=[a-z])/);
            for (var i=0; i<data.length; i++) {
                var type = data[i].split('(')[0];
                var s = data[i].split('(')[1].replace(')','');
                var transform = new this.Type[type](s);
                this.transforms.push(transform);
            }
        }
        
        // aspect ratio
        svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
            // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
            aspectRatio = svg.compressSpaces(aspectRatio);
            aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
            var align = aspectRatio.split(' ')[0] || 'xMidYMid';
            var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';                  

            // calculate scale
            var scaleX = width / desiredWidth;
            var scaleY = height / desiredHeight;
            var scaleMin = Math.min(scaleX, scaleY);
            var scaleMax = Math.max(scaleX, scaleY);
            if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
            if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }    
            
            refX = new svg.Property('refX', refX);
            refY = new svg.Property('refY', refY);
            if (refX.hasValue() && refY.hasValue()) {               
                ctx.translate(-scaleMin * refX.Length.toPixels('x'), -scaleMin * refY.Length.toPixels('y'));
            } 
            else {                  
                // align
                if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0); 
                if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0); 
                if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0); 
                if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight); 
            }
            
            // scale
            if (align == 'none') ctx.scale(scaleX, scaleY);
            else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin); 
            else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);     
            
            // translate
            ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);          
        }
        
        // elements
        svg.Element = {}
        
        svg.Element.ElementBase = function(node) {  
            this.attributes = {};
            this.styles = {};
            this.children = [];
            
            // get or create attribute
            this.attribute = function(name, createIfNotExists) {
                var a = this.attributes[name];
                if (a != null) return a;
                            
                a = new svg.Property(name, '');
                if (createIfNotExists === true) this.attributes[name] = a;
                return a;
            }
            
            // get or create style, crawls up node tree
            this.style = function(name, createIfNotExists) {
                var s = this.styles[name];
                if (s != null) return s;
                
                var a = this.attribute(name);
                if (a != null && a.hasValue()) {
                    return a;
                }
                
                var p = this.parent;
                if (p != null) {
                    var ps = p.style(name);
                    if (ps != null && ps.hasValue()) {
                        return ps;
                    }
                }
                    
                s = new svg.Property(name, '');
                if (createIfNotExists === true) this.styles[name] = s;
                return s;
            }
            
            // base render
            this.render = function(ctx) {

                // don't render display=none
                if (this.style('display').value == 'none') return;
                
                // don't render visibility=hidden
                if (this.attribute('visibility').value == 'hidden') return;

                            // don't render if hidden
                            if (this.style('fill-opacity').numValueOrDefault(1) == 0.0 ||
                                this.style('stroke-opacity').numValueOrDefault(1) == 0.0) return;

                ctx.save();
                    this.setContext(ctx);
                        // mask
                        if (this.attribute('mask').hasValue()) {
                            var mask = this.attribute('mask').Definition.getDefinition();
                            if (mask != null) mask.apply(ctx, this);
                        }
                        else if (this.style('filter').hasValue()) {
                            var filter = this.style('filter').Definition.getDefinition();
                            if (filter != null) filter.apply(ctx, this);
                        }
                        else this.renderChildren(ctx);              
                    this.clearContext(ctx);
                ctx.restore();
            }
            
            // base set context
            this.setContext = function(ctx) {
                // OVERRIDE ME!
            }
            
            // base clear context
            this.clearContext = function(ctx) {
                // OVERRIDE ME!
            }           
            
            // base render children
            this.renderChildren = function(ctx) {
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].render(ctx);
                }
            }
            
            this.addChild = function(childNode, create) {
                var child = childNode;
                if (create) child = svg.CreateElement(childNode);
                child.parent = this;
                this.children.push(child);          
            }

            this.getBoundingBox = function() {
                var bb = new svg.BoundingBox();
                for (var i=0; i<this.children.length; i++) {
                    bb.addBoundingBox(this.children[i].getBoundingBox());
                }
                return bb;
            };

            //debugger
            if (node && node.type() == 'element') { //ELEMENT_NODE
                var nodeName = node.name();  // node.nodeName

                //log("... processing node "+nodeName+", children "+node.childNodes().length+", attrs "+node.attrs().length);

                // add children
                var childNodes = node.childNodes();
                for (var i=0, len=childNodes.length; i<len; i++) {
                    var childNode = childNodes[i];

                    //ELEMENT_NODE
                    if( childNode.type() == 'element') {
                         this.addChild(childNode, true); 
                    }

                    // TEXT_NODE
                    if (node.name() == 'text' && childNode.type() == 'text' ) { 
                        var txt = childNode.text() || childNode.nodeValue || childNode.text || '';
                        if (txt && svg.trim(svg.compressSpaces(txt)) != '') {
                            this.addChild(new svg.Element.tspan(childNode), false); 
                        }
                    }
                }
                
                // add attributes
                var attrs = node.attrs();  // node.attributes in original
                for (var i=0; i<attrs.length; i++) {
                    var attribute = attrs[i];
                    var attrName = attribute.name();  // attribute.nodeName
                    var attrValue = attribute.value();
                    //log("  attribute "+i+", name "+attrName+", value "+attrValue+", original: "+attribute)
                    //log("  attribute "+i+", name "+attrName);
                    
                    this.attributes[attrName] = new svg.Property(attrName, attrValue);
                }
                                        
                // add tag styles
                var styles = svg.Styles[nodeName];
                if (styles != null) {
                    for (var name in styles) {
                        this.styles[name] = styles[name];
                    }
                }                   
                
                // add class styles
                if (this.attribute('class').hasValue()) {
                    var classes = svg.compressSpaces(this.attribute('class').value).split(' ');
                    for (var j=0; j<classes.length; j++) {
                        styles = svg.Styles['.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                        styles = svg.Styles[nodeName+'.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                    }
                }
                
                // add inline styles
                if (this.attribute('style').hasValue()) {
                    var styles = this.attribute('style').value.split(';');
                    for (var i=0; i<styles.length; i++) {
                        if (svg.trim(styles[i]) != '') {
                            var style = styles[i].split(':');
                            var name = svg.trim(style[0]);
                            var value = svg.trim(style[1]);
                            this.styles[name] = new svg.Property(name, value);
                        }
                    }
                }   

                // add id
                if (this.attribute('id').hasValue()) {
                    if (svg.Definitions[this.attribute('id').value] == null) {
                        svg.Definitions[this.attribute('id').value] = this;
                    }
                }
            }
        }
        
        svg.Element.RenderedElementBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.setContext = function(ctx) {
                // fill
                if (this.style('fill').Definition.isUrl()) {
                    var fs = this.style('fill').Definition.getFillStyle(this);
                    if (fs != null) ctx.fillStyle = fs;
                }
                else if (this.style('fill').hasValue()) {
                    var fillStyle = this.style('fill');
                                    if (this.style('fill-opacity').hasValue()) fillStyle = fillStyle.Color.addOpacity(this.style('fill-opacity').value);
                                    ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
                }
                                    
                // stroke
                if (this.style('stroke').Definition.isUrl()) {
                    var fs = this.style('stroke').Definition.getFillStyle(this);
                    if (fs != null) ctx.strokeStyle = fs;
                }
                else if (this.style('stroke').hasValue()) {
                    var strokeStyle = this.style('stroke');
                    if (this.style('stroke-opacity').hasValue()) strokeStyle = strokeStyle.Color.addOpacity(this.style('stroke-opacity').value);
                    ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
                }
                if (this.style('stroke-width').hasValue()) ctx.lineWidth = this.style('stroke-width').Length.toPixels();
                if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
                if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
                if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;

                // font
                if (typeof(ctx.font) != 'undefined') {
                    ctx.font = svg.Font.CreateFont( 
                        this.style('font-style').value, 
                        this.style('font-variant').value, 
                        this.style('font-weight').value, 
                        this.style('font-size').hasValue() ? this.style('font-size').Length.toPixels() + 'px' : '', 
                        this.style('font-family').value).toString();
                }
                
                // transform
                if (this.attribute('transform').hasValue()) { 
                    var transform = new svg.Transform(this.attribute('transform').value);
                    transform.apply(ctx);
                }
                
                // clip
                            /*
                if (this.attribute('clip-path').hasValue()) {
                    var clip = this.attribute('clip-path').Definition.getDefinition();
                    if (clip != null) clip.apply(ctx);
                }
                            */
                
                // opacity
                if (this.style('opacity').hasValue()) {
                    ctx.globalAlpha = this.style('opacity').numValue();
                }
            }       
        }
        svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
        
        svg.Element.PathElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                if (ctx != null) ctx.beginPath();
                return new svg.BoundingBox();
            }
            
            this.renderChildren = function(ctx) {
                this.path(ctx);
                
                if (ctx.fillStyle != '') ctx.fill();
                if (ctx.strokeStyle != '') ctx.stroke();
                
                var markers = this.getMarkers();
                if (markers != null) {
                    if (this.style('marker-start').Definition.isUrl()) {
                        var marker = this.style('marker-start').Definition.getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1]);
                    }
                    if (this.style('marker-mid').Definition.isUrl()) {
                        var marker = this.style('marker-mid').Definition.getDefinition();
                        for (var i=1;i<markers.length-1;i++) {
                            marker.render(ctx, markers[i][0], markers[i][1]);
                        }
                    }
                    if (this.style('marker-end').Definition.isUrl()) {
                        var marker = this.style('marker-end').Definition.getDefinition();
                        marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
                    }
                }                   
            }
            
            this.getBoundingBox = function() {
                return this.path();
            }
            
            this.getMarkers = function() {
                return null;
            }
        }
        svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
        
        // svg element
        svg.Element.svg = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseClearContext = this.clearContext;
            this.clearContext = function(ctx) {
                this.baseClearContext(ctx);
                svg.ViewPort.RemoveCurrent();
            }
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                // initial values
                ctx.strokeStyle = 'rgba(0,0,0,0)';
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                ctx.miterLimit = 4;         
            
                this.baseSetContext(ctx);
                
                // create new view port
                if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
                    ctx.translate(this.attribute('x').Length.toPixels('x'), this.attribute('y').Length.toPixels('y'));
                }
                
                var width = svg.ViewPort.width();
                var height = svg.ViewPort.height();
                if (typeof(this.root) == 'undefined' && this.attribute('width').hasValue() && this.attribute('height').hasValue()) {
                    width = this.attribute('width').Length.toPixels('x');
                    height = this.attribute('height').Length.toPixels('y');
                    
                    var x = 0;
                    var y = 0;
                    if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
                        x = -this.attribute('refX').Length.toPixels('x');
                        y = -this.attribute('refY').Length.toPixels('y');
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(width, y);
                    ctx.lineTo(width, height);
                    ctx.lineTo(x, height);
                    ctx.closePath();
                    ctx.clip();
                }
                svg.ViewPort.SetCurrent(width, height); 
                        
                // viewbox
                if (this.attribute('viewBox').hasValue()) {             
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value, 
                                    svg.ViewPort.width(), 
                                    width,
                                    svg.ViewPort.height(),
                                    height,
                                    minX,
                                    minY,
                                    this.attribute('refX').value,
                                    this.attribute('refY').value);
                                        
                    svg.ViewPort.RemoveCurrent();   
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);                        
                }               
            }
        }
        svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

        // rect element
        svg.Element.rect = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var x = this.attribute('x').Length.toPixels('x');
                var y = this.attribute('y').Length.toPixels('y');
                var width = this.attribute('width').Length.toPixels('x');
                var height = this.attribute('height').Length.toPixels('y');
                var rx = this.attribute('rx').Length.toPixels('x');
                var ry = this.attribute('ry').Length.toPixels('y');
                if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
                if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(x + rx, y);
                    ctx.lineTo(x + width - rx, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
                    ctx.lineTo(x + width, y + height - ry);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
                    ctx.lineTo(x + rx, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
                    ctx.lineTo(x, y + ry);
                    ctx.quadraticCurveTo(x, y, x + rx, y);
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.rect.prototype = new svg.Element.PathElementBase;
        
        // circle element
        svg.Element.circle = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var cx = this.attribute('cx').Length.toPixels('x');
                var cy = this.attribute('cy').Length.toPixels('y');
                var rx = this.attribute('r').Length.toPixels('x');
                var ry = this.attribute('r').Length.toPixels('y');
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
            }
        }
        svg.Element.circle.prototype = new svg.Element.PathElementBase; 

        // ellipse element
        svg.Element.ellipse = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var rx = this.attribute('rx').Length.toPixels('x');
                var ry = this.attribute('ry').Length.toPixels('y');
                var cx = this.attribute('cx').Length.toPixels('x');
                var cy = this.attribute('cy').Length.toPixels('y');
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
            }
        }
        svg.Element.ellipse.prototype = new svg.Element.PathElementBase;            
        
        // line element
        svg.Element.line = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.getPoints = function() {
                return [
                    new svg.Point(this.attribute('x1').Length.toPixels('x'), this.attribute('y1').Length.toPixels('y')),
                    new svg.Point(this.attribute('x2').Length.toPixels('x'), this.attribute('y2').Length.toPixels('y'))];
            }
                                
            this.path = function(ctx) {
                var points = this.getPoints();
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                }
                
                return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
            }
            
            this.getMarkers = function() {
                var points = this.getPoints();  
                var a = points[0].angleTo(points[1]);
                return [[points[0], a], [points[1], a]];
            }
        }
        svg.Element.line.prototype = new svg.Element.PathElementBase;       
                
        // polyline element
        svg.Element.polyline = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.points = svg.CreatePath(this.attribute('points').value);
            this.path = function(ctx) {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                }
                for (var i=1; i<this.points.length; i++) {
                    bb.addPoint(this.points[i].x, this.points[i].y);
                    if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                return bb;
            }
            
            this.getMarkers = function() {
                var markers = [];
                for (var i=0; i<this.points.length - 1; i++) {
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
                }
                markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
                return markers;
            }           
        }
        svg.Element.polyline.prototype = new svg.Element.PathElementBase;               
                
        // polygon element
        svg.Element.polygon = function(node) {
            this.base = svg.Element.polyline;
            this.base(node);
            
            this.basePath = this.path;
            this.path = function(ctx) {
                var bb = this.basePath(ctx);
                if (ctx != null) {
                    ctx.lineTo(this.points[0].x, this.points[0].y);
                    ctx.closePath();
                }
                return bb;
            }
        }
        svg.Element.polygon.prototype = new svg.Element.polyline;

        // path element
        svg.Element.path = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);

            //log("creating path element");
                    
            var d = this.attribute('d').value;
            // TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
            d = d.replace(/,/gm,' '); // get rid of all commas
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
            d = svg.compressSpaces(d); // compress multiple spaces
            d = svg.trim(d);
            this.PathParser = new (function(d) {
                this.tokens = d.split(' ');
                //log("  .. parsing path, "+this.tokens.length+" tokens");
                
                this.reset = function() {
                    this.i = -1;
                    this.command = '';
                    this.previousCommand = '';
                    this.start = new svg.Point(0, 0);
                    this.control = new svg.Point(0, 0);
                    this.current = new svg.Point(0, 0);
                    this.points = [];
                    this.angles = [];
                }
                                
                this.isEnd = function() {
                    return this.i >= this.tokens.length - 1;
                }
                
                this.isCommandOrEnd = function() {
                    if (this.isEnd()) return true;
                    return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
                }
                
                this.isRelativeCommand = function() {
                    return this.command == this.command.toLowerCase();
                }
                            
                this.getToken = function() {
                    this.i = this.i + 1;
                    return this.tokens[this.i];
                }
                
                this.getScalar = function() {
                    return parseFloat(this.getToken());
                }
                
                this.nextCommand = function() {
                    this.previousCommand = this.command;
                    this.command = this.getToken();
                }               
                
                this.getPoint = function() {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p);
                }
                
                this.getAsControlPoint = function() {
                    var p = this.getPoint();
                    this.control = p;
                    return p;
                }
                
                this.getAsCurrentPoint = function() {
                    var p = this.getPoint();
                    this.current = p;
                    return p;   
                }
                
                this.getReflectedControlPoint = function() {
                    if (this.previousCommand.toLowerCase() != 'c' && 
                        this.previousCommand.toLowerCase() != 's' &&
                        this.previousCommand.toLowerCase() != 'q' &&
                        this.previousCommand.toLowerCase() != 't') {
                        return this.current;
                    }
                    
                    // reflect point
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);                    
                    return p;
                }
                
                this.makeAbsolute = function(p) {
                    if (this.isRelativeCommand()) {
                        p.x = this.current.x + p.x;
                        p.y = this.current.y + p.y;
                    }
                    return p;
                }
                
                this.addMarker = function(p, from, priorTo) {
                    // if the last angle isn't filled in because we didn't have this point yet ...
                    if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
                        this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
                    }
                    this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
                }
                
                this.addMarkerAngle = function(p, a) {
                    this.points.push(p);
                    this.angles.push(a);
                }               
                
                this.getMarkerPoints = function() { return this.points; }
                this.getMarkerAngles = function() {
                    for (var i=0; i<this.angles.length; i++) {
                        if (this.angles[i] == null) {
                            for (var j=i+1; j<this.angles.length; j++) {
                                if (this.angles[j] != null) {
                                    this.angles[i] = this.angles[j];
                                    break;
                                }
                            }
                        }
                    }
                    return this.angles;
                }
            })(d);

            this.path = function(ctx) {
                var pp = this.PathParser;
                pp.reset();

                var bb = new svg.BoundingBox();
                if (ctx != null) ctx.beginPath();
                while (!pp.isEnd()) {
                    pp.nextCommand();
                    switch (pp.command.toUpperCase()) {
                    case 'M':
                        var p = pp.getAsCurrentPoint();
                        pp.addMarker(p);
                        bb.addPoint(p.x, p.y);
                        if (ctx != null) ctx.moveTo(p.x, p.y);
                        pp.start = pp.current;
                        while (!pp.isCommandOrEnd()) {
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, pp.start);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'L':
                        while (!pp.isCommandOrEnd()) {
                            var c = pp.current;
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, c);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'H':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'V':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'C':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'S':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getReflectedControlPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'Q':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'T':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getReflectedControlPoint();
                            pp.control = cntrl;
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'A':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var rx = pp.getScalar();
                            var ry = pp.getScalar();
                            var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                            var largeArcFlag = pp.getScalar();
                            var sweepFlag = pp.getScalar();
                            var cp = pp.getAsCurrentPoint();

                            // Conversion from endpoint to center parameterization
                            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                            // x1', y1'
                            var currp = new svg.Point(
                                Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
                                -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                            );
                            // adjust radii
                            var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
                            if (l > 1) {
                                rx *= Math.sqrt(l);
                                ry *= Math.sqrt(l);
                            }
                            // cx', cy'
                            var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                                ((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
                                (Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
                            );
                            if (isNaN(s)) s = 0;
                            var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                            // cx, cy
                            var centp = new svg.Point(
                                (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                                (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                            );
                            // vector magnitude
                            var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
                            // ratio between two vectors
                            var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
                            // angle between two vectors
                            var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
                            // initial angle
                            var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
                            // angle delta
                            var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
                            var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
                            var ad = a(u, v);
                            if (r(u,v) <= -1) ad = Math.PI;
                            if (r(u,v) >= 1) ad = 0;

                            if (sweepFlag == 0 && ad > 0) ad = ad - 2 * Math.PI;
                            if (sweepFlag == 1 && ad < 0) ad = ad + 2 * Math.PI;

                            // for markers
                            var halfWay = new svg.Point(
                                centp.x - rx * Math.cos((a1 + ad) / 2),
                                centp.y - ry * Math.sin((a1 + ad) / 2)
                            );
                            pp.addMarkerAngle(halfWay, (a1 + ad) / 2 + (sweepFlag == 0 ? 1 : -1) * Math.PI / 2);
                            pp.addMarkerAngle(cp, ad + (sweepFlag == 0 ? 1 : -1) * Math.PI / 2);

                            bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
                            if (ctx != null) {
                                var r = rx > ry ? rx : ry;
                                var sx = rx > ry ? 1 : rx / ry;
                                var sy = rx > ry ? ry / rx : 1;

                                ctx.translate(centp.x, centp.y);
                                ctx.rotate(xAxisRotation);
                                ctx.scale(sx, sy);
                                ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                ctx.scale(1/sx, 1/sy);
                                ctx.rotate(-xAxisRotation);
                                ctx.translate(-centp.x, -centp.y);
                            }
                        }
                        break;
                    case 'Z':
                        if (ctx != null) ctx.closePath();
                        pp.current = pp.start;
                    }
                }

                return bb;
            }

            this.getMarkers = function() {
                var points = this.PathParser.getMarkerPoints();
                var angles = this.PathParser.getMarkerAngles();
                
                var markers = [];
                for (var i=0; i<points.length; i++) {
                    markers.push([points[i], angles[i]]);
                }
                return markers;
            }
        }
        svg.Element.path.prototype = new svg.Element.PathElementBase;
        
    /*      // pattern element
        svg.Element.pattern = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.createPattern = function(ctx, element) {
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['x'] = new svg.Property('x', this.attribute('x').value);
                tempSvg.attributes['y'] = new svg.Property('y', this.attribute('y').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
                tempSvg.children = this.children;
                
                var c = document.createElement('canvas');
                c.width = this.attribute('width').Length.toPixels('x');
                c.height = this.attribute('height').Length.toPixels('y');
                tempSvg.render(c.getContext('2d'));     
                return ctx.createPattern(c, 'repeat');
            }
        }
        svg.Element.pattern.prototype = new svg.Element.ElementBase;*/
        
        // marker element
        svg.Element.marker = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.baseRender = this.render;
            this.render = function(ctx, point, angle) {
                ctx.translate(point.x, point.y);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
                ctx.save();
                            
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
                tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
                tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
                tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
                tempSvg.children = this.children;
                tempSvg.render(ctx);
                
                ctx.restore();
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
                ctx.translate(-point.x, -point.y);
            }
        }
        svg.Element.marker.prototype = new svg.Element.ElementBase;
        
        // definitions element
        svg.Element.defs = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            this.render = function(ctx) {
                // NOOP
            }
        }
        svg.Element.defs.prototype = new svg.Element.ElementBase;


        // font element
        svg.Element.font = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.horizAdvX = this.attribute('horiz-adv-x').numValue();

            this.isRTL = false;
            this.isArabic = false;
            this.fontFace = null;
            this.missingGlyph = null;
            this.glyphs = [];
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'font-face') {
                    this.fontFace = child;
                    if (child.style('font-family').hasValue()) {
                        svg.Definitions[child.style('font-family').value] = this;
                    }
                }
                else if (child.type == 'missing-glyph') this.missingGlyph = child;
                else if (child.type == 'glyph') {
                    if (child.arabicForm != '') {
                        this.isRTL = true;
                        this.isArabic = true;
                        if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
                        this.glyphs[child.unicode][child.arabicForm] = child;
                    }
                    else {
                        this.glyphs[child.unicode] = child;
                    }
                }
            }
        }
        svg.Element.font.prototype = new svg.Element.ElementBase;

        // font-face element
        svg.Element.fontface = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.ascent = this.attribute('ascent').value;
            this.descent = this.attribute('descent').value;
            this.unitsPerEm = this.attribute('units-per-em').numValue();
        }
        svg.Element.fontface.prototype = new svg.Element.ElementBase;

        // missing-glyph element
        svg.Element.missingglyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);

            this.horizAdvX = 0;
        }
        svg.Element.missingglyph.prototype = new svg.Element.path;

        // glyph element
        svg.Element.glyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);

            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.unicode = this.attribute('unicode').value;
            this.arabicForm = this.attribute('arabic-form').value;
        }
        svg.Element.glyph.prototype = new svg.Element.path;

        // text element
        svg.Element.text = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.style('dominant-baseline').hasValue()) ctx.textBaseline = this.style('dominant-baseline').value;
                if (this.style('alignment-baseline').hasValue()) ctx.textBaseline = this.style('alignment-baseline').value;
            }

            this.renderChildren = function(ctx) {

                var textAnchor = this.style('text-anchor').valueOrDefault('start');
                var x = this.attribute('x').Length.toPixels('x');
                var y = this.attribute('y').Length.toPixels('y');
                for (var i=0; i<this.children.length; i++) {

                    var child = this.children[i];

                    if (child.attribute('x').hasValue()) {
                        child.x = child.attribute('x').Length.toPixels('x');
                    }
                    else {
                        if (child.attribute('dx').hasValue()) x += child.attribute('dx').Length.toPixels('x');
                        child.x = x;
                    }

                    var childLength = child.measureText(ctx);
                    if (textAnchor != 'start' && (i==0 || child.attribute('x').hasValue())) { // new group?
                        // loop through rest of children
                        var groupLength = childLength;
                        for (var j=i+1; j<this.children.length; j++) {
                            var childInGroup = this.children[j];
                            if (childInGroup.attribute('x').hasValue()) break; // new group
                            groupLength += childInGroup.measureText(ctx);
                        }
                        child.x -= (textAnchor == 'end' ? groupLength : groupLength / 2.0);
                    }
                    x = child.x + childLength;

                    if (child.attribute('y').hasValue()) {
                        child.y = child.attribute('y').Length.toPixels('y');
                    }
                    else {
                        if (child.attribute('dy').hasValue()) y += child.attribute('dy').Length.toPixels('y');
                        child.y = y;
                    }
                    y = child.y;

                    child.render(ctx);
                }
            }
        }
        svg.Element.text.prototype = new svg.Element.RenderedElementBase;

        // text base
        svg.Element.TextElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.getGlyph = function(font, text, i) {
                var c = text[i];
                var glyph = null;
                if (font.isArabic) {
                    var arabicForm = 'isolated';
                    if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';
                    if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
                    if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
                    if (typeof(font.glyphs[c]) != 'undefined') {
                        glyph = font.glyphs[c][arabicForm];
                        if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
                    }
                }
                else {
                    glyph = font.glyphs[c];
                }
                if (glyph == null) glyph = font.missingGlyph;
                return glyph;
            }

            this.renderChildren = function(ctx) {
                var customFont = this.parent.style('font-family').Definition.getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");

                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        var scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y);
                        ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                        if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
                        glyph.render(ctx);
                        if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
                        ctx.lineWidth = lw;
                        ctx.scale(1/scale, -1/scale);
                        ctx.translate(-this.x, -this.y);

                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            this.x += dx[i];
                        }
                    }
                    return;
                }

                if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
                if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
            }

            this.getText = function() {
                // OVERRIDE ME
            }

            this.measureText = function(ctx) {
                var customFont = this.parent.style('font-family').Definition.getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var measure = 0;
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            measure += dx[i];
                        }
                    }
                    return measure;
                }

                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText) return textToMeasure.length * 10;

                ctx.save();
                this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                ctx.restore();
                return width;
            }
        }
        svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;

        // tspan
        svg.Element.tspan = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.text = node.text() || '';
            this.getText = function() {
                return this.text;
            }
        }
        svg.Element.tspan.prototype = new svg.Element.TextElementBase;
    

        /*
        // base for gradients
        svg.Element.GradientBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
            
            this.stops = [];            
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                this.stops.push(child);
            }   
            
            this.getGradient = function() {
                // OVERRIDE ME!
            }           

            this.createGradient = function(ctx, element) {
                var stopsContainer = this;
                if (this.attribute('xlink:href').hasValue()) {
                    stopsContainer = this.attribute('xlink:href').Definition.getDefinition();
                }
            
                var g = this.getGradient(ctx, element);
                for (var i=0; i<stopsContainer.stops.length; i++) {
                    g.addColorStop(stopsContainer.stops[i].offset, stopsContainer.stops[i].color);
                }
                
                if (this.attribute('gradientTransform').hasValue()) {
                    // render as transformed pattern on temporary canvas
                    var rootView = svg.ViewPort.viewPorts[0];
                    
                    var rect = new svg.Element.rect();
                    rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
                    rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);
                    
                    var group = new svg.Element.g();
                    group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
                    group.children = [ rect ];
                    
                    var tempSvg = new svg.Element.svg();
                    tempSvg.attributes['x'] = new svg.Property('x', 0);
                    tempSvg.attributes['y'] = new svg.Property('y', 0);
                    tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
                    tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
                    tempSvg.children = [ group ];
                    
                    var c = document.createElement('canvas');
                    c.width = rootView.width;
                    c.height = rootView.height;
                    var tempCtx = c.getContext('2d');
                    tempCtx.fillStyle = g;
                    tempSvg.render(tempCtx);        
                    return tempCtx.createPattern(c, 'no-repeat');
                }
                
                return g;               
            }
        }
        svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
        
        // linear gradient element
        svg.Element.linearGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();
                
                var x1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x1').numValue() 
                    : this.attribute('x1').Length.toPixels('x'));
                var y1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y1').numValue()
                    : this.attribute('y1').Length.toPixels('y'));
                var x2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x2').numValue()
                    : this.attribute('x2').Length.toPixels('x'));
                var y2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y2').numValue()
                    : this.attribute('y2').Length.toPixels('y'));

                return ctx.createLinearGradient(x1, y1, x2, y2);
            }
        }
        svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
        
        // radial gradient element
        svg.Element.radialGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();
                
                var cx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('cx').numValue() 
                    : this.attribute('cx').Length.toPixels('x'));
                var cy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('cy').numValue() 
                    : this.attribute('cy').Length.toPixels('y'));
                
                var fx = cx;
                var fy = cy;
                if (this.attribute('fx').hasValue()) {
                    fx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('fx').numValue() 
                    : this.attribute('fx').Length.toPixels('x'));
                }
                if (this.attribute('fy').hasValue()) {
                    fy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('fy').numValue() 
                    : this.attribute('fy').Length.toPixels('y'));
                }
                
                var r = (this.gradientUnits == 'objectBoundingBox' 
                    ? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
                    : this.attribute('r').Length.toPixels());
                
                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
            }
        }
        svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
        
        // gradient stop element
        svg.Element.stop = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.offset = this.attribute('offset').numValue();
            
            var stopColor = this.style('stop-color');
            if (this.style('stop-opacity').hasValue()) stopColor = stopColor.Color.addOpacity(this.style('stop-opacity').value);
            this.color = stopColor.value;
        }
        svg.Element.stop.prototype = new svg.Element.ElementBase;
        */
        // group element
        svg.Element.g = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.getBoundingBox = function() {
                var bb = new svg.BoundingBox();
                for (var i=0; i<this.children.length; i++) {
                    bb.addBoundingBox(this.children[i].getBoundingBox());
                }
                return bb;
            };
        }
        svg.Element.g.prototype = new svg.Element.RenderedElementBase;

        // symbol element
        svg.Element.symbol = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {       
                this.baseSetContext(ctx);
                
                // viewbox
                if (this.attribute('viewBox').hasValue()) {             
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value, 
                                    this.attribute('width').Length.toPixels('x'),
                                    width,
                                    this.attribute('height').Length.toPixels('y'),
                                    height,
                                    minX,
                                    minY);

                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);                        
                }
            }           
        }
        svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;     
            
        // style element
        svg.Element.style = function(node) { 
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            // text, or spaces then CDATA
            var css = node.childNodes()[0].nodeValue + (node.childNodes().length > 1 ? node.childNodes()[1].nodeValue : '');
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
            css = svg.compressSpaces(css); // replace whitespace
            var cssDefs = css.split('}');
            for (var i=0; i<cssDefs.length; i++) {
                if (svg.trim(cssDefs[i]) != '') {
                    var cssDef = cssDefs[i].split('{');
                    var cssClasses = cssDef[0].split(',');
                    var cssProps = cssDef[1].split(';');
                    for (var j=0; j<cssClasses.length; j++) {
                        var cssClass = svg.trim(cssClasses[j]);
                        if (cssClass != '') {
                            var props = {};
                            for (var k=0; k<cssProps.length; k++) {
                                var prop = cssProps[k].indexOf(':');
                                var name = cssProps[k].substr(0, prop);
                                var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                if (name != null && value != null) {
                                    props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
                                }
                            }
                            svg.Styles[cssClass] = props;
                            if (cssClass == '@font-face') {
                                var fontFamily = props['font-family'].value.replace(/"/g,'');
                                var srcs = props['src'].value.split(',');
                                for (var s=0; s<srcs.length; s++) {
                                    if (srcs[s].indexOf('format("svg")') > 0) {
                                        var urlStart = srcs[s].indexOf('url');
                                        var urlEnd = srcs[s].indexOf(')', urlStart);
                                        var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                        var doc = svg.parseXml(svg.ajax(url));
                                        var fonts = doc.getElementsByTagName('font');
                                        for (var f=0; f<fonts.length; f++) {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        svg.Element.style.prototype = new svg.Element.ElementBase;
        
        // use element 
        svg.Element.use = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').Length.toPixels('x'), 0);
                if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').Length.toPixels('y'));
            }
            
            this.getDefinition = function() {
                var element = this.attribute('xlink:href').Definition.getDefinition();
                if (this.attribute('width').hasValue()) element.attribute('width', true).value = this.attribute('width').value;
                if (this.attribute('height').hasValue()) element.attribute('height', true).value = this.attribute('height').value;
                return element;
            }
            
            this.path = function(ctx) {
                var element = this.getDefinition();
                if (element != null) element.path(ctx);
            }
            
            this.renderChildren = function(ctx) {
                var element = this.getDefinition();
                if (element != null) element.render(ctx);
            }
        }
        svg.Element.use.prototype = new svg.Element.RenderedElementBase;
        
        /*// mask element
        svg.Element.mask = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var x = this.attribute('x').Length.toPixels('x');
                var y = this.attribute('y').Length.toPixels('y');
                var width = this.attribute('width').Length.toPixels('x');
                var height = this.attribute('height').Length.toPixels('y');
                
                // temporarily remove mask to avoid recursion
                var mask = element.attribute('mask').value;
                element.attribute('mask').value = '';
                
                    var cMask = document.createElement('canvas');
                    cMask.width = x + width;
                    cMask.height = y + height;
                    var maskCtx = cMask.getContext('2d');
                    this.renderChildren(maskCtx);
                
                    var c = document.createElement('canvas');
                    c.width = x + width;
                    c.height = y + height;
                    var tempCtx = c.getContext('2d');
                    element.render(tempCtx);
                    tempCtx.globalCompositeOperation = 'destination-in';
                    //tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
                    tempCtx.fillRect(0, 0, x + width, y + height);
                    
                    //ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
                    ctx.fillRect(0, 0, x + width, y + height);
                    
                // reassign mask
                element.attribute('mask').value = mask; 
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.mask.prototype = new svg.Element.ElementBase;*/
        
        // clip element
        svg.Element.clipPath = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx) {
                for (var i=0; i<this.children.length; i++) {
                    if (this.children[i].path) {
                        this.children[i].path(ctx);
                        ctx.clip();
                    }
                }
            }
            
            this.render = function(ctx) {
                        Debug.log('no op');
                // NO RENDER
            }
        }
        svg.Element.clipPath.prototype = new svg.Element.ElementBase;
    /*
        // filters
        svg.Element.filter = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var bb = element.getBoundingBox();
                var x = this.attribute('x').Length.toPixels('x');
                var y = this.attribute('y').Length.toPixels('y');
                if (x == 0 || y == 0) {
                    x = bb.x1;
                    y = bb.y1;
                }
                var width = this.attribute('width').Length.toPixels('x');
                var height = this.attribute('height').Length.toPixels('y');
                if (width == 0 || height == 0) {
                    width = bb.width();
                    height = bb.height();
                }
                
                // temporarily remove filter to avoid recursion
                var filter = element.style('filter').value;
                element.style('filter').value = '';
                
                // max filter distance
                var extraPercent = .20;
                var px = extraPercent * width;
                var py = extraPercent * height;
                
                var c = document.createElement('canvas');
                c.width = width + 2*px;
                c.height = height + 2*py;
                var tempCtx = c.getContext('2d');
                tempCtx.translate(-x + px, -y + py);
                element.render(tempCtx);
            
                // apply filters
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
                }
                
                // render on me
                ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);
                
                // reassign filter
                element.style('filter', true).value = filter;   
            }
            
            this.render = function(ctx) {
                // NO RENDER
            }       
        }
        svg.Element.filter.prototype = new svg.Element.ElementBase;
        
        svg.Element.feGaussianBlur = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            function make_fgauss(sigma) {
                sigma = Math.max(sigma, 0.01);                
                var len = Math.ceil(sigma * 4.0) + 1;                     
                mask = [];                               
                for (var i = 0; i < len; i++) {                             
                    mask[i] = Math.exp(-0.5 * (i / sigma) * (i / sigma));                                           
                }                                                           
                return mask; 
            }
            
            function normalize(mask) {
                var sum = 0;
                for (var i = 1; i < mask.length; i++) {
                    sum += Math.abs(mask[i]);
                }
                sum = 2 * sum + Math.abs(mask[0]);
                for (var i = 0; i < mask.length; i++) {
                    mask[i] /= sum;
                }
                return mask;
            }
            
            function convolve_even(src, dst, mask, width, height) {
              for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                  var a = imGet(src, x, y, width, height, 3)/255;
                  for (var rgba = 0; rgba < 4; rgba++) {                      
                      var sum = mask[0] * (a==0?255:imGet(src, x, y, width, height, rgba)) * (a==0||rgba==3?1:a);
                      for (var i = 1; i < mask.length; i++) {
                        var a1 = imGet(src, Math.max(x-i,0), y, width, height, 3)/255;
                        var a2 = imGet(src, Math.min(x+i, width-1), y, width, height, 3)/255;
                        sum += mask[i] * 
                          ((a1==0?255:imGet(src, Math.max(x-i,0), y, width, height, rgba)) * (a1==0||rgba==3?1:a1) + 
                           (a2==0?255:imGet(src, Math.min(x+i, width-1), y, width, height, rgba)) * (a2==0||rgba==3?1:a2));
                      }
                      imSet(dst, y, x, height, width, rgba, sum);
                  }           
                }
              }
            }       

            function imGet(img, x, y, width, height, rgba) {
                return img[y*width*4 + x*4 + rgba];
            }
            
            function imSet(img, x, y, width, height, rgba, val) {
                img[y*width*4 + x*4 + rgba] = val;
            }
                        
            function blur(ctx, width, height, sigma)
            {
                var srcData = ctx.getImageData(0, 0, width, height);
                var mask = make_fgauss(sigma);
                mask = normalize(mask);
                tmp = [];
                convolve_even(srcData.data, tmp, mask, width, height);
                convolve_even(tmp, srcData.data, mask, height, width);
                ctx.clearRect(0, 0, width, height);
                ctx.putImageData(srcData, 0, 0);
            }           
        
            this.apply = function(ctx, x, y, width, height) {
                // assuming x==0 && y==0 for now
                blur(ctx, width, height, this.attribute('stdDeviation').numValue());
            }
        }
        svg.Element.filter.prototype = new svg.Element.feGaussianBlur;*/
        
        // title element, do nothing
        svg.Element.title = function(node) {
        }
        svg.Element.title.prototype = new svg.Element.ElementBase;

        // desc element, do nothing
        svg.Element.desc = function(node) {
        }
        svg.Element.desc.prototype = new svg.Element.ElementBase;       
        
        svg.missingElements = [];

        svg.Element.MISSING = function(node) {
            // log the error only once for each kind of element
            if (svg.missingElements.indexOf(node.name()) === -1) {
                //log('SVG element \'' + node.name() + '\' not implemented. ' + node);
                svg.missingElements.push(node.name());
            }
        }
        svg.Element.MISSING.prototype = new svg.Element.ElementBase;
        
        // element factory
        svg.CreateElement = function(node) {    
            var className = node.name().replace(/^[^:]+:/,''); // remove namespace
            className = className.replace(/\-/g,''); // remove dashes
            var e = null;
            //log("creating svg element for class: "+className);
                
            if (typeof(svg.Element[className]) != 'undefined') {
                e = new svg.Element[className](node);
            }
            else {
                e = new svg.Element.MISSING(node);
            }

            e.type = node.name();
            return e;
        }
        /*      
        // load from url
        svg.load = function(ctx, url) {
            svg.loadXml(ctx, svg.ajax(url));
        }
        */
        // load from xml
        svg.loadXml = function(ctx, xmlString) {
            var xmlParser = ctx.xmlParser;
            var xmlDoc = xmlParser.parseXml(xmlString);
            return svg.loadXmlDoc(ctx, xmlDoc);
        }
        
        svg.loadXmlDoc = function(ctx, doc) {
            svg.init(ctx);
            
    /*      var mapXY = function(p) {
                return p;
                var e = ctx.canvas;
                while (e) {
                    p.x -= e.offsetLeft;
                    p.y -= e.offsetTop;
                    e = e.offsetParent;
                }
                if (window.scrollX) p.x += window.scrollX;
                if (window.scrollY) p.y += window.scrollY;
                return p;
            }
    */

            if ( !doc || !doc.root) {
                return false;
            }
        
            var e = svg.CreateElement(doc.root());
            e.root = true;

            var cWidth = 100;
            var cHeight = 100;
            if (e.style('width').hasValue()) {
                cWidth = e.style('width').Length.toPixels('x');
            }
            if (e.style('height').hasValue()) {
                cHeight = e.style('height').Length.toPixels('y');
            }

            svg.ViewPort.Clear();
            svg.ViewPort.SetCurrent(cWidth, cHeight);
                    
            e.render(ctx);

            return true;
        }
        
        return svg;
    }

    // Expose the two properties.
    this.buildSvg = buildSvg;
    this.Context = Context;
};
//stlparser.js
/*
The code below is referenced from //depot/labs_client/importers/stlparser.js.
Internal use only, not exported to clients.
@private
@class StlParser
**/
var StlParser = {

    /*
    Parse ASCII STL data into a {Mesh3D} object.   
    @for StlParser
    @since 1.1.0
    @param {String|ArrayBuffer} data The data to be parsed
    @param {Mesh3D} mesh The Mesh3D object where the data is parsed onto
    **/ 
    parseAsciiSTL: function(data, mesh) {
        var didFindHeader = false
        var idx = 0;
        var len = data.byteLength;
        var tri = [0,0,0, 0,0,0, 0,0,0], itri = 0;
        while (idx < len) {
            // Parse one row
            var row = '';
            while (idx < len) {
                var chr = data.getUint8(idx);
                idx++;
                if (chr === 10 || chr === 13) { // Line break
                    if (row.length > 0)
                        break;
                }
                row += String.fromCharCode(chr > 127 ? 65533 : chr);        
            }
            // Prune white space
            row = row.replace(/\s+/g,' ');
            row = row.trim();
            // Try to match "vertex <x> <y> <z>"
            var items = row.split(' ');

            if (!didFindHeader) {
                if (items.length < 1 || items[0] !== 'solid') {
                    Debug.log("parseAsciiSTL: could not find header on first line");
                    return false;
                } else {
                    didFindHeader = true;
                }
            }

            if (items.length === 4 && items[0] === "vertex") {
                var x = parseFloat(items[1]) ;
                var y = parseFloat(items[2]) ;
                var z = parseFloat(items[3]) ;
                if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    Debug.log("parseAsciiSTL(): Invalid floating point value: ["+items[1]+","+items[2]+","+items[3]+"]");
                    return false;
                }
                tri[itri*3+0] = x;
                tri[itri*3+1] = y;
                tri[itri*3+2] = z;
                itri++;

                // After 3 vertices, add a triangle.
                if (itri >= 3) {
                    mesh.triangle(tri);
                    itri = 0;
                }
            }
        }

        return true;
    }, 

    /*
    Parse binary STL data into a {Mesh3D} object.   
    @for StlParser
    @since 1.1.0
    @param {String|ArrayBuffer} data The data to be parsed
    @param {Mesh3D} mesh The Mesh3D object where the data is parsed onto
    **/ 
    parseBinarySTL: function(data, mesh) {
        if (data.byteLength < 80+4)
            return false;

        var offset = 80; // Skip header
        var numTris = data.getUint32(offset, true); 
        var expectDataSize = 80+4+numTris*50;
        if (data.byteLength < expectDataSize)
            return false;
        offset += 4;

        var tri = [0,0,0, 0,0,0, 0,0,0];
        var index = 0;
        for (var i=0; i<numTris; i++) {
            offset += 12; // Skip the face normals
            for (var j = 0; j < 3; j++) {
                index = j*3;
                tri[index] = data.getFloat32(offset, true) ;
                tri[index+1] = data.getFloat32(offset+4, true) ;
                tri[index+2] = data.getFloat32(offset+8, true) ;
                offset += 12;
            }
            mesh.triangle(tri);
            offset += 2; // Skip attribute byte count (uint16)
        } 

        return true;

    }
};
//event.js
/**
EventSource is the standard way of declaring an event which clients can bind to, to receive callback notifications when the event occurs.
@class EventSource
@since 1.1.0
@param {String} type A meaningful identifier for the event name.
@param {Object} [target] The object that serves as the {Event#target} for raised events.
@constructor
@example 

//define custom event to which listeners can listen for a change
var customEvent = new CoreLibrary.EventSource('customevent');

var eventListener = function () {
    //some code
};

customEvent.bind(eventListener); //bind event listener

function someFunction() {
    customEvent.fire(); //call all the event listeners
    
    //unbind listener
    customEvent.unbind(eventListener);
}

**/
function EventSource(type, target) {
    if(!type) {
        return;
    }
    this._type = type;
    this._listeners = [];
    if (target) this._target = target;
}

EventSource.prototype = {

    constructor: EventSource,

    /** 
    Bind listener function to specific event.
    @public
    @method bind
    @param {Function} listener Listener function 
    @example
        event.bind(listener);
    **/
    bind: function(listener) {
        if(!listener) return;
        this._listeners.push(listener);
    },

    /** 
    Unbind listener function from specific event.
    @public
    @method unbind
    @param {Function} listener Listener function
    @example
        event.unbind(); //will unbind all the listeners
    @example
        event.unbind(listener); //will unbind specific listener
    **/
    unbind: function(listener) {
        if(!listener) { //unbind all
            this._listeners = [];
        } else { //unbind specific listener
            var lisCount = this._listeners.length;
            for (var i=0; i < lisCount; i++){
                if (this._listeners[i] === listener){
                    this._listeners.splice(i, 1);
                    break;
                }
            }
        }
    },

    /** 
    Will invoke all the listener functions.
    @public
    @method fire
    @param {Object} data Event-specific data that will be available on the Event object in the data field.
    @param {Object} originalEvent Originating event, if this event is caused by another event.  Will be available on the Event object in the originalEvent field.
    @example
        event.fire(value);
        event.fire(value, domEvent);
    **/
    fire: function(data, originalEvent){

        var lisCount = this._listeners.length;
        if (lisCount > 0) {

            var event = new Event();
            event._target = this._target || this;
            event._type = this._type;
            event._data = data;
            if(originalEvent) event._originalEvent = originalEvent;

            
            for (var i=0; i < lisCount; i++){
                this._listeners[i].call(this, event);
            }
            
        }
    }

};

/**
Event is passed to client callbacks when any {EventSource} is fired using the {EventSource#fire} method.
@class Event
@since 1.1.0
@constructor
**/
function Event() {
    this._type = undefined;
    this._target = undefined;
    this._data = undefined;
    this._bubbles = true;
    this._cancelable = true;
    this._timeStamp = new Date();
    this._originalEvent = undefined;

    /**
    This read-only property is an object that hosts the EventSource.  This is specified by the host in the constructor for {EventSource}.
    @property {Object} target
    @readonly
    @public
    **/
    Object.defineProperty(this, 'target', {
        get : function() {
            return this._target;
        },
        enumerable : true
    });

    /**
    A meaningful name of the event, cooresponding to the string supplied when the firing {EventSource} was constructed.
    @property {String} type
    @readonly
    @public
    **/
    Object.defineProperty(this, 'type', {
        get : function() {
            return this._type;
        },
        enumerable : true
    });

    /**
    Event-specific data associated with this event.  Value supplied in {EventSource#fire}.
    @property {Object} data
    @readonly
    @public
    **/
    Object.defineProperty(this, 'data', {
        get : function() {
            return this._data;
        },
        enumerable : true
    });

    /**
    Identifies current event bubbles down to all listeners or not.
    @property {Boolean} bubbles
    @readonly
    @public
    **/
    Object.defineProperty(this, 'bubbles', {
        get : function() {
            return this._bubbles;
        },
        enumerable : true
    });

    /**
    Identifies current event is cancelable or not.
    @property {Boolean} cancelable
    @readonly
    @public
    **/
    Object.defineProperty(this, 'cancelable', {
        get : function() {
            return this._cancelable;
        },
        enumerable : true
    });

    /**
    Event time stamp.
    @property {Date} timestamp
    @readonly
    @public
    **/
    Object.defineProperty(this, 'timestamp', {
        get : function() {
            return this._timeStamp;
        },
        enumerable : true
    });

    /**
    Information about the originating event, if this event is caused by another event.  Value supplied in {EventSource#fire}.
    @property {Object} originalEvent
    @readonly
    @public
    **/
    Object.defineProperty(this, 'originalEvent', {
        get : function() {
            return this._originalEvent;
        },
        enumerable : true
    });
    
}

Event.prototype = {

    constructor: Event

};

Library.exports.EventSource = EventSource;
initializeObjectMethods(EventSource, 'EventSource');



//shape.js
/**
Information about a particular Creative Platform Library along with parameters for evaluation.
@json LibraryEvaluationJSON
**/

    /**
    Indicates the unique identifier of the Creative Platform Library that is referenced.
    @property libraryId
    @type String
    **/

    /**
    Indicates the revision of the Creative Platform Library that is referenced.
    @property libraryRev
    @type Number
    **/

    /**
    A key-value map of the parameter values that are passed to the Creative Platform Library where the keys represent the parameter id, and the values of those keys represent the real values.
    @property params
    @type Object
    @example
    "params": { "length": 2, "width": 4, "height": 100 }
    **/

/**
The JSON schema for the geometry portion of the shape.  Clients should never manipulate or inspect this structure directly, 
instead they should construct a {Shape} object from {ShapeJSON} then use the methods on the {Shape} object to 
manipulate and inspect it.  This JSON schema is subject to potential changes in the future.
@json ShapeGeometryJSON
@private
**/

    /**
    Indicates the unique identifier of the Creative Platform Library that is referenced.
    @property pluginId
    @type String
    **/

    /**
    Indicates the revision of the Creative Platform Library that is referenced.
    @property pluginRev
    @type Number
    **/

    /**
    Indicates the type of plugin.  Legacy shapes have an empty string, newer shapes have "library"
    @property pluginType
    @type String
    @default library
    **/

    /**
    For stock shapes or imported geometry, this is essentially a foreign key to the static geometry data.  Some of the default / stock shapes are as follows:
    * 101 : Box 
    * 102 : Cylinder 
    * 103 : Pyramid 
    * 104 : Roof 
    * 105 : Round Roof 
    * 106 : Sphere 
    * 107 : Wedge 
    * 108 : Cone 
    * 109 : Half Sphere 
    * 110 : Hexagonal Prism 
    * 111 : Paraboloid 
    * 112 : Torus thin 
    * 113 : Torus 
    * 114 : Torus thick 
    * 115 : Tube thin 
    * 116 : Tube 
    * 117 : Tube thick 
    * 150 : Box Hole 
    * 151 : Cylinder Hole 
    * 300 : A 
    * 301 : B 
    * 302 : C 
    * 303 : D 
    * 304 : E 
    * 305 : F 
    * 306 : G 
    * 307 : H 
    * 308 : I 
    * 309 : J 
    * 310 : K 
    * 311 : L 
    * 312 : M 
    * 313 : N 
    * 314 : O 
    * 315 : P 
    * 316 : Q 
    * 317 : R 
    * 318 : S 
    * 319 : T 
    * 320 : U 
    * 321 : V 
    * 322 : W 
    * 323 : X 
    * 324 : Y 
    * 325 : Z 
    * 350 : 0 
    * 351 : 1 
    * 352 : 2 
    * 353 : 3 
    * 354 : 4 
    * 355 : 5 
    * 356 : 6 
    * 357 : 7 
    * 358 : 8 
    * 359 : 9 
    * 400 : At 
    * 401 : And 
    * 402 : Exclamation Mark 
    * 403 : Question Mark 
    * 404 : Dice 
    * 405 : Diamond 
    * 406 : Star 
    * 407 : Heart 
    * 408 : Tinkercad Logo 
    * 450 : Egg 
    * 451 : Egg Hole 
    * 452 : Bunny ear 
    * 453 : Bunny ear 
    * 454 : Chick foot 
    * 457 : Modify Classic 
    * 458 : Modify Classic Hole 
    * 459 : Modify Mini 
    * 460 : Modify Mini Hole 
    @markdown
    @property dataId
    @type String
    @example
    "dataId": "101"
    **/

    /**
    A key-value map of the parameter values that are passed to the Creative Platform Library where the keys represent the parameter id, and the values of those keys represent the real values.
    @property params
    @type Object
    @example
    "params": { "length": 2, "width": 4, "height": 100 }
    **/

    /**
    When {#dataId} is specified, this repressents the X, Y and Z scales that are to be applied to the data.
    @property scale
    @type {Array[Number]}
    @default [0, 0, 0]
    **/

    /**
    Represents the name of the geom. This could be the Plugin name or the imported file's name depending on the type of the geom.
    @property name
    @type {String}
    **/

/**
The JSON schema for the internal design format.  Clients should never manipulate or inspect this structure directly, 
instead they should construct a {Shape} object from this structure then use the methods on the {Shape} object to 
manipulate and inspect it.  This JSON schema is subject to potential changes in the future.
@json ShapeJSON
@private
**/

    /**
    Indicates the schema version of the shape.  
    @property ver
    @type Number
    @default 1
    **/

    /**
    Indicates the unique ID of the shape within the containing document.  No two shapes can have the same ID.
    @property id
    @type Number
    **/

    /**
    Indicates the schema version of the shape.  
    @property isSub
    @type Boolean
    @default false
    **/

    /**
    Specifies the color of the shape with a sequence of RGBA values between 0 and 255.
    @property color
    @type Array[Number]
    **/

    /**
    For shapes that contain other shapes, this indicates whether the colors of the individual shapes
    permeate through or whether the color defined by {#color} prevails for all children.
    @property isMulticolor
    @type Boolean
    **/

    /**
    For some geometries which have multiple Levels of Detail this indicates which level of detail
    should be used.
    @property lod
    @type Number
    **/

    /**
    A description of the geometry for this shape.
    @property geom
    @type ShapeGeometryJSON
    **/

    /**
    The transformation matrix (local to world) of this particular shape.  It's an array of 16 elements.
    should be used.
    @property TM
    @type Array[Number]
    **/

    /**
    The children contained within this shape.
    @property children
    @type Array[ShapeJSON]
    **/

    /**
    The revision of the shape's topology, each change to any of the members triggers this member to increment by one.
    @property topoRev
    @type Number
    **/

    /**
    Associates a {IShapeConfigurator} by supplying information about the Creative Platform Library it's contained within.
    The Creative Platform Library specified must implement the {IShapeConfiguratorExporter} interface.
    @property conf
    @type LibraryEvaluationJSON
    @proposed
    **/

    /**
    Associates an order dependent list of {IShapeModifier}'s by supplying information about the Creative Platform Libraries they're contained within.
    The Creative Platform Libraries specified must implement the {IShapeModifierExporter} interface.
    @property mods
    @type Array[LibraryEvaluationJSON]
    @proposed
    **/

/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _Shape
@param {ShapeJSON} [json] JSON received from the toJSON method.
@param {Matrix3D} [localToParent] The transformation of this shape to the parent shape.
@private
**/
var _Shape = function(json, localToParent) {

    /**
    @private 
    @property {ShapeJSON} _json.
    **/
    this._json = json;

    /**
    @private 
    @property {Matrix3D} localToParent.
    **/
    if(localToParent instanceof Matrix3D){
        this.localToParent = localToParent;
    }
};

_Shape.prototype = {
    _localToParent: function(){
        if(arguments.length === 0){
            // getter
            if(this.localToParent){
                return this.localToParent;
            }
            return this._localToWorld();
        }
        else{
            // setter
            if(!this.localToParent){
                this._localToWorld(arguments[0]);
            }
            else{
                var tm = arguments[0];
                var newTtrans;
                if (tm instanceof Matrix3D) {
                    newTtrans = tm;
                } else if (Array.isArray(tm) && tm.length === 16) {
                    newTtrans = new Matrix3D(tm);
                } else {
                    Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
                }
                var transDiff = newTtrans.clone().transform(this.localToParent.invert());
                this.localToParent = newTtrans.clone();

                // update the TM of the current and children shapes.
                var updateLocalToWorldTrans = function(shapeJson, transDiff){
                    var localToWorld = transDiff.clone().transform(new Matrix3D(shapeJson.TM));
                    shapeJson.TM = localToWorld.elements;
                    var children = shapeJson.children;
                    for(var i = 0, tot = children.length; i < tot; i++){
                        updateLocalToWorldTrans(shapeJson.children[i], transDiff);
                    }
                };

                updateLocalToWorldTrans(this._json, transDiff);
            }
        }
    },
    _localToWorld: function(){
        if(arguments.length === 0){
            // getter
            if(this._json){
                return new Matrix3D(this._json.TM);
            }
            return undefined;
        }
        else{
            // setter
            if(this._json){
                var tm = arguments[0];
                var matrix;
                if (tm instanceof Matrix3D) {
                    matrix = tm.elements;
                } else if (Array.isArray(tm) && tm.length === 16) {
                    matrix = tm;
                } else {
                    Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
                }

                this._json.TM = matrix;
            }
        }
    }
}

/**
An object that allows discovery and manipulation of a document's structure for a particular shape.  Some of the
traversal members closely mimic the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node">HTML Node</a>.
@class Shape
@constructor
@param {ShapeJSON} [json] JSON received from the toJSON method.
@param {Matrix3D} [localToParent] The transformation of this shape to the parent shape.
@proposed
**/
var Shape = function(json, localToParent){
    /**
    The transformation matrix that describes the transformation from local space to parent space.
    This property ultimately sets {ShapeJSON#TM} but takes into account the parent's transformation.
    @property localToParent
    @type Matrix3D
    **/
   
    /**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @private 
    @property {_Shape} _impl
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Shape(json, localToParent)
    });
};

Shape.prototype = {    

    /**
    Returns the JSON representation of the object that can be serialized.  
    The resulting JSON can be passed into the constructor later on to reconstruct the object.
    @method toJSON
    @return {ShapeJSON}
    **/
    toJSON: function() {
        return this._impl._json;
    },

    /**
    Obtains a shape based on a path of indices, returns undefined if the indices are out of bounds. If the path is empty, returns itself.
    @method shapeByPath
    @param {Array[Number]} indices An array of zero based child indices or an empty array  
    @return {Shape|undefined}
    @example 
    //The same shape object if the input is an empty array
    var currentShape = shape.shapeByPath([]);

    // The first child, then the 3rd child of it.
    var grandChild = parent.shapeByPath([0, 2]); 

    // The first child, then the 3rd child of it.
    var equivalent = parent.shapeByPath([0]).shapeByPath([2]);
    **/
    shapeByPath: function(indices) {
        if(!Array.isArray(indices)){
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }
        //input is an empty array, return itself
        if(indices.length < 1) {
            return this;
        }

        var curNode = this._impl._json;
        var i = 0, tot = indices.length;
        var targetNode, parentNode;
        while(curNode && i < tot){
            if(!curNode.children || curNode.children.length <= indices[i]){
                return undefined; // index overflow, not found
            }
            parentNode= curNode;
            curNode = curNode.children[indices[i]];
            i++;
            if(i === tot){
                targetNode = curNode; // found
            }
        }

        if(targetNode){
            var parentToWorld = new Matrix3D(parentNode.TM.slice(0));
            var localToWorld = new Matrix3D(targetNode.TM.slice(0));
            var localToParent = localToWorld.transform(parentToWorld.invert());

            return new Shape(targetNode, localToParent);
        }
        
        return undefined;
    },

    /**
    This associates a Shape Generator with this shape.
    * All children shapes will be removed.
    * If a Shape Configurator is currently assigned, it will be removed.
    @method assignGenerator
    @param {LibraryEvaluationJSON} assignment Information about the library and default parameters to use.
    @markdown
    **/
    assignGenerator: function(assignment) {
        var _json = this._impl._json;

        if(_json){
            _json.children=[];
            if(!_json["geom"]["params"]){
                _json["geom"]["params"] = {};
            }

            _json["pluginType"] = "library";
            _json["pluginId"] = assignment["libraryId"];
            _json["pluginRev"] = assignment["libraryRev"];
            _json["params"] = assignment["params"];
            _json["scale"] = [1,1,1];
        }
    },

    /**
    Set the value for the parameter of {ShapeGeometryJSON#params}.
    @method setGeneratorParameter
    @param {String} paramId The parameter id.
    @param {Any} value
    @markdown
    **/
    setGeneratorParameter: function(paramId, value) {
        var _json = this._impl._json;
        if(_json && _json.geom){
            if(!_json["geom"]["params"]){
                _json["geom"]["params"] = {};
            }

            _json["geom"]["params"][paramId] = value;
        }
    },

    /**
    Set the value for the parameter of {ShapeGeometryJSON#params}.
    @method setModifierParameter
    @param {Number} modIndex The nth modifier.
    @param {String} paramId The parameter id.
    @param {Any} value
    @markdown
    **/
    setModifierParameter: function(modIndex, paramId, value) {
        if(modIndex < 0){
            Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
        }

        var _json = this._impl._json;
        if(_json && _json.mods){
            if(modIndex >= _json.mods.length){
               Plugin.panic(ERROR_ARGUMENTS_MESSAGE); 
            }

            if(!_json["mods"][modIndex]["params"]){
                _json["mods"][modIndex]["params"] = {};
            }

            _json["mods"][modIndex]["params"][paramId] = value;
        }
    }
};

Object.defineProperty(Shape.prototype, 'localToParent', {
        get: function(){
            return this._impl._localToParent();
        },
        set: function(value){
            return this._impl._localToParent(value);
        }
    });

initializeObjectMethods(Shape, 'Shape');

Library.exports.Shape = Shape;
//font.js

/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _SvgFont
@param {String} svgString The content of a SVG font.
@private
**/
var _SvgFont = (function() {

	/**
	Do a little preprocessing to overwrite the font-family attribute on font-face
	and add a missing glyph if not already exist.
	@private
	@method _preprocessFont
	**/
	var _preprocessFont = function(fontElem, ns) {
		var fontFaceElem = fontElem.get('xmlns:font-face', ns.href());
	    fontFaceElem.attr({"font-family": fontElem.attr("id")});

		var missingGlyphElem = fontElem.get('xmlns:missing-glyph', ns.href());
	    if (!missingGlyphElem) {
	        missingGlyphElem = fontElem.node('missing-glyph');
	    }
	    var pathData = missingGlyphElem.attr("d");
	    if (!pathData) {
	        var substitutes = ["?", " "];
	        var missingGlyph = undefined;
	        for (var i = 0; i < substitutes.length; i++) {
	            var glyphXPath = 'xmlns:glyph[@unicode="' + substitutes[i] + '"]';  
	            missingGlyph = fontElem.get(glyphXPath, ns.href());
	            if (missingGlyph) {
	                break;
	            }
	        };
	        if (missingGlyph) {
	            missingGlyphElem.attr({"horiz-adv-x": missingGlyph.attr("horiz-adv-x")});
	            missingGlyphElem.attr({"d": missingGlyph.attr("d")});
	        }
	    }
	};

	return function(svgString) {
		var fontSvgDoc = xml.parseXml(svgString);

		if (!fontSvgDoc || !fontSvgDoc.root) {
            Plugin.panic("The input is not a valid SVG font.");
        }

        var ns = fontSvgDoc.root().namespace();
	    var fontElem = fontSvgDoc.get('/xmlns:svg/xmlns:defs/xmlns:font', ns.href());
	    var fontFamily = fontElem.attr("id");

        _preprocessFont(fontElem, ns);

		var svgParser = new SvgParser();
    	var svg = svgParser.buildSvg();
    	var ctx = new svgParser.Context(svg, xml, Path2D);

    	svg.init(ctx);
    	svg.CreateElement(fontSvgDoc.root());

    	var font = svg.Definitions[fontFamily];
    	if (!font) {
    		// Font definition not found.
    		Plugin.panic("The input is not a valid SVG font.");
    	}

    	svg.ViewPort.Clear();
        svg.ViewPort.SetCurrent(100, 100);

        // Store the font data.

        /**
	    The name of the font family.
	    @private 
	    @property _fontFamily
	    **/
    	this._fontFamily = fontFamily;

    	/**
	    The font definition generated by SVG parser.
	    @private 
	    @property _font
	    **/
    	this._font = font;

    	/**
	    The SVG parser object that is reused for text rendering.
	    @private 
	    @property _svg
	    **/
    	this._svg = svg;
    	
    	/**
	    The SVG parser context that is reused for text rendering.
	    @private 
	    @property _context
	    **/
    	this._context = ctx;
	};

})();

_SvgFont.prototype = (function() {
	
	/**
	Gets the definition of the specified glyph or missing glyph.
	@private
	@method _getGlyph
	**/
	var _getGlyph = function(font, ch) {
		// Arab glyphs not handled yet.
		return  font.glyphs[ch] || font.missingGlyph;
	};

	return {
		/**
	    Private method for getting the horizontal advance after generating a glyph in horizontal orientation.
	    @private
	    @method _glyphAdvanceX
	    @return {Number}
	    **/
		_glyphAdvance: function(ch, size) {
			var glyph = _getGlyph(this._font, ch);
			return size * (glyph.horizAdvX || this._font.horizAdvX) / this._font.fontFace.unitsPerEm;
		},

		/**
		Private method for rendering a single glyph into an array of Path2D objects.
		@private
		@method _glyph
		@return {Array[Path2D]}
		**/
		_glyphPaths: function(ch, size) {
			var ctx = this._context;
			var font = this._font;

			var glyph = _getGlyph(this._font, ch);

			ctx.save();
			var scale = size / font.fontFace.unitsPerEm;

            ctx.translate(0, size);
            ctx.scale(scale, -scale);
            
            glyph.render(ctx);
            
            var paths = ctx.paths;
            
            ctx.paths = [];            
			ctx.restore();

			return paths;
		}
	};
})();

/**
Creates an object that represents a SVG font.
@class Font
@constructor
@param {String} font The content of a SVG font file.
@param {Number} [size=25] The top right point of the 
@since 1.16.0
**/
var Font = function(font, size) {

	/**
    Gets or sets the font size, which determine the size of text generated by the font.
    @property {Number} size The size of a font, which is the full height of a character.
    @default 25
    **/
	this.size = (size || 25);

	/**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @private 
    @property {_SvgFont} _impl
    **/
	Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _SvgFont(font)
    });
};

Font.prototype = {

	/**
    Gets the horizontal advance after rendering a glyph.
    @method glyphAdvance
    @param {String} ch A character corresponds to the glyph.
    @return {Number}
    **/
	glyphAdvance: function(ch) {
		if (typeof ch !== 'string' || ch.length !== 1) {
			return undefined;
		}
		return this._impl._glyphAdvance(ch, this.size);
	},

	/**
	Gets the paths of a glyph as an array of Path2D objects.
	@method glyphPaths
	@param {String} ch A character corresponds to the glyph.
	@return {Array[Path2D]}
	**/
	glyphPaths: function(ch) {
		if (typeof ch !== 'string' || ch.length !== 1) {
			return undefined;
		}
		return this._impl._glyphPaths(ch, this.size);
	}
};

initializeObjectMethods(Font, 'Font');

/*
 * Export it for public use
 */
Library.exports.Font = Font;
//shapegenerator.js
/**
Describes the configuration that a Shape Generator can supply for curating the standalone experience.
@json ShapeGeneratorConfigurationJSON
@since 1.4.0
@see IShapeGenerator#configuration
**/

    /**
    A single top-level group that describes the layout of the presentation for the shape generator.
    @property layout
    @type LayoutGroupJSON
    @optional
    **/

/**
This interface describes the different functions that a library that supports shape generation can export.
Since these are all reserved keywords, a developer only need declare members with this name in their library.
The interface is quite flexible, allowing a developer to choose one of 3 different techniques for implementing
a shape generator:

- Synchronous 
    - {IShapeGeneratorExporter#params} 
    - {IShapeGeneratorExporter#process}
- Asynchronous 
    - {IShapeGeneratorExporter#shapeGeneratorDefaults} 
    - {IShapeGeneratorExporter#shapeGeneratorEvaluate}
- Object Oriented 
    - {IShapeGeneratorExporter#shapeGenerator}


@markdown
@interface IShapeGeneratorExporter
@since 1.0.0
**/

    /**
    Declares a set of parameters that users can interact with and modify.  This member is preceded by {IShapeGeneratorExporter#shapeGeneratorDefaults} or {IShapeGeneratorExporter#shapeGenerator}.
    @since 1.0.0
    @property params
    @type Array[ParameterJSON*]
    @optional
    @see IShapeGeneratorExporter#shapeGeneratorDefaults
    @see IShapeGeneratorExporter#shapeGenerator
    **/

    /**
    A synchronous method that should compute geometry from a set of user-defined parameters.  This method is preceded by {IShapeGeneratorExporter#shapeGeneratorEvaluate} or {IShapeGeneratorExporter#shapeGenerator}.
    @since 1.0.0
    @method process
    @param {Object[String,Object]} parameters A Key-Value dictionary that contains the parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
    @return {Solid3D}
    @optional
    @see IShapeGeneratorExporter#shapeGeneratorEvaluate
    @see IShapeGeneratorExporter#shapeGenerator
    **/

    /**
    An asynchronous version of {IShapeGeneratorExporter#params}.  This method takes higher precedent than {IShapeGeneratorExporter#params} but is preceded by {IShapeGeneratorExporter#shapeGenerator}.
    @since 1.1.0
    @method shapeGeneratorDefaults
    @param {Function(Array[Object])} callback A callback that's invoked with information about what parameters are available.
    @optional
    @async
    @see IShapeGeneratorExporter#shapeGenerator
    @see IShapeGeneratorExporter#params

    **/

    /**
    An asynchronous version of {IShapeGeneratorExporter#process}.  This method takes higher precedent than {IShapeGeneratorExporter#process} but is preceded by {IShapeGeneratorExporter#shapeGenerator}.
    @since 1.1.0
    @method shapeGeneratorEvaluate
    @param {Object[String,Object]} parameters A Key-Value dictionary that contains the parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
    @param {Function(Solid3D)} callback A callback function that accepts a single {Solid3D} as an argument.
    @optional
    @async
    @see IShapeGeneratorExporter#shapeGenerator
    @see IShapeGeneratorExporter#process
    **/

    /**
    Implementing this function takes higher precedent over the following members:

    - {IShapeGeneratorExporter#params}
    - {IShapeGeneratorExporter#process}
    - {IShapeGeneratorExporter#shapeGeneratorDefaults}
    - {IShapeGeneratorExporter#shapeGeneratorEvaluate}

    If this method is not implemented by the developer, it will be automatically implemented by the platform for the developer and it will wrap the other methods to standardize the entry points.
    @since 1.4.0
    @method shapeGenerator
    @return {IShapeGenerator}

    @optional
    @markdown
    **/

/**
A Shape Generator is an object that can generate geometry from user-supplied parameters.
Shape Generators are assigned to shapes via the {ShapeJSON#geom} member.
@interface IShapeGenerator
@since 1.4.0
**/

    /**
    Allows the Shape Generator to describe the parameters and their default values asynchronously.
    If this is not implemented, then no parameters will be shown to the user.  In earlier versions
    of the Autodesk Creative Platform this was achieved by either assigning a variable named <code>params</code>
    or by implementation a function called <code>shapeGeneratorDefaults</code>.
    @method parameters
    @param {Function(Array[ParameterJSON*])} callback
    @async
    @optional
    **/

    /**
    Allows the Shape Generator to curate the presets for the shape a bit better.  For right now
    only a single preset is used, even if multiple presets are specified.  In the future multiple
    presets may be allowed and the schema may be updated to permit more flexibility.
    @method presets
    @param {Function(Array[Object])} callback A callback that's invoked with information about what parameters are available.
    @async
    @optional
    @experimental
    **/

    /**
    Allows the shape generator to evaluate the user-defined parameters then generate a {Solid3D}.  This function is called every time the parameters are changed.  
    Beware that the results are cached for each unique set of parameter combinations, so if the Shape Generator uses any random number generation, it must be
    a repeatable random number to ensure consistency across various evaluations.  In earlier versions of the Autodesk Creative Platform this was achieved by 
    implementing a synchronous function called <code>process</code> or an asynchronous function called <code>shapeGeneratorEvaluate</code>.
    @method evaluate
    @param {Object[String,Object]} parameters A Key-Value dictionary that contains the parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
    @param {Function(Solid3D)} callback A callback function that accepts a single {Solid3D} as an argument.
    @async
    @required
    **/

    /**
    Allows the shape generator to evaluate the parameters then generate a {Solid3D} for preview purposes.  Sometimes there are some shortcuts that can be taken
    for preview purposes that cannot be taken for the final results in {IShapeGenerator#evaluate}.  For example, for previewing sometimes it's not necessary
    to perform boolean or CSG operations on multiple meshes, but for the final result that may need to be done.
    @method preview
    @param {Object[String,Object]} parameters A Key-Value dictionary that contains the parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
    @param {Function(Solid3D|Array[Solid3D*])} callback A callback function that accepts a single {Solid3D} or an {Array[Solid3D*]} as an argument.
    @async
    @optional
    @experimental
    **/

    /**
    Allows the shape generator to evaluate the parameters for validity, and respond with information about the validation.  This function is only called when a parameter is modified that has
    the {ParameterJSON#validate} field set to <code>true</code> or if the client implements {IShapeGenerator#configuration} and the configuration contains a {LayoutGroupMapJSON} element 
    which the user happens to change.
    @method validate
    @param {Object} args
      @param {Object} args.changed Information about what has changed to trigger this validation.
        @param {Object[String,Object]} [args.changed.parameters] A Key-Value dictionary that contains keys for each parameter that changed, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
        @param {Object[String,String]} [args.changed.maps] A Key-Value dictionary that contains the keys for the maps that changed.  The key is {LayoutGroupJSON#id} and the value is the currently selected map value {MapKeyJSON#color}.
      @param {Object[String,Object]} args.parameters A Key-Value dictionary that contains the parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
      @param {Object[String,String]} [args.maps] A Key-Value dictionary that contains the currently selected color(s) on the image maps.  The key is {LayoutGroupJSON#id} and the value is the currently selected map value {MapKeyJSON#color}.
    @param {Function(Array[ParameterJSON*])} callback A callback function that allows an array of {ParameterJSON} objects to be returned, such that only the subset of parameters and parameter fields that are affected need to be returned.
    @async
    @optional
    @since 1.9.0
    **/

    /**
    Allows the shape generator to specify a curated viewing experience for standalone experience when downloading a disconnected version of the viewer.
    @method configuration
    @param {Function(ShapeGeneratorConfigurationJSON)} callback A callback that should be invoked with the configuration.
    @async
    @optional
    @experimental
    **/

    /**
    A Shape Generator can present randomization buttons to a user by including {LayoutGroupItemRandomizerJSON} sections in the {ShapeGeneratorConfigurationJSON} returned by {IShapeGenerator#configuration}.  
    If this option is included, then the shape generator needs to implement a method for generating the random values for the various parameters, since there could be rules that govern how they relate to each other.
    @method randomize
    @param {Object} args Information about what needs to be randomized
      @param {RandomizerConfigurationJSON} args.config The client defined randomization, in case there are multiple, that was defined on {LayoutGroupItemRandomizerJSON#randomizer}.
      @param {Object[String,Object]} args.parameters A Key-Value dictionary that contains the current parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
    @param {Function(Object[String,Object])} callback A callback function that accepts a key-value dictionary that contains the random parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the random value of the parameter.
    @async
    @optional
    @since 1.9.0
    **/

/**
This class is a layer between the developer's implementation of {IShapeGenerator} and the application.  
It provides some input and output validation, and handling the deserialization of JSON to objects like {Matrix3D}, {Sketch2D}, {Runtime.File}, etc.
@class ShapeGeneratorProxy
@private
**/
function ShapeGeneratorProxy( original ) {
    var methods = ['parameters', 'presets', 'evaluate', 'preview', 'validate', 'configuration', 'randomize'];
    BaseProxy.call(this, original, methods);
};

ShapeGeneratorProxy.prototype = new BaseProxy();
ShapeGeneratorProxy.prototype._evaluate = function(parameters, callback) {
    var original = this._original;
    this._unpackParameters(parameters, function(unpackedParams) {
        original.evaluate(parameters, callback);
    });
};

Environment.setVariable(['proxies', 'shapeGenerator'], function(original) {
    // This is a very subtle piece of code that's extremely important.
    // When the shape generator is executed on the client side in tinkercad
    // we don't want to create a new proxy on each mouse move because that
    // would require that we re-fetch the parameters each time which may
    // result in a network request for a resource.  So we need to cache
    // the original proxy on the shape generator and then use it for the
    // future calls so that the proxy can cache information.  This doesn't
    // prevent server side executions or client side executions from 
    // still causing a resource fetch on the first call to the shape 
    // generator parameters, but for now that is less obvious.  In the
    // future we may want to offer clients an optimized set of methods
    // so that we can get the parameter definitions without the default
    // values to make it more efficient.
    if (original.__proxy) {
        return original.__proxy;
    } else {
        var proxy = new ShapeGeneratorProxy(original);
        original.__proxy = proxy;
        return proxy;
    }
});

initializeObjectMethods(ShapeGeneratorProxy, 'ShapeGeneratorProxy');
//shapeconfigurator.js
/**
Describes the configuration that a Shape Configurator can supply for curating the standalone experience.
@json ShapeConfiguratorConfigurationJSON
@see IShapeConfigurator#configuration
@proposed
**/

    /**
    A single top-level group that describes the layout of the presentation for the Shape Configurator.
    @property layout
    @type LayoutGroupJSON
    @optional
    **/

/**
This interface describes the different functions that a library that supports shape configuration can export.
@markdown
@interface IShapeConfiguratorExporter
@proposed
**/

    /**
    Returns an instance of the Shape Configurator defined in the library.
    @method shapeConfigurator
    @return {IShapeConfigurator}
    @optional
    @markdown
    **/

/**
A Shape Configurator is an object that can generate and update document structure from user-supplied parameters.
Shape Configurators are assigned to shapes via the {ShapeJSON#conf} member.
@interface IShapeConfigurator
@proposed
**/

    /**
    Allows the Shape Configurator a way to specify what the default shape structure is, so that the initial
    state is available when dragging and dropping components from the gallery.
    @method shape
    @param {Function(Shape)} callback
    @async
    @required
    **/

    /**
    Allows the Shape Configurator to describe the parameters and their default values asynchronously.
    @method parameters
    @param {Function(Array[ParameterJSON*])} callback
    @async
    @required
    **/

    /**
    Allows the Shape Configurator to curate the presets for the shape a bit better.  For right now
    only a single preset is used, even if multiple presets are specified.  In the future multiple
    presets may be allowed and the schema may be updated to permit more flexibility.
    @method presets
    @param {Function(Array[Object])} callback A callback that's invoked with information about what parameters are available.
    @async
    @optional
    @experimental
    **/

    /**
    Allows the shape Configurator to evaluate the user-defined parameters then generate a {Shape}.  This function is called every time the parameters are changed.  
    Beware that the results are cached for each unique set of parameter combinations, so if the Shape Configurator uses any random number generation, it must be
    a repeatable random number to ensure consistency across various evaluations.
    @method evaluate
    @param {Object} context Contextual information about the request
      @param {Shape} context.shape The shape that the configurator is applied to and its current state.
      @param {Object[String,Object]} context.parameters A Key-Value dictionary that contains the parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
    @param {Function(Shape)} callback A callback function that accepts a single {Shape} as an argument.
    @async
    @required
    **/

    /**
    Allows the shape Configurator to evaluate the parameters for validity, and respond with information about the validation.  This function is only called when a parameter is modified that has
    the {ParameterJSON#validate} field set to <code>true</code> or if the client implements {IShapeConfigurator#configuration} and the configuration contains a {LayoutGroupMapJSON} element 
    which the user happens to change.
    @method validate
    @param {Object} args
      @param {Object} args.changed Information about what has changed to trigger this validation.
        @param {Object[String,Object]} [args.changed.parameters] A Key-Value dictionary that contains keys for each parameter that changed, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
        @param {Object[String,String]} [args.changed.maps] A Key-Value dictionary that contains the keys for the maps that changed.  The key is {LayoutGroupJSON#id} and the value is the currently selected map value {MapKeyJSON#color}.
      @param {Object[String,Object]} args.parameters A Key-Value dictionary that contains the parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
      @param {Object[String,String]} [args.maps] A Key-Value dictionary that contains the currently selected color(s) on the image maps.  The key is {LayoutGroupJSON#id} and the value is the currently selected map value {MapKeyJSON#color}.
    @param {Function(Array[ParameterJSON*])} callback A callback function that allows an array of {ParameterJSON} objects to be returned, such that only the subset of parameters and parameter fields that are affected need to be returned.
    @async
    @optional
    **/

    /**
    Allows the Shape Configurator to specify a curated viewing experience for standalone experience when downloading a disconnected version of the viewer.
    @method configuration
    @param {Function(ShapeConfiguratorConfigurationJSON)} callback A callback that should be invoked with the configuration.
    @async
    @optional
    @experimental
    **/

    /**
    A Shape Configurator can present randomization buttons to a user by including {LayoutGroupItemRandomizerJSON} sections in the {ShapeGeneratorConfigurationJSON} returned by {IShapeConfigurator#configuration}.  
    If this option is included, then the Shape Configurator needs to implement a method for generating the random values for the various parameters, since there could be rules that govern how they relate to each other.
    @method randomize
    @param {Object} args Information about what needs to be randomized
      @param {RandomizerConfigurationJSON} args.config The client defined randomization, in case there are multiple, that was defined on {LayoutGroupItemRandomizerJSON#randomizer}.
      @param {Object[String,Object]} args.parameters A Key-Value dictionary that contains the current parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
    @param {Function(Object[String,Object])} callback A callback function that accepts a key-value dictionary that contains the random parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the random value of the parameter.
    @async
    @optional
    **/
/**
This class is a layer between the developer's implementation of {IShapeConfigurator} and the application.  
It provides some input and output validation, and handling the deserialization of JSON to objects like {Matrix3D}, {Sketch2D}, {Runtime.File}, {Shape}, etc.
@class ShapeConfiguratorProxy
@private
**/
function ShapeConfiguratorProxy( original ) {
    var methods = ['parameters', 'presets', 'evaluate', 'validate', 'configuration', 'randomize', 'shape'];
    BaseProxy.call(this, original, methods);
};

ShapeConfiguratorProxy.prototype = new BaseProxy();
ShapeConfiguratorProxy.prototype._evaluate = function(context, callback) {
    // unpack shape
    if(!(context.shape instanceof Shape)){
        if (typeof context.shape === "string"){
            context.shape = new Shape(JSON.parse(context.shape));
        }
        else{
            context.shape = new Shape(context.shape);
        }
    }

    var original = this._original;
    this._unpackParameters(context.params, function(unpackedParams) {
        context.params = unpackedParams;
        original.evaluate(context, callback);
    });
};



Environment.setVariable(['proxies', 'shapeConfigurator'], function(original) {
    // This is a very subtle piece of code that's extremely important.
    // When the shape generator is executed on the client side in tinkercad
    // we don't want to create a new proxy on each mouse move because that
    // would require that we re-fetch the parameters each time which may
    // result in a network request for a resource.  So we need to cache
    // the original proxy on the shape generator and then use it for the
    // future calls so that the proxy can cache information.  This doesn't
    // prevent server side executions or client side executions from 
    // still causing a resource fetch on the first call to the shape 
    // generator parameters, but for now that is less obvious.  In the
    // future we may want to offer clients an optimized set of methods
    // so that we can get the parameter definitions without the default
    // values to make it more efficient.
    if (original.__proxy) {
        return original.__proxy;
    } else {
        var proxy = new ShapeConfiguratorProxy(original);
        original.__proxy = proxy;
        return proxy;
    }
});

initializeObjectMethods(ShapeConfiguratorProxy, 'ShapeConfiguratorProxy');
//shapemodifier.js
/**
This interface describes the different functions that a library that supports Shape Modifiers can export.
@markdown
@interface IShapeModifierExporter
@proposed
**/

    /**
    Returns an instance of the Shape Modifier defined in the library.
    @method shapeModifier
    @return {IShapeModifier}
    @optional
    @markdown
    **/

/**
A Shape Modifier is an object that can modify the geometry of a shape.
Shape Modifiers are assigned to shapes via the {ShapeJSON#mods} member.
@interface IShapeModifier
@proposed
**/

    /**
    Allows the Shape Modifier to describe the parameters and their default values asynchronously.
    @method parameters
    @param {Function(Array[ParameterJSON*])} callback
    @async
    @required
    **/

    /**
    Allows the Shape Modifier to evaluate the user-defined parameters then generate a {Shape}.  This function is called every time the parameters are changed.  
    Beware that the results are cached for each unique set of parameter combinations, so if the Shape Modifier uses any random number generation, it must be
    a repeatable random number to ensure consistency across various evaluations.
    @method evaluate
    @param {Object} context Contextual information about the request
      @param {Array[Instance]} context.instances An array of instances.
      @param {Object[String,Object]} context.parameters A Key-Value dictionary that contains the parameter values, where the key is equivalent to {ParameterJSON#id} and the value is the value of the parameter.
    @param {Function(Array[Instance])} callback A callback function that accepts an array of instances.
    @async
    @required
    **/

/**
This class is a layer between the developer's implementation of {IShapeModifier} and the application.  
It provides some input and output validation, and handling the deserialization of JSON to objects like {Matrix3D}, {Instance}, {Mesh3D}, etc.
@class ShapeModifierProxy
@private
**/
function ShapeModifierProxy( original ) {
    var members = ['parameters', 'evaluate'];
    BaseProxy.call(this, original, members);
};


ShapeModifierProxy.prototype = new BaseProxy();
ShapeModifierProxy.prototype._evaluate = function(context, callback) {

    //Unpack Instances
    try {
        var instanceObjects = [];
        var instances = context.instances;
        instances.forEach(function(instanceJson){ 
            var inst;
            // unpack Instance
            if(instanceJson instanceof Instance){
                inst = instanceJson;  
            } else {
                var tm, mesh;
                if (typeof instanceJson === "string"){
                    instanceJson = JSON.parse(instanceJson);
                }
                var tm = new Matrix3D(instanceJson['localToParent']);
                var mesh = new Mesh3D();
                mesh.indexedTriangles(instanceJson['mesh']['vertices'], instanceJson['mesh']['triangles']);

                inst = new Instance(tm, mesh);
                var keys = Object.keys(instanceJson);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if(key !== 'mesh' && key !== 'localToParent'){
                        inst[key] = instanceJson[key];
                    }
                }
            }
            instanceObjects.push(inst);
        });
        context.instances.length = 0;
        context.instances = instanceObjects;
    } catch (e) {
        Plugin.warning("A problem occurred while deserializing context.instances");
    }

    var original = this._original;
    this._unpackParameters(context.params, function(unpackedParams) {
        context.params = unpackedParams;
        original.evaluate(context, callback);
    });

};

Environment.setVariable(['proxies', 'shapeModifier'], function(original) {
    // This is a very subtle piece of code that's extremely important.
    // When the shape modifier is executed on the client side in tinkercad
    // we don't want to create a new proxy on each mouse move because that
    // would require that we re-fetch the parameters each time which may
    // result in a network request for a resource.  So we need to cache
    // the original proxy on the shape modifier and then use it for the
    // future calls so that the proxy can cache information.  This doesn't
    // prevent server side executions or client side executions from 
    // still causing a resource fetch on the first call to the shape 
    // modifier parameters, but for now that is less obvious.  In the
    // future we may want to offer clients an optimized set of methods
    // so that we can get the parameter definitions without the default
    // values to make it more efficient.
    if (original.__proxy) {
        return original.__proxy;
    } else {
        var proxy = new ShapeModifierProxy(original);
        original.__proxy = proxy;
        return proxy;
    }
});
initializeObjectMethods(ShapeModifierProxy, 'ShapeModifierProxy');
//instance.js
/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _Instance
@private
**/
function _Instance(localToParent, mesh) {
	 /**
    The transformation matrix that describes the transformation of the geometry from local space to parent space.
    @private
    @property _localToParent
    @type Matrix3D
    **/
	this._localToParent = localToParent;

	/**
	If the instance was constructed from a {Mesh3D} then this member allows access to the mesh.
	Clients should not assume this member exists so that in the future if there are other geometry
	types they can be set as different members.
	@private
	@property _mesh
	@type Mesh3D
	@readonly
	@optional
	**/
	this._mesh = mesh;
};


/**
An object that describes an instance of some particular geometry.
@class Instance
@param {Matrix3D} localToParent The transformation of the instance, which will become the localToParent member.
@param {Mesh3D} mesh The geometry that has been instanced.  In the future if other geometry types are supported, they would be assigned to different members.  For now this is assigned to the mesh member.
@constructor
@proposed
**/
    
function Instance(localToParent, mesh) {

	/**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @private 
    @property {_Insance} _impl
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        value: new _Instance(localToParent, mesh)  
    });

};

Instance.prototype = {
	/**
    Returns the JSON representation of the object that can be serialized.  
    @method toJSON
    @return {JSON}
    **/
    toJSON: function() {
        var instanceJSON = {};
        instanceJSON['localToParent'] = this._impl._localToParent.toJSON();
        instanceJSON['mesh'] = this._impl._mesh.toJSON();
        return instanceJSON;
    }
};

/**
The transformation matrix that describes the transformation of the geometry from local space to parent space.
@property localToParent
@type Matrix3D
**/
Object.defineProperty(Instance.prototype, 'localToParent', {	
	set: function(value) {
	  this._impl._localToParent = value;
	},
	get: function() {
	  return this._impl._localToParent;
	},
	enumerable : true
});

/**
If the instance was constructed from a {Mesh3D} then this member allows access to the mesh.
Clients should not assume this member exists so that in the future if there are other geometry
types they can be set as different members.
@property mesh
@type Mesh3D
@readonly
@optional
**/
Object.defineProperty(Instance.prototype, 'mesh', {
    get : function() {
        return this._impl._mesh;
    },
    enumerable : true
});

initializeObjectMethods(Instance, 'Instance');

Library.exports.Instance = Instance;
//topic-documentation.js
/**
{@Tokens:Off}
The documentation system uses industry standard <a href="http://yui.github.io/yuidoc/">YUIDoc</a>, 
along with a few proprietary extensions.  What's even better is that developers can take full
advantage of this system when developing your libraries, to help document contributions in manner consistent with
the Creative Platform.  Creative Platform Libraries are documented with 4 basic high-level concepts, to help
developers get a high-level view of the library:
<style>
td {
	vertical-align: baseline;
}
</style>

<ul>
	<li><b>Topics</b><p>Articles that provide a conceptual overviews or background information that may be needed to understand some of the technical aspects.  
	These can also be used to provide getting started guides, tutorials, etc.</p></li>
	<li><b>Statics</b><p>Objects that are more often than not singletons, and accessed statically and do not require instantiation.</p></li>
	<li><b>Classes</b><p>Classes that are created directly by the client, or accessed via properties and methods of other objects.</p></li>
	<li><b>Enums</b><p>Enumerations that the library provides.</p></li>
</ul>

<h1>Comment Tags</h1>
The following are the <a href="http://yui.github.io/yuidoc/">YUIDoc</a> tags that are currently supported in the
HTML presentation for documentation.  Other tags from YUIDocs can be used but are not presented at this time.  
In addition there are several additional tags that are proprietary with special meaning, as indicated below:
<table>
	<tr>
		<td style="width: 200px;"><ul>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#async">&#64;async</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#chainable">&#64;chainable</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#class">&#64;class</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#const">&#64;const</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#constructor">&#64;constructor</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#default">&#64;default</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#deprecated">&#64;deprecated</a></li>
			<li><a href="#example-opensource">&#64;derivative</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-opensource">&#64;downloadurl</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-enum">&#64;enum</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#example">&#64;example</a></li>
			<li><a href="#example-experimental">&#64;experimental</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
		</ul></td><td style="width: 200px;"><ul>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#extends">&#64;extends</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#for">&#64;for</a></li>
			<li><a href="#example-interface">&#64;implements</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-interface">&#64;interface</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-markdown">&#64;markdown</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-json">&#64;json</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-opensource">&#64;licensetext</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-opensource">&#64;licenseurl</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#module">&#64;module</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#optional">&#64;optional</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#param">&#64;param</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#private">&#64;private</a></li>
		</ul></td><td style="width: 200px;"><ul>
			<li><a href="#example-promise">&#64;progress</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#property">&#64;property</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#protected">&#64;protected</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#public">&#64;public</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#readonly">&#64;readonly</a></li>
			<li><a href="#example-promise">&#64;rejected</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-version">&#64;released</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#return">&#64;return</a> | <span class="parenttags">Enhanced Tag</span></li>
			<li><a href="#example-promise">&#64;resolved</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#required">&#64;required</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#see">&#64;see</a></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#since">&#64;since</a></li>
		</ul></td><td style="width: 200px;"><ul>
			<li><a href="#example-opensource">&#64;source</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#static">&#64;static</a></li>
			<li><a href="#example-suppress">&#64;suppress</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-opensource">&#64;symbols</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#throws">&#64;throws</a></li>
			<li><a href="#example-topic">&#64;topic</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#type">&#64;type</a></li>
			<li><a href="#example-unlisted">&#64;unlisted</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="http://yui.github.io/yuidoc/syntax/index.html#value">&#64;value</a></li>
			<li><a href="#example-version">&#64;version</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
			<li><a href="#example-opensource">&#64;websiteurl</a>&nbsp;|&nbsp;<span class="parenttags">Proprietary Tag</span></li>
		</ul></td>
	</tr>
</table>

<h1 id="symboltags">Symbol Tags</h1>
When documenting property or argument types, developers can provide direct links to symbols in these scenarios using braces { ... } with the symbol identifier contained within them.  
These symbol tags are also processed in descriptions of classes, topics and library overviews.
<table><tr><td style="width: 400px;"><ul>
<li>Classes, Enums, or Methods within library:<br/><pre class="prettyprint">&#47;**
&#64;param {ClassName}
&#64;see {ClassName#memberName}
*&#47;</pre></li>
<li>Classes, Enums, or Methods within referenced library:<br/><pre class="prettyprint">&#47;**
&#64;param {LibraryAlias.ClassName}
&#64;see {LibraryAlias.ClassName#memberName}
*&#47;</pre></li>
<li>JavaScript Objects (See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/">Global Objects</a>):<br/><pre class="prettyprint">&#47;**
&#64;param {JavaScriptObjectName}
*&#47;</pre></li>
</ul></td><td style="width: 400px;"><li>An Array of Classes:<pre class="prettyprint">&#47;**
&#64;param {Array[Number]}
&#64;param {Array[Object|ClassName]}
*&#47;</pre></li>
<li>Maps of Objects:<br/><pre class="prettyprint">&#47;**
&#64;param {Object[String, Number]}
&#64;param {Object[Number, LibraryAlias.ClassName]}
*&#47;</pre></li>
<li>Variable number of arguments:<br/><pre class="prettyprint">&#47;**
&#64;param {Function(String*)}
&#64;param {Number*}
*&#47;</pre></li>
</ul>
</td></table>

The set of JavaScript objects that are internally recognized and get links automatically provided are listed below (case sensitive):

<table>
	<tr>
		<td style="width: 200px;"><ul>
			<li>{Array}</li>
			<li>{ArrayBuffer}</li>
			<li>{Boolean}</li>
			<li>{DataView}</li>
			<li>{Date}</li>
			<li>{decodeURI}</li>
			<li>{decodeURIComponent}</li>
			<li>{encodeURI}</li>
			<li>{encodeURIComponent}</li>
			<li>{Error}</li>
			<li>{eval}</li>
		</ul></td><td style="width: 200px;"><ul>
			<li>{EvalError}</li>
			<li>{Float32Array}</li>
			<li>{Float64Array}</li>
			<li>{Function}</li>
			<li>{HTMLElement}</li>
			<li>{Infinity}</li>
			<li>{Int16Array}</li>
			<li>{Int32Array}</li>
			<li>{Int8Array}</li>
			<li>{isFinite}</li>
			<li>{isNaN}</li>
		</ul></td><td style="width: 200px;"><ul>
			<li>{JSON}</li>
			<li>{Math}</li>
			<li>{NaN}</li>
			<li>{Number}</li>
			<li>{Object}</li>
			<li>{parseFloat}</li>
			<li>{parseInt}</li>
			<li>{Promise}</li>
			<li>{RangeError}</li>
			<li>{ReferenceError}</li>
			<li>{RegExp}</li>
		</ul></td><td style="width: 200px;"><ul>
			<li>{String}</li>
			<li>{SyntaxError}</li>
			<li>{TypeError}</li>
			<li>{Uint16Array}</li>
			<li>{Uint32Array}</li>
			<li>{Uint8Array}</li>
			<li>{Uint8ClampedArray}</li>
			<li>{undefined}</li>
			<li>{Window}</li>
			<li>{$.Deferred}</li>
		</ul></td>
	</tr>
</table>

<h1>Additional Formatting</h1>
In addition to the tags above which can be used to link directly to types, there are some additional tags
that are processed when outputting text from a &#64;topic block, library introduction or class description.  
All of these are case-sensitive with no extra spacing allowed, to ensure optimal performance while parsing:
<ul>
	<li><b>HTML</b><p>Full HTML is allowed, so just about anything is possible.</p></li>
	<li><b>Images</b><p>Inserting images, by referring to the name of resource using the built-in <code>{&#64;ResourceUrl:<name>}</code> tag<br/><pre class="prettyprint lang-html">
&lt;img src="{&#64;ResourceUrl:illustration.jpg}" style="width: 50px; height: 100px;"/&gt;</pre></p></li>
	<li><b>Equations</b><p>Inserting equations generated by LaTeX editors such as <a href="http://www.codecogs.com/latex/eqneditor.php">CODECOGS</a>, by adding the image as a resource and referring to it using the <code>{&#64;ResourceUrl}</code> tag<p>{@Tokens:On}<img src="{@ResourceUrl:matrix3.gif}"/>{@Tokens:Off}</p></li>
	<li><b>Code Examples</b><p>Inserting code snippets via <a href="http://google-code-prettify.googlecode.com/svn/trunk/README.html">Prettify</a>.  Please refer to the Prettify documentation for to specify the language (i.e. JavaScript, HTML, etc.).<br/><pre class="prettyprint lang-html">
&lt;pre class="prettyprint"&gt;
// Code Snippets Go Here
var foo = 1.0;
var bar = 2.0;
var zoo = foo / bar;
&lt;/pre&gt;
</pre></li>
	<li><b>Advanced</b><p>Disabling or Re-enabling Formatting<br/><pre class="prettyprint">&#47;**
{&#64;Tokens:Off}
{Mesh3D} // Will print as plain text, rather than a link to Mesh3D
{&#64;Tokens:On}
*&#47;</pre></p></li>
</ul>

<h1>Example Documentation Templates</h1>
The following templates are provided as conveniences for developers to help them get started documenting their code.
The example templates below can be embellished with additional tags as well, but the templates below are considered 
the best practice for the bare minimum.

<table><tr><td><ul>

<li id="example-class"><b>Class Template</b></br>
<pre class="prettyprint">
&#47;**
A description of the class goes here.  
This can be HTML and Markdown.
&#64;since 1.0
&#64;class ClassName
**&#47;
</pre></li>

<li id="example-return"><b>Return Object With Properties</b><br/>
<pre class="prettyprint">
&#47;**
This method returns an object with several properties.
&#64;method overlappingCurves
&#64;return {Array[Object]} Array of objects with these properties:
&#64;return {Point2D} result.intersection Position of overlap.
&#64;return {Curve2D} result.firstCurve The first curve. 
&#64;return {Curve2D} result.secondCurve The second curve.
**&#47;
</pre></li>

<li id="example-experimental"><b>Experimental Template</b></h2>
<pre class="prettyprint">
&#47;**
Indicates a class, static, interface, enum, method or property is
experimental and not intended for use yet.
&#64;since 1.0
&#64;method methodName 
&#64;experimental
**&#47;
</pre></li>

<li id="example-markdown"><b>Markdown Template</b></h2>
<pre class="prettyprint">
&#47;**
Using the markdown tag allows the author to:
# Selectively choose which descriptions get processed as markdown
# Avoid unintended consequences on other blocks which may be HTML
# Take advantage of one of the most popular forms of documentation
&#64;since 1.0
&#64;method methodName 
&#64;markdown
**&#47;
</pre></li>

<li id="example-topic"><b>Topic Template</b><br/>
<pre class="prettyprint">
&#47;**
A description of the topic goes here.  
This can be HTML and Markdown.
&#64;since 1.0
&#64;topic Topic Name
**&#47;
</pre></li>

<li id="example-opensource"><b>Open Source / Attribution Template</b></h2>
<pre class="prettyprint">
&#47;**
A description of the open source library and why it's 
included can be listed here.  If the library is used
as-is with no modifications, then &#64;source identifies
the filename included without modifications.  If the 
library has been modified, then use &#64;derivative 
rather than &#64;source.
&#64;opensource Library r1.2.3
&#64;websiteurl https://library.com
&#64;downloadurl https://library.com/downloads/r1.2.3.min.js
&#64;licenseurl https://library.com/downloads/LICENSE
&#64;licensetext &lt;Full text...
...of the license&gt;
&#64;source r1.2.3.min.js
&#64;symbols TopLevelSymbols, AnotherTopLevelSymbol
**&#47;
</pre></li>

<li id="example-promise"><b>Promise Template</b></h2>
<pre class="prettyprint">
&#47;**
A method or property that returns a Promise or 
$.Deferred object can document the callback parameters 
for the Resolved, Rejected and Progress callbacks.  The 
type supplied after the promise tag is optional, but
provides additional info to consumers about the exact 
type of object returned.  The Resolved, Rejected and 
Progress tags are all optional.
&#64;method someMethod
&#64;promise $.Deferred
&#64;resolved Description for resolved callback.
&#64;param {Object} result The resulting object.
&#64;rejected Description for rejected callback.
&#64;param {Error} err Descriptive error info.
&#64;progress Description for progress callback.
&#64;param {Number} percent The percent complete.
&#64;param {String} status Status information.
**&#47;
</pre></li>

</ul></td><td><ul>

<li id="example-interface"><b>Interface Template</b><br/>
<pre class="prettyprint">
&#47;**
A description of the interface goes here.
This can be HTML and Markdown.
&#64;interface ShapeInterface
**&#47;

&#9;&#47;**
&#9;This is a member on the interface.
&#9;&#64;method size
&#9;&#64;return {Box3D}
&#9;**&#47;

&#47;**
This is an example of a class that implements it.
&#64;class Sphere
**&#47;

&#9;&#47;**
&#9;The description, return and parameters are 
&#9;automatically taken from inheritted member.
&#9;&#64;method size
&#9;&#64;implements ShapeInterface
&#9;**&#47;
</pre></li>

<li id="example-static"><b>Static Template</b><br/>
<pre class="prettyprint">
&#47;**
A description of the static class goes here.  
This can be HTML and Markdown.
&#64;since 1.0
&#64;class StaticName
&#64;static
**&#47;
</pre></li>

<li id="example-version"><b>Version Template</b></h2>
<pre class="prettyprint">
&#47;**
Allows the library developer to add notes about 
a particular version for a user.  The versions 
are sorted based on the released attribute which 
is an ISO formatted time, and should always be 
included.
&#64;version 1.20
&#64;released 2014-01-01T00:00:00Z
**&#47;
</pre></li>

<li id="example-json"><b>JSON Template</b><br/>
<pre class="prettyprint">
&#47;**
A description of the JSON object goes here.
This can be HTML and Markdown.
&#64;since 1.0
&#64;json IdentifierJSON
**&#47;
</pre></li>

<li id="example-enum"><b>Enum Template</b></h2>
<pre class="prettyprint">
&#47;**
A description of the enum goes here.  
This can be HTML and Markdown.
&#64;since 1.0
&#64;static
&#64;enum EnumName
**&#47;
</pre></li>

<li id="example-suppress"><b>Suppress Template</b></h2>
<pre class="prettyprint">
&#47;**
A derived class can suppress members that are
irrelevant using the suppress keyword with a 
&#64;extend BaseClass
&#64;class DerivedClass
&#64;suppress memberOne, memberTwo, memberThree
**&#47;
</pre></li>

<li id="example-unlisted"><b>Unlisted Template</b></h2>
<pre class="prettyprint">
&#47;**
An unlisted topic, class, static or enum will not
appear listed on the index page
&#64;since 1.0
&#64;topic Unlisted Topic Name
&#64;unlisted
**&#47;
</pre></li></ul></td></table>

<h1>Documentation Style Tips</h1>
To have really great consistent documentation, our internal developers try to follow the basic principles:
<ul>
<li><b>Topics</b><p>For larger libraries that have lots of interdependencies, the documentation added to  individual items often fails to illustrate the larger context.  Using <code>&#64;topic</code> tags to provide separate articles to users that provide a top-down introduction can be extremely helpful to helping users get started.</p></li>
<li><b>Headings</b><p>Use <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code> and <code>&lt;h3&gt;</code> to organize content in topics.  The <span class="ui-element">Return To Library Index</span> links are automatically added to all <code>&lt;h1&gt;</code> tags.</p></li>
<li><b>Descriptions</b><p>Provide meaningful descriptions for everything that engage and entertain the reader!</p></li>
<li><b>Example Code</b><p>Provide coding examples using <code>&lt;pre class="prettyprint"&gt;...&lt;/pre&gt;</code> with good comments.  When possible provide completely working samples that can be copied & pasted.</p></li>
<li><b>Stylize Code References</b><p>When referring to code in text, use  <code>&lt;code&gt;</code>  to make it clear to the reader that code is being referred to.</p></li> 
<li><b>Links</b><p>When referring to a class, method, static, etc, provide a direct hyperlink to the symbol using <a href="#symboltags">Symbol Tags</a> for convenience to the reader.</p></li>
<li><b>Keywords</b><p>Emphasizing keywords and terminology using the <code>&lt;em&gt;</code> tag to make it clear to the reader this is important or unique to what's being discussed.</p></li> 
<li><b>Illustrations</b><p>Try to include illustrations and images using the <code>{@ResourceUrl}</code> tag whenever possible.  Pictures are worth 1,000 words.</p></li>
<li><b>UI Elements</b><p>When referring to a User Interface element, you can create elements <span class="ui-element">Like This</span> by using the <code>ui-element</code> class:<pre class="prettyprint">&lt;span class="ui-element"&gt;Like This&lt;/span&gt;</pre></p></li>
<li><b>See Also</b><p>It can be extremely helpful to document where objects can be obtained from when they're non-instantiable, or where they are used.  We encourage liberal use of <code>&#64;see</code> tags.</p></li>
<li><b>Point Of View</b><p>Try to avoid the trap of First and Second Person point of view in documentation.  It's incredibly easy to use <i>'you'</i> or <i>'I'</i>, however alternatives should always be used.</p></li>
<li><b>Key Terminology</b><p>Terms such as the Autodesk Creative Platform, Shape Generators and Library should be used consistently and correctly.  Terminology such as Shape Script, 
has been retired because the term was overloaded with multiple meanings representing 1) An underlying technology, 2) A file a user edited and 3) An intelligent kind of shape in Tinkercad.</p></li>
</ul>

@topic How To Document Your Creative Platform Library
@unlisted
**/
//topic-introduction.js
/**

<img src="{@ResourceUrl:cluster.png}" style="float:right; padding:20px; margin-top:-40px;"/>

<p>The geometric modeling kernel, or geometry kernel, is a core component of any Computer Aided Design system. Tinkercad uses a custom in-house kernel called Gen6. The purpose of this document is to give an introduction to how Gen6 works to help you better work against the Script APIs.</p>

<p>Gen6 is very similar to other geometry kernels in that it operates on a geometry tree called the Design Tree. The input geometry to Gen6 can either be precise analytical geometry, also called boundary representations, or mesh data represented by triangles. The output can be a triangle mesh for viewing or special files designed to drive devices like 3D printers. A very distinctive feature of Gen6 is that it has been designed from the ground up to run in a server cluster utilizing thousands of CPU cores. In practice this means that Gen6 can perform computations which would take minutes or hours using other geometry kernels in just a few hundred milliseconds.</p>

<p>Gen6 is the sixth-generation production quality geometry kernel developed by Tinkercad Inc. Like its five predecessors Gen6 was built from scratch utilizing the knowledge learned from operating the previous kernels in production. The architecture and core algorithms of Gen6 finally satisfied the target performance envelope so a seventh generation is highly unlikely during the next decade; instead development will focus on improving Gen6.</p>

<h1>Design Tree</h1>

<p>Every design in Tinkercad is represented by a Design Tree where the nodes are Solids or Groups. Every solid is generated by a script that takes as input user parameters and optionally an external file. Scripts that only take user parameters are called Shape Generators, scripts that operate on external files are called Import Scripts.</p>

<p>A group is a container node that can hold either solids or other groups. The group places its children in two sets: the add set and the sub set. When Gen6 evaluates a group to determine what kind of solid it represents it does a few solid boolean operations. First Gen6 forms two new temporary solids by doing a union on all the shapes in the add and sub groups separately. Then Gen6 creates the final result by subtracting the sub solid from the add solid. The resulting solid is then used in further calculations.</p>

<p>Shape is a term used in the editor UI. From the perspective of the Gen6 and the Script API a shape can either be a solid or a group. When the editor user groups their selection together to create a new shape they are actually creating a group in Gen6.</p>

<h1>Scripts</h1>

<p>Tinkercad is extended by writing Scripts using the JavaScript language. The Script API provides a specification of what functions and libraries are available in the JavaScript environment. While all scripts are created and edited in the Tinkercad editor they don't actually execute in the browser. The scripts are uploaded from the editor client to Gen6 and executed in the server cluster. This is also why the JavaScript environment is very different from a typical browser environment, the server runtimes only expose a small necessary set of functions for each script.</p>

<p>The output from Shape and Import scripts is always a solid. Sometimes the solid is defined using analytical interfaces in the API such as Path2D combined with extrude. For other scripts the output is a mesh consisting of triangles. An integral feature of the internal solid representation in Gen6 is the ability to use this triangle mesh to always correctly represent a solid. The internal representation is unaffected by problems in the triangle mesh like holes or intersections. The algorithms are designed to mimic human perception so that the solids are as close to what a human observer would expect.</p>

<h1>Performance</h1>

<p>The Tinkercad Gen6 kernel has been built from the ground up to be a aggressively distributed kernel running in a dedicated server cluster. The primary focus has been on decreasing the rebuild time for a single Design Tree, when talking about scaling the numbers always refer to evaluating a single Design Tree. The architecture of Gen6 is designed to scale to tens of thousands of CPU cores. The current version of Gen6 running in production only has a handful of the planned distribution options enabled and scales to several hundred CPU cores. Gen6 obviously supports a large number of concurrent users so the actual cluster can be a lot larger to increase throughput.</p>

<p>The internals of Gen6 are implemented in Go and tightly optimized C. The script API has been carefully designed to allow scripts to be evaluated aggressively in parallel. The script API is also focused on handling higher level objects and leave the low level operations to the core Gen6 code.</p>

<p>When Gen6 is evaluating a Design Tree it will always externally behave as if the whole tree was evaluated from scratch. This includes re-running shape and import scripts. There are however a number of caches both in the editor client and server side that speed up some of the operations but also decrease network traffic between the client and the server cluster.</p>

<h1>Units and output precision</h1>

<p>The base unit for Gen6 is the millimeter or 1e-3m.  The editor user can display different units in the user interface but inside the kernel everything is handled as millimeters. All the coordinates and distances created by scripts are in millimeters, any conversion needs to be handled in the script itself.</p>

<p>A key concept in Gen6 is the output precision. Several output targets like 3D printers operate at a fixed precision and have limits on how much data they can accept from an outside source. Gen6 generates output data at a precision that is good enough to satisfy the printer but not any higher so as to limit output size. Output precision is handled automatically for scripts utilizing analytic ways of generating their solids (such as 2D paths combined with extrusion). Scripts utilizing the mesh interface need to manually adjust tessellation based on the error metric indicated in the API.</p>

@topic Tinkercad's Gen6 Geometry Kernel
@unlisted
**/
//topic-introduction2.js
/**
<p>Shape Generators are JavaScript programs that generate 3D geometry based on a set of visual inputs provided to the user.
A shape can be generated from 2D curves that are extruded, or by directly building a mesh.
The end result is a water-tight shape that can interact with other shapes in boolean operations.
Developers are free to use functionality provided by the Autodesk Core Library, or libraries developed by other members of the community.</p>

<h1>Curating Consistency</h1>
<img src="{@ResourceUrl:coordinate-system.png}" style="float:right; padding:20px; margin-top:-40px;"/>
<p>To ensure a consistent user experience, the default size of shapes produced by Shape Generators should be 20 &times; 20 &times; 20 millimeters, placed above the ground.  
Because each shape is different and it's not always possible to be 20 &times; 20 &times; 20 millimeters, at least one or two dimensions of the shape should be 20 millimeters.</p>
<p>For example, the shape's bounding box should not exceed (-10,-10,0) to (10,10,20).</p>

<h1 id="structural">Structural Prerequisites</h1> 
<p>There are 2 things developers need to provide in a Shape Generator:<p>
<ul>
<li><b>Parameter Declaration</b>&nbsp;|&nbsp;<span class="parenttags">Optional</span><p>A declaration of parameters that users can modify to affect the shape geometry.</p></li>
<li><b>Parameter Processing</b>&nbsp;|&nbsp;<span class="parenttags">Required</span><p>A function that generates the shape geometry from a user-supplied set of parameter values.</p></li>
</ul>

<h1 id="declaringparameters">Parameter Declaration</h1>
<img src="{@ResourceUrl:parameters.png}" style="float:right; border:1px solid black; margin: 5px;"/>
Shape Generators can declare parameters using one of two appraoches: 
<ol>
  <li>Synchronous</li>
  <li>Asynchronous</li>
</ol>
It's up to the developer to choose the approach based on the functionality that's required.  The Asynchronous model is typically only used when the parameters are more complicated
and require the use of some asynchronous functionality to prepare.  Users are encouraged to use the synchronous model when possible.  There 
are several different types of parameters that are supported, each has a number of configurable characteristics.  To learn more about the 
configurable options, please refer to the documentation for each of the parameter types:
<ol>
    <li><b>Angle</b><p>Refer to {AngleParameterJSON} for additional fields.</p></li>
    <li><b>Boolean</b><p>Refer to {BooleanParameterJSON} for additional fields.</p></li>
    <li><b>Real Value</b><p>Refer to {FloatParameterJSON} for additional fields.</p></li>
    <li><b>Integer Value</b><p>Refer to {IntegerParameterJSON} for additional fields.</p></li>
    <li><b>Length</b><p>Refer to {LengthParameterJSON} for additional fields.</p></li>
    <li><b>List</b><p>Refer to {ListParameterJSON} for additional fields.</p></li>
    <li><b>2D Sketch</b><p>Refer to {SketchParameterJSON} for additional fields.</p></li>
    <li><b>String</b><p>Refer to {StringParameterJSON} for additional fields.</p></li>
    <li><b>File</b><p>Refer to {FileParameterJSON} for additional fields.</p></li>
</ol>
Below are examples of how the parameters for a Shape Generator would be defined using the different techniques available:
<ul><li><b>Synchronous</b><p><pre class="prettyprint">// SVG Data For Default Extrusion Profile
// Wrapped in a function so Conversions.toSketch2DFromSVG(...) is 
// only executed when needed and not on each shape generation.
function defaultValue() {
    var svg = '&lt;?xml version="1.0" encoding="ISO-8859-1" standalone="no"?&gt;
               &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
                "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;
               &lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt;
               &lt;circle cx="0" cy="0" r="10" 
                stroke="black" stroke-width="2" fill="red" /&gt;
               &lt;/svg&gt;';
    var svgSketch = Conversions.toSketch2DFromSVG(svg);
    return svgSketch.toJSON();
}
params = [
  {
    "id": "sketch",
    "displayName": "Profile",
    "type": "sketch", 
    "default": defaultValue() 
  }
];</pre></li><li><b>Asynchronous</b><p><pre class="prettyprint">function shapeGeneratorDefaults(callback) {
  Library.resourceText('Circle.svg', function(resourceData) {
    var sketch2D = Conversions.toSketch2DFromSVG(resourceData);
    var params = [
      { 
        "id": "sketch", 
        "displayName": "Profile", 
        "type": "sketch", 
        "default": sketch2D.toJSON()
      }
    ];
    callback(params);
  });
}</pre></li></ul>

<h1 id="processingparameters">Parameter Processing</h1>
Shape Generators can choose to process parameters using one of two appraoches: 
<ol>
  <li>Synchronous</li>
  <li>Asynchronous</li>
</ol>
It's up to the developer to choose the approach based on the functionality that's required.
<table>
  <tr><td style="width: 400px;"><ul><li><b>Synchronous</b><p><pre class="prettyprint">function process(params) {

  var l = params['length'];
  var w = params['width'];
  var h = params['height'];

  var result = computeResult(l, w, h);
  return result;

}</pre></li></ul></td><td style="width: 400px;"><ul><li><b>Asynchronous</b><p><pre class="prettyprint">function shapeGeneratorEvaluate(params, callback) {

  var l = params['length'];
  var w = params['width'];
  var h = params['height'];

  var result = computeResult(l, w, h);
  callback(result)

}</pre></li></ul></td></tr>
</table>

<p>The <code>process()</code> or <code>shapeGeneratorEvaluate()</code> functions are mandatory for shape generators. For a script to be valid, these functions must produce a {Solid3D} object. Failure to produce 
a {Solid3D} will leave the script-generated shape in an error state.</p>
<p>The first argument is a key-value dictionary {Object[String,Object]} where the keys are a parameter <code>id</code>, and the values are the types defined by the parameter definitions.  If the asynchronous 
approach is used, the second argument is a callback {Function(Object)} that must be called with the results.</p>

<h1>Putting It All Together</h1>
There's no functionality in the examples below that require the use of the asynchronous model, but both approaches are shown below to illustate the key differences in the techniques:
<table>
  <tr><td style="width: 400px; vertical-align: top;"><ul><li><b>Synchronous</b><p><pre class="prettyprint">params = [
  { 
    "id": "radius", 
    "displayName": "Radius", 
    "type": "length", 
    "rangeMin": 1, 
    "rangeMax": 50, 
    "default": 20 
  }
];

function process(params) {

  var r = params['radius'];
  var angle = 2*Math.PI / 3;
  var h = Math.sqrt(2) * r;

  var sides = [];
  for (var i = 0; i < 3; i++) {
  	var x = r * Math.cos(i * angle);
  	var y = r * Math.sin(i * angle);
  	sides.push([x, y, 0]);
  }
  var peak = [0, 0, h];

  var mesh = new Mesh3D();
  mesh.triangle(sides[0], sides[2], sides[1]);
  mesh.triangle(sides[0], sides[1], peak);
  mesh.triangle(sides[1], sides[2], peak);
  mesh.triangle(sides[2], sides[0], peak);

  return Solid.make(mesh);
}
</pre></li></ul></td><td style="width: 400px; vertical-align: top;"><ul><li><b>Asynchronous</b><p><pre class="prettyprint">function shapeGeneratorDefaults(callback) {
  var params = [
    { 
      "id": "radius", 
      "displayName": "Radius", 
      "type": "length", 
      "rangeMin": 1, 
      "rangeMax": 50, 
      "default": 20 
    }
  ];
  callback(params);
}

function shapeGeneratorEvaluate(params, callback) {

  var r = params['radius'];
  var angle = 2*Math.PI / 3;
  var h = Math.sqrt(2) * r;

  var sides = [];
  for (var i = 0; i < 3; i++) {
    var x = r * Math.cos(i * angle);
    var y = r * Math.sin(i * angle);
    sides.push([x, y, 0]);
  }
  var peak = [0, 0, h];

  var mesh = new Mesh3D();
  mesh.triangle(sides[0], sides[2], sides[1]);
  mesh.triangle(sides[0], sides[1], peak);
  mesh.triangle(sides[1], sides[2], peak);
  mesh.triangle(sides[2], sides[0], peak);

  callback(Solid.make(mesh));
}
</pre></li></ul></td></tr>
</table>

<h1>The Object-Oriented Approach</h1>
Aside from declaring some parameters and generating geometry, there are lots of other things a Shape Generator may do so it became necessary to encapsulate
all of the responsibilities in a clean interface that caters to our object-oriented developers.  To find out more about the additional capabilities when
using this approach refer to {IShapeGenerator}.  This technique can be used in lieu of the Asynchronous or Synchronous approaches discussed above, 
and all three approaches: 1) Synchronous, 2) Asynchronous and 3) Object-Oriented will be supported going forward to cater to the full spectrum of developers.
<ul><li><b>Object-Oriented</b><p><pre class="prettyprint">var Mesh3D = Core.Mesh3D;
var Solid = Core.Solid;

// An object-oriented shape generator
var Generator = {

  parameters: function(callback) {
    var params = [
      { 
        "id": "radius", 
        "displayName": "Radius", 
        "type": "length", 
        "rangeMin": 1, 
        "rangeMax": 50, 
        "default": 20 
      }
    ];
    callback(params);
  },
   
  evaluate: function(params, callback) {
    
    var r = params['radius'];
    var angle = 2*Math.PI / 3;
    var h = Math.sqrt(2) * r;

    var sides = [];
    for (var i = 0; i < 3; i++) {
      var x = r * Math.cos(i * angle);
      var y = r * Math.sin(i * angle);
      sides.push([x, y, 0]);
    }
    var peak = [0, 0, h];
  
    var mesh = new Mesh3D();
    mesh.triangle(sides[0], sides[2], sides[1]);
    mesh.triangle(sides[0], sides[1], peak);
    mesh.triangle(sides[1], sides[2], peak);
    mesh.triangle(sides[2], sides[0], peak);

    callback(Solid.make(mesh));
   
  }

};

// Returns the object-oriented shape generator,
function shapeGenerator() {
  return Generator;
}
</pre></li></ul>

@topic Shape Generator Overview
@unlisted
**/
//topic-tutorial1.js
/**

<p>This tutorial will introduce you to a simple method for creating 3D shapes out of 2D outlines. There's another tutorial, {Platonic Solid Generator - Part 1}, which shows how a script can generate shapes from 3D primitives like triangles.</p>

<h2 id="toc">Table of contents</h2>

<ul>
<li><a href="#intro">From Canvas 2D to 3D</a></li>
<li><a href="#creating">Creating a Shape Generator</a></li>
<li><a href="#reusing">Reusing HTML5 graphics code</a></li>
<li><a href="#flipping">Flipping the solid</a></li>
<li><a href="#position">Fixing the position</a></li>
</ul>

<h2 id="intro">From Canvas 2D to 3D</h2>

<p>In this tutorial we'll start with ordinary 2D graphics and turn it into a 3D shape. One great thing about the Autodesk Creative Platform is that it uses the JavaScript language which is already familiar to many people from web development. To get quickly off the ground, we'll take an existing bit of JavaScript graphics code meant for a web page and use it as the source for a new 3D shape. The result of our effort will be the heart shape shown in the screenshot below.</p>
<img src="{@ResourceUrl:heart-from-canvas-flipped.png}" style="border: 1px solid black;"/>

<h2 id="creating">Creating a Shape Generator</h2>

<p>Before digging into the JavaScript code, let's take a brief glance at the essentials of creating a Shape Generator.</p>

<p>On the right-hand side of the Tinkercad Editor, expand <span class="ui-element">Your Shape Generators</span> and click on <span class="ui-element">New Shape Generator</span>. Choose one of the example scripts as a starting point, for example <span class="ui-element">Star</span>.</p>

<img src="{@ResourceUrl:customshape-category.png}" alt="Custom shapes category" style="border: 1px solid black;"/>

<p>Click on <span class="ui-element">Edit</span>, and the Autodesk Creative Platform Library Editor appears on the left-hand side of the window.</p>

<p>You can delete everything and just leave an empty <code>process()</code> function like the one below &mdash; we'll fill it out with brand new code soon.</p>

<pre class="prettyprint">function process(params) {
}
</pre>

<h2 id="reusing">Reusing HTML5 graphics code</h2>

<p>The Autodesk Core Library's approach for creating 2D shapes is very similar to the <em>Canvas</em> graphics API available in HTML5. We can take a piece of code that generates a shape in Canvas and reuse it for our Shape Generator.</p>

<p>Mozilla's developer site has a Canvas tutorial that contains a short and sweet example of rendering a heart:</p>
<blockquote>
    <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Drawing_shapes" target="_blank">Click here to open the Canvas tutorial in a new tab</a></blockquote>

<p>Copy the drawing code under the comment that reads &ldquo;Bezier curve example&rdquo;, and paste it into the Autodesk Creative Platform Library Editor inside the <code>process()</code> function. Replace references to <code>ctx</code> with <code>path</code>.</p>

<p>Then add this line at the start of the <code>process()</code> function:</p>
<pre class="prettyprint">var path = new Path2D();</pre>

<p>Also add one line at the end of the <code>process()</code> function:</p>
 <pre class="prettyprint">return Solid.extrude([path], 10);</pre>

<div class="imgwrap">
<img src="{@ResourceUrl:heart-from-canvas.png}" alt="Heart upside down" style="border: 1px solid black;"/>
</div>

<p>That's all! Click <span class="ui-element">Save</span>. You should now see the heart shape in your Shape Generators list. To create an instance of this shape, you can drag &amp; drop it into  Tinkercad's workspace just like other shapes.</p>

<p>Below is the complete heart generator script we just adapted from the HTML Canvas example.</p>

<pre class="prettyprint">function process(params) {

    var path = new Path2D();

    path.moveTo(75,40);
    path.bezierCurveTo(75,37,70,25,50,25);
    path.bezierCurveTo(20,25,20,62.5,20,62.5);
    path.bezierCurveTo(20,80,40,102,75,120);
    path.bezierCurveTo(110,102,130,80,130,62.5);
    path.bezierCurveTo(130,62.5,130,25,100,25);
    path.bezierCurveTo(85,25,75,37,75,40);

    return Solid.extrude([path], 10);

}
</pre>

<p>The height of the extruded shape is 10 millimeters. You can change this by modifying the last parameter passed to the {Solid#extrude} function. </p>

<h2 id="flipping">Flipping the solid</h2>

<p>The heart is not quite what we expected because it's upside down compared to the sample image shown in Mozilla's tutorial. This is because the coordinate system of the Canvas API is flipped in the Y direction compared to the 3D space in the Autodesk Creative Platform.</p>

<p>We could fix this by modifying the coordinates passed to the path methods like <code>moveTo()</code> and <code>bezierCurveTo()</code> however there's an easier way to flip the entire shape.</p>

<p>The object returned by the <code>Solid.extrude()</code> call is a {Solid3D} object. A quick glance at {Solid3D} reveals a method called {Solid3D#transform} is available. This method is a generic way of performing transformation operations like translating, scaling and rotating. Let's use it to flip our heart shape so that it looks like the original one on the Mozilla site.</p>

<p>The <code>transform()</code> method takes a 4x4 transformation matrix as its argument. Don't worry if you're not quite up to speed on linear algebra. We don't need to do anything complicated with this matrix, we'll just tweak one value to scale the solid by -1 in the Y direction.</p>

<p>Replace the last line of the <code>process()</code> function with the following: </p>
<pre class="prettyprint">var solid = Solid.extrude([path], 10);

var tm = [1,  0, 0, 0,
          0, -1, 0, 0,
          0,  0, 1, 0,
          0,  0, 0, 1];
solid.transform(tm);
return solid;
</pre>

<img src="{@ResourceUrl:heart-from-canvas-flipped.png}" alt="Heart" style="border: 1px solid black;"/>



<p>The transformation matrix is represented as a JavaScript array of 16 numbers. A matrix that is otherwise zero except that it has the value 1 at indices 0, 5, 10 and 15 is called the <em>identity matrix</em> &mdash; this means that transforming a solid by this matrix won't alter it in any way. We can change the values at indices 0, 5 and 10 that were set to 1 in order to define the scaling factor in each dimension. Thus by changing the second one of them to -1 we'll cause all Y coordinates to be scaled by -1.</p>

<p>Now the heart is right way up. Transformation matrices are a powerful tool in 3D graphics and modeling, but you can get far on the Autodesk Creative Platform without knowing matrices more intimately than this. If you are interested in learning more about transformation matrices, have a look at {Matrix3D}.</p>

<h2 id="position">Fixing the position</h2>

<p>There's one other annoying thing about the code we copied from Mozilla Developer Network, though. It draws the heart at a location that's not centered on the origin. This makes sense in the HTML5 Canvas world where shapes are measured in pixels: the origin of the image plane is the top-left corner and negative values are not visible. But in 3D space, we'd like to have the center of the heart at point <em>(0, 0)</em>.</p>

<p>You can use the same transformation matrix to reposition the heart. In the matrix, the last value on each of the first three lines is the translation offset. Try entering some numbers there instead of zero, and you'll see the shape being translated accordingly.</p>

<p>The actual values for translating the solid to the origin are left as an exercise. You can calculate them by looking at the coordinates passed to the Path2D methods: where is the center point of the heart shape we're drawing?</p>

<p>Below is the complete commented code for the heart shape at this point.</p>

<p>There is also a modified version that doesn't use the Canvas-style pixel coordinates anymore, and has added parameters for easy modification of the shape's size and height. You can find this updated heart shape in the list of examples Tinkercad's Shape Generator Templates.</p>

<pre class="prettyprint">
// A 2D heart shape based on HTML5 Canvas code example at Mozilla Developer Network:
// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Drawing_shapes
function process(params) {

    // The Path2D object has methods with same names as the HTML Canvas &quot;context&quot; object,
    // so we can use this code directly from the MDN example.
    var path = new Path2D();
    path.moveTo(75,40);
    path.bezierCurveTo(75,37,70,25,50,25);
    path.bezierCurveTo(20,25,20,62.5,20,62.5);
    path.bezierCurveTo(20,80,40,102,75,120);
    path.bezierCurveTo(110,102,130,80,130,62.5);
    path.bezierCurveTo(130,62.5,130,25,100,25);
    path.bezierCurveTo(85,25,75,37,75,40);

    // The 2D path is extruded into a 3D shape.
    var solid = Solid.extrude([path], 10);

    // HTML Canvas has the coordinate space upside down compared to us.
    // We can fix that by transforming the 3D solid with the following transformation matrix.
    // This matrix applies a -1 scaling in the Y direction.
    var tm = [1,  0, 0, 0,  // Modify the last value on this line to move in X
              0, -1, 0, 0,  // Modify the last value on this line to move in Y
              0,  0, 1, 0,
              0,  0, 0, 1];
    solid.transform(tm);

    return solid;
}
</pre>

@topic Heart Extrusion Generator
@unlisted
**/
//topic-tutorial2.js
/**
<p>The Autodesk Creative Platform Library Editor lets you write Shape Generators that construct 3D shapes in several different ways. A shape generated automatically becomes watertight so you can group it with other shapes, use it as a hole, and so on. Shape Generators are always procedural: the shape will be recomputed on the fly as needed, so the results of a Shape Generator are not set in stone once created. Even when the shape is included in a group, its form can be modified by visually tweaking parameters that were defined by the author of the Shape Generator.</p>

<p>This tutorial will introduce you to building unlimited 3D shapes out of individual points in space. There's another tutorial, {Heart Extrusion Generator}, which shows how a Shape Generator can produce shapes starting from 2D elements.</p>

<div class='imgwrap' style="padding-top:10px;">
<img src="{@ResourceUrl:icosahedron-scripteditor.png}" style="border: 1px solid black;"/>
</div>

<h1 id="toc">Table of contents</h1>
<ul>
<li><a href="#intro">Introduction</a></li>
<li><a href="#creating">Creating a Shape Generator</a></li>
<li><a href="#tetrahedron">Tetrahedron</a></li>
<li><a href="#parameters">Adding parameters</a></li>
<li><a href="#cube">Cube</a></li>
<li><a href="#exercises">Exercises</a></li>
</ul>

<h1 id="intro">Introduction</h1>

<p>At the heart of the Autodesk Creative Platform happens to be a solid modeler.  The most typical representation of 3D shapes is only concerned with points and depthless surfaces and thus lacks any notion of volume within the shapes. This kind of 3D shape is usually called a "mesh" - you could visualize it as pieces of cloth wrapped over a wireframe of points. The points are called vertices, and the surface elements are faces.  However because of the unique underlying technology in Autodesk's Creative Platform, even meshes that are not watertight can be converted into a solid.</p>
<img src="{@ResourceUrl:platonics-2rows.png}" style="float: left;"/>

<p>Things in the real world are of course very much concerned with volume, so when designing anything that represents physical objects, the advantage of working in solids is clear. But meshes have their own practical advantages: it is easy to write code to generate meshes, and there is a large amount of mesh data in the wild. The Autodesk Creative Platform lets you combine the best of both worlds - generate meshes in your script, and they become solids.</p>

<p>This tutorial covers the most fundamental type of geometric solids, the five <em>Platonic solids</em>.</p>

<p>The <em>Platonic solids</em> are unique because they are the only convex regular polyhedra. In plain English, they are the only solids that can be built out of identical faces (either triangles, squares or pentagons), with the same number of faces meeting at each vertex, and with faces meeting each other always at the same angle at the edges.</p>

<p>These shapes are named after the Greek philosopher Plato. He was fascinated by these regular solids and claimed a mystic link between the five solids and the five classical elements discussed in Greek philosophy - Earth, Water, Air, Fire and the invisible Aether. Were he alive today, Plato would surely be an Autodesk Creative Platform user, as he was a man who understood the importance of being able to turn ideas into physical reality.</p>

<p>There are a great many ways to construct the <em>Platonic solids</em>  because of their beautifully regular mathematical properties. This tutorial will demonstrate how to write Shape Generators for these solids in a &#8220;common sense&#8221; way that assumes only basic familiarity with JavaScript and some trigonometry. There are also more elegant, generalized mathematical formulations for building the solids - if you're interested; the <a href="http://en.wikipedia.org/wiki/Platonic_solid">Wikipedia article</a> on the solids is a fine place to start.</p>

<h1 id="creating">Creating a Shape Generator</h1>


<p>Before jumping into geometry, let's take a brief glance at the essentials of creating a Shape Generator.</p>

<p>Open the Autodesk Creative Platform Library Editor.  If you're using Tinkercad, on the right-hand side expand <span class="ui-element">Your Shape Generators</span> and click <span class="ui-element">New Shape Generator</span>. Choose one of the example scripts as a starting point, for example <span class="ui-element">Star</span>.</p>

<p>Click <span class="ui-element">Edit</span>, and the Autodesk Creative Platform Library Editor pops up at the left-hand side of the window.</p>

<div class='imgwrap'>
<img src="{@ResourceUrl:customshape-scripteditor.png}" alt="Script editor" style="border: 1px solid black;"/>
</div>

<p>Delete the existing code within the <code>process()</code> function and paste in the following:</p>

<pre class="prettyprint">function process(params) {
    var mesh = new Mesh3D();

    return Solid.make(mesh);
}
</pre>

<p>An empty mesh now awaits us, eager to be filled with vertices and faces. Note the call to {Solid#make}: the returned shape must be a solid, so we call this function to turn the mesh into a solid representation.</p>

<p>A quick note on the <code>process()</code> function: it is necessary because it's the so-called &#8220;entry point&#8221; for Shape Generators on the Autodesk Creative Platform. Without this function, the script would not be called to do any useful work. As it happens, this script doesn't do anything useful anyway currently, returning an empty mesh at it does. Let's fix that.</p>

<h1 id="tetrahedron">Tetrahedron</h1>

<p>The tetrahedron, also known as a pyramid with a triangular base, is a fine starting point for a mesh tutorial because it's the simplest possible solid that can be defined as a mesh.</p>

<p>Consisting of four vertices and four faces, it's easy to mentally visualize the construction of the tetrahedron: all we need is an equilateral triangle for the base, i.e. a triangle whose angles are identical, and a &#8220;peak&#8221; vertex at the center.</p>

<img src="{@ResourceUrl:tetrahedron.png}" style="float: right;" alt="Tetrahedron"/>

<p>To build the base triangle, we start with the angle in radians. Let's recall some trigonometry. A full circle is 2 &times; &#960;, so each point of the equilateral triangle has an angle one-third of that:</p>

<pre class="prettyprint">var angle = 2 * Math.PI / 3;
</pre>

<p>The coordinates for the triangle's points can be calculated by imagining a circle around the triangle and calculating points on that circle separated by this angle. To define the size of the triangle - and consequently the whole tetrahedron - we'll need the radius of the circumscribing circle. For the moment, let's just define the radius as 10:</p>

<pre class="prettyprint">var r = 10;
</pre>

<p>Now we can create the vertices for the triangle's base:</p>

<pre class="prettyprint">var sides = [];
for (var i = 0; i < 3; i++) {
    var x = r * Math.cos(i * angle);
    var y = r * Math.sin(i * angle);
    sides.push( [x, y, 0] );
}
</pre>

<p>Note that we're passing zero for the z coordinate, and the x and y coordinates are around the origin. By default, this tetrahedron will lie at the center of the workplace when placed into your design.</p>

<p>Next we need to place the peak vertex. Its x and y coordinates are obviously at the center of the base triangle, i.e. point (0, 0). But what is the z coordinate? We can use good old Pythagoras to figure this out, but we need to know the length of a tetrahedron's edge in relation to the radius we used to construct the base. I'll skip the formulation and simply tell you that the length of the edge is <em>&#8730;3r</em> - you can find this and other possibly useful formulas at the <a href="http://en.wikipedia.org/wiki/Tetrahedron">Wikipedia article on tetrahedrons</a>.</p>

<p>Armed with the radius <code>a</code> and edge length <code>b</code>, we can calculate the height of our tetrahedron using the Pythagorean theorem:</p>

<p><img src="{@ResourceUrl:pythagorean.gif}" style="float: center;"/></p>

<p>Recall that <code>b</code>, edge length, is <em>&#8730;3r</em>. When we insert this into the equation above, it simplifies neatly down to <code>&#8730;2r</code>. </p>

<pre class="prettyprint">var h = Math.sqrt(2) * r;</pre>

<p>Let's store the last vertex:</p>

<pre class="prettyprint">var peak = [0, 0, h];</pre>

<p>Now we have all the vertices in memory as arrays. We can call methods on the {Mesh3D} object to define the four faces of the tetrahedron based on these vertices:</p>

<pre class="prettyprint">mesh.triangle(sides[0], sides[2], sides[1]);
mesh.triangle(sides[0], sides[1], peak);
mesh.triangle(sides[1], sides[2], peak);
mesh.triangle(sides[2], sides[0], peak);
</pre>

<p>The first triangle is the base. By the way, the {Mesh3D#triangle} method is flexible about input. We can pass vertices as individual arrays like we did here, but it's equally possible to pass a single array containing nine numbers for all the three points' coordinates, or to pass the nine numbers as individual arguments.</p>

<p>The ordering of vertices in these calls is critical. If you try flipping some of the indices within one of the {Mesh3D#triangle} calls, for example by changing the parameters of the first triangle call to <i>(sides[0], sides[2], sides[1])</i>. You won't see anything rendered in the editor.</p>

<p>It's not enough that the indices define a valid triangle. We must also pay attention to the &#8220;winding order&#8221; of the indices - in other words, whether the triangle is defined in <em>clockwise</em> or <em>counter-clockwise</em> order.</p>

<p>The winding order essentially defines which side of the triangle is "on the outside" and which is "on the inside" of the shape. The important point is that all your triangles must use the same winding order. You can use either direction, as long as it's the same for all triangles. To see an example of this in practice, you can try flipping the first two coordinates of each <code>triangle()</code> call. This will reverse the winding order but visually the shape is unaffected.</p>

<p>The Autodesk Creative Platform can sometimes allow either winding order for Shape Generators because of the underlying technology. In traditional 3D applications that work exclusively on meshes, the winding order usually must be the same for all polygons defined in the whole system, not just within one object. But in the Autodesk Creative Platform your mesh will be converted into a special solid representation by the geometry engine anyway, so the winding order of polygons just needs to be consistent within your own script.</p>

<p>Here is the complete function. You can copy and paste it into the script editor, then click <span class="ui-element">Save</span></p>

<pre class="prettyprint">function process(params) {
    var r = params.radius;
    var angle = 2*Math.PI / 3;
    var h = Math.sqrt(2) * r;

    var sides = [];
    for (var i = 0; i < 3; i++) {
        var x = r * Math.cos(i * angle);
        var y = r * Math.sin(i * angle);
        sides.push([x, y, 0]);
    }
    var peak = [0, 0, h];

    var mesh = new Mesh3D();
    mesh.triangle(sides[0], sides[2], sides[1]);
    mesh.triangle(sides[0], sides[1], peak);
    mesh.triangle(sides[1], sides[2], peak);
    mesh.triangle(sides[2], sides[0], peak);
    
    return Solid.make(mesh);
}
</pre>

<h1 id="parameters">Adding parameters</h1>

<div class='imgwrap'>
<img src="{@ResourceUrl:tetrahedron-params.png}" style="float:right;" alt="Tetrahedron Tools menu"/>
</div>

<p>Our custom tetrahedron shape is currently fixed at a specific size. We can always resize the shape in an application such as Tinkercad, but perhaps it would be useful to have a way to control the radius value we used in creating the tetrahedron. This can be accomplished by adding a custom parameter.</p>

<p>As you can see from the screenshot on the right, once a Shape Generator has parameters, they become accessible directly by the user.  This way you can easily change parameter values for a single shape or a whole selection of shapes.</p>

<p>Parameters are defined by adding an object called params into the script, alongside the required <code>process()</code> function.</p>

<p>Here's the parameter definition for a Radius slider:</p>

<pre class="prettyprint">params = [
  {
    &quot;id&quot;: &quot;radius&quot;, 
    &quot;displayName&quot;: &quot;Radius&quot;,
    &quot;type&quot;: &quot;float&quot;,
    &quot;rangeMin&quot;: 1,
    &quot;rangeMax&quot;: 50,
    &quot;default&quot;: 20
  }
];
</pre>

<p>The <code>&#8216;params'</code> object is a JavaScript array containing JavaScript objects describing each parameter. More specifically, this list of parameter definitions is a <a href="http://en.wikipedia.org/wiki/Json">JSON</a> array. Each key (such as <code>&#8220;displayName&#8221;</code>) must be quoted, and the array's contents must not end with a comma. (This may seem like a somewhat arbitrary restriction, but using JSON ensures that the parameters can always be parsed separately from actual script execution.)</p>

<img src="{@ResourceUrl:tetrahedron-editor-params.png}" alt="Tetrahedron" style="border: 1px solid black;"/>

<p>It's not enough to just define a slider; we also need to use that value in our processing function. The parameter values are passed to the function in an argument called params. Change the <code>var r = ...</code> line to the following:</p>

<pre class="prettyprint">var r = params.radius;</pre>

<p>Click <span class="ui-element">Save</span>, and the slider is ready for use. We're done with the tetrahedron.</p>


<h1 id="cube">Cube</h1>

<p>The next solid is the cube, and despite having more vertices and faces than the tetrahedron, it is easier to construct because the faces meet at right angles. This cube Shape Generator is also useful starting point for any block-like angular shapes (for example a slanted block or a wedge with a tapered end).</p>

<p>To keep things simple, we will not touch parameters again for the rest of this tutorial. All of the regular solids need only one parameter for the size, and so we can just reuse the "Radius" parameter we created for the tetrahedron.</p>

<img src="{@ResourceUrl:cube.png}" style="float:right;" alt="Cube" style="border: 1px solid black;"/>

<p>To construct a cube, we are more interested in the edge length, which is <em>&#8730;2r</em>. (You can confirm this by imagining a right-angled triangle whose 90&deg; angle lies at the center of the cube base. The edge length is the hypotenuse of this triangle.)</p>

<p>Since we want the cube center to lie at the origin, that means the x/y coordinates of the corners of the cube base are half of the edge length from the origin. Let us call this half-edge-length variable <em>he</em> and build the base:</p>

<pre class="prettyprint">
var r = params.radius;
var e = Math.sqrt(2) * r;
var he = e / 2;

var bot = [];  // Bottom face vertices
bot.push( [-he, -he, 0] );
bot.push( [he, -he, 0] );
bot.push( [he, he, 0] );
bot.push( [-he, he, 0] );
</pre>

<p>Building the top of the cube is simply a matter of setting the right height:</p>

<pre class="prettyprint">
var top = [];  // Top face vertices
top.push( [-he, -he, e] );
top.push( [he, -he, e] );
top.push( [he, he, e] );
top.push( [-he, he, e] );
</pre>

<p>These are the vertices for the cube. The {Mesh3D} object has a {Mesh3D#quad} method that we can use to define the six faces of the cube:</p>

<pre class="prettyprint">
var mesh = new Mesh3D();
mesh.quad(bot[3], bot[2], bot[1], bot[0]);
mesh.quad(top[0], top[1], top[2], top[3]);

mesh.quad(bot[0], bot[1], top[1], top[0]);
mesh.quad(bot[1], bot[2], top[2], top[1]);
mesh.quad(bot[2], bot[3], top[3], top[2]);
mesh.quad(bot[3], bot[0], top[0], top[3]);
</pre>

<img src="{@ResourceUrl:cube-scripteditor.png}" style="border: 1px solid black;"/>

<p>Below is the complete script for the cube.</p>

<pre class="prettyprint">params = [
  { 
    &quot;id&quot;: &quot;radius&quot;,
    &quot;displayName&quot;: &quot;Radius&quot;,
    &quot;type&quot;: &quot;float&quot;,
    &quot;rangeMin&quot;: 1,
    &quot;rangeMax&quot;: 50,
    &quot;default&quot;: 20 }
];

function process(params) { 
  var r = params.radius;
  var e = Math.sqrt(2) * r;
  var he = e / 2;

  var bot = [];
  bot.push( [-he, -he, 0] );
  bot.push( [he, -he, 0] );
  bot.push( [he, he, 0] );
  bot.push( [-he, he, 0] );

  var top = [];
  top.push( [-he, -he, e] );
  top.push( [he, -he, e] );
  top.push( [he, he, e] );
  top.push( [-he, he, e] );

  var mesh = new Mesh3D();
  mesh.quad(bot[3], bot[2], bot[1], bot[0]);
  mesh.quad(top[0], top[1], top[2], top[3]);

  mesh.quad(bot[0], bot[1], top[1], top[0]);
  mesh.quad(bot[1], bot[2], top[2], top[1]);
  mesh.quad(bot[2], bot[3], top[3], top[2]);
  mesh.quad(bot[3], bot[0], top[0], top[3]);

  return Solid.make(mesh);
}
</pre>

<h1 id="exercises">Exercises</h1>

<p>To practice 3D thinking, you can try changing those vertex definitions. There are many kinds of blocks that can be created with minimal changes to this cube-generating script. How would you make a slanted box? Or a wedge that has a thin rectangle at the other end and a larger rectangle at the other end?</p>

<p>How about a twisted cube where the top face is rotated? To compute the rotated vertices, take a look back at the Tetrahedron construction. The necessary rotation math is all there - you just need to change a few numbers so that the <code>for</code> loop produces a square instead of an equilateral triangle.</p>

<p>Twisting the cube breaks the planarity of the side faces and reveals that the shape is in fact built out of triangles:</p>

<img src="{@ResourceUrl:cube-twisted.png}" style="border: 1px solid black;"/>

<p>If you are a cubist sculptor, this is probably exactly the shape you were looking for. But for the rest of us, it would be interesting to make the twist smoother. Rather than one sharp diagonal edge across the side, we would want the rotation to progress in steps. To accomplish this we will need to add subdivisions - but that is a great topic for another tutorial later on.</p>

@topic Platonic Solid Generator - Part 1
@unlisted
**/
//topic-tutorial3.js
/**
<p>This is the second part of the tutorial that shows how to build the elementary Platonic Shapes using the Autodesk Creative Platform Shape Generators.</p>

<p>In {Platonic Solid Generator - Part 1}, we learned the essentials of creating meshes in and built the first two solids, the tetrahedron and the cube. This second part will cover the remaining three solids: the octahedron, the dodecahedron and the icosahedron. In the course of building these more complex shapes, we'll use the graphical debugging aids.</p>

<img src="{@ResourceUrl:icosahedron-scripteditor.png}" style="border: 1px solid black;"/>

<h1 id="toc">Table of contents</h1>
<ul>
<li><a href="#octahedron">Octahedron</a></li>
<li><a href="#dodecahedron">Dodecahedron</a></li>
<li><a href="#icosahedron">Icosahedron</a></li>
</ul>

<h1 id="octahedron">Octahedron</h1>

<p>The octahedron is a simple form compared to the last two solids we're going to encounter next. It's essentially two square-based pyramids glued to each other at the base.</p>

<div class='imgwrap'>
<img src="{@ResourceUrl:octahedron.png}" alt="Octahedron" style="border: 1px solid black;"/>
</div>

<p>As you may remember from the first part of this tutorial, the tetrahedron is a pyramid with a triangular base. Hence we can easily modify the tetrahedron's code to produce pyramids with a square base instead. The height of each pyramid is simply the radius of the shape &mdash; because these are regular solids, each vertex must lie at the same distance from the center.</p>

<p>There's not much else to say about constructing the octahedron, so here's the code:</p>

<pre class="prettyprint">function process(params) {
    var r = params.radius;
    var e = Math.sqrt(2) * r;
    var angle = Math.PI / 2;

    var sides = [];
    for (var i = 0; i &lt; 4; i++) {
        var x = r * Math.cos(i * angle);
        var y = r * Math.sin(i * angle);
        sides.push([x, y, 0]);
    }
    var top = [0, 0, r];
    var bot = [0, 0, -r];

    var mesh = new Mesh3D();
    mesh.triangle(sides[0], sides[3], top);
    mesh.triangle(sides[1], sides[0], top);
    mesh.triangle(sides[2], sides[1], top);
    mesh.triangle(sides[3], sides[2], top);

    mesh.triangle(sides[3], sides[0], bot);
    mesh.triangle(sides[0], sides[1], bot);
    mesh.triangle(sides[1], sides[2], bot);
    mesh.triangle(sides[2], sides[3], bot);

    return Solid.make(mesh);
}
</pre>

<h1 id="dodecahedron">Dodecahedron</h1>

<img src="{@ResourceUrl:dodecahedron-construction.png}" style="float:right;" alt="Dodecahedron construction"/>

<p>The dodecahedron is a more complicated animal. It's built out of 12 pentagonal faces and 20 vertices, so it has the most vertices of all the Platonic solids. (The last solid, icosahedron, has 20 faces but only 12 vertices.)</p>

<p>The dodecahedron's vertex placement contains some rather interesting proportions. The famous golden ratio makes an appearance in the rectangles formed by many of the dodecahedron's vertices that lie on the same plane. <a href="http://en.wikipedia.org/wiki/Dodecahedron#Cartesian_coordinates">The Wikipedia article</a> has a useful picture showing these rectangles within the dodecahedron. You can find it reproduced on the right.</p>


<p>The illustration shows a cube and three rectangles on the x/y/z planes. I find this to be a reasonably straightforward way of visualizing the dodecahedron's vertex relationships, so I'll use it as the basis for constructing the shape.</p>

<p>The picture tells us the coordinates for the cube and rectangle vertices. But as you can see, the coordinates are given in relation to the dodecahedron's inner cube - the cube vertices lie at <em>(&plusmn;1, &plusmn;1, &plusmn;1)</em>. In order to create the dodecahedron in respect to the same <em>radius</em> parameter that we've used for the other Platonic shapes, we need one more number: the relation of the dodecahedron's inner cube to its outer radius. This number is given in the Wikipedia article, it's &#8730;3. Armed with this knowledge, let's build the vertices.</p>

<pre class="prettyprint">var r = params.radius;
var m = 1 / Math.sqrt(3) * r;
var phi = (1 + Math.sqrt(5)) / 2;  // The golden ratio, ~1.618

var r1 = 1 * m;
var phi1 = phi * m;
var iphi1 = (1.0 / phi) * m;

var cubeBot = [];
cubeBot.push([-r1, -r1, -r1]);
cubeBot.push([r1, -r1, -r1]);
cubeBot.push([r1, r1, -r1]);
cubeBot.push([-r1, r1, -r1]);

var cubeTop = [];
cubeTop.push([-r1, -r1, r1]);
cubeTop.push([r1, -r1, r1]);
cubeTop.push([r1, r1, r1]);
cubeTop.push([-r1, r1, r1]);

var xrect = [];
xrect.push([0, -iphi1, -phi1]);
xrect.push([0, -iphi1, phi1]);
xrect.push([0, iphi1, phi1]);
xrect.push([0, iphi1, -phi1]);

var zrect = [];
zrect.push([-iphi1, -phi1, 0]);
zrect.push([iphi1, -phi1, 0]);
zrect.push([iphi1, phi1, 0]);
zrect.push([-iphi1, phi1, 0]);

var yrect = [];
yrect.push([-phi1, 0, -iphi1]);
yrect.push([phi1, 0, -iphi1]);
yrect.push([phi1, 0, iphi1]);
yrect.push([-phi1, 0, iphi1]);
</pre>

<p>If you look back at the picture, the <code>xrect</code> vertices are marked in green, the <code>zrect</code> vertices are in blue and the <code>yrect</code> vertices are in pink.</p>

<p>Now we've defined a cube and three rectangles, but we can't actually see them. There's a quick solution available: There's the {Debug} utilities which gives us the possibility to draw lines using {Debug#line} that are only visible while we're working on the script. This is a convenient way of visualizing 3D elements in space without having to define a valid solid.</p>

<p>Let's draw debug visualization lines for the cube and the three rectangles. These debug lines can also have different colors using the {Debug#color} function, so let's use the same colors (orange, green, blue and pink) as in the illustration.</p>

<pre class="prettyprint">Debug.color(1, 0.65, 0, 1);
Debug.line(cubeBot[0], cubeBot[1]);
Debug.line(cubeBot[1], cubeBot[2]);
Debug.line(cubeBot[2], cubeBot[3]);
Debug.line(cubeBot[3], cubeBot[0]);
Debug.line(cubeTop[0], cubeTop[1]);
Debug.line(cubeTop[1], cubeTop[2]);
Debug.line(cubeTop[2], cubeTop[3]);
Debug.line(cubeTop[3], cubeTop[0]);
Debug.line(cubeBot[0], cubeTop[0]);
Debug.line(cubeBot[1], cubeTop[1]);
Debug.line(cubeBot[2], cubeTop[2]);
Debug.line(cubeBot[3], cubeTop[3]);

Debug.color(0, 0.8, 0, 1);
Debug.line(xrect[0], xrect[1]);
Debug.line(xrect[1], xrect[2]);
Debug.line(xrect[2], xrect[3]);
Debug.line(xrect[3], xrect[0]);

Debug.color(0, 0.1, 1.0, 1);
Debug.line(zrect[0], zrect[1]);
Debug.line(zrect[1], zrect[2]);
Debug.line(zrect[2], zrect[3]);
Debug.line(zrect[3], zrect[0]);

Debug.color(1, 0.2, 0.8, 1);
Debug.line(yrect[0], yrect[1]);
Debug.line(yrect[1], yrect[2]);
Debug.line(yrect[2], yrect[3]);
Debug.line(yrect[3], yrect[0]);
</pre>

<p>You should now see this:</p>
<div style="width: 100%"><img src="{@ResourceUrl:dodecahedron-debug-lines.png}" alt="Dodecahedron debug lines" style="border: 1px solid black;"/></div>

<p>Ok, now that we've verified that the vertices are where we want them to be, it's time to build the surface.</p>
    <p>There is no readymade function on the Mesh type for creating pentagons, as it's a fairly rare type of surface element compared to triangles and quads. This is not a problem since we can easily define our own helper function for creating pentagons out of triangles. The following is the complete code for the dodecahedron.</p>

<pre class="prettyprint">params = [
    {
        &#8220;id&#8221;: &#8220;radius&#8221;,
        &#8220;displayName&#8221;: &#8220;Radius&#8221;,
        &#8220;type&#8221;: &#8220;float&#8221;,
        &#8220;rangeMin&#8221;: 1,
        &#8220;rangeMax&#8221;: 50,
        &#8220;default&#8221;: 20
    }
];
function process(params) {
    var r = params.radius;
    var m = 1 / Math.sqrt(3) * r;
    var phi = (1 + Math.sqrt(5)) / 2;  // The golden ratio, ~1.618

    var r1 = 1 * m;
    var phi1 = phi * m;
    var iphi1 = (1.0 / phi) * m;

    var cubeBot = [];
    cubeBot.push([-r1, -r1, -r1]);
    cubeBot.push([r1, -r1, -r1]);
    cubeBot.push([r1, r1, -r1]);
    cubeBot.push([-r1, r1, -r1]);

    var cubeTop = [];
    cubeTop.push([-r1, -r1, r1]);
    cubeTop.push([r1, -r1, r1]);
    cubeTop.push([r1, r1, r1]);
    cubeTop.push([-r1, r1, r1]);

    var xrect = [];
    xrect.push([0, -iphi1, -phi1]);
    xrect.push([0, -iphi1, phi1]);
    xrect.push([0, iphi1, phi1]);
    xrect.push([0, iphi1, -phi1]);

    var zrect = [];
    zrect.push([-iphi1, -phi1, 0]);
    zrect.push([iphi1, -phi1, 0]);
    zrect.push([iphi1, phi1, 0]);
    zrect.push([-iphi1, phi1, 0]);

    var yrect = [];
    yrect.push([-phi1, 0, -iphi1]);
    yrect.push([phi1, 0, -iphi1]);
    yrect.push([phi1, 0, iphi1]);
    yrect.push([-phi1, 0, iphi1]);

    if (false) {
        // Draw debug lines to show structures within the dodecahedron:
        // the vertices form a cube and three rectanges on each axis.
        Debug.color(1, 0.65, 0, 1);
        Debug.line(cubeBot[0], cubeBot[1]);
        Debug.line(cubeBot[1], cubeBot[2]);
        Debug.line(cubeBot[2], cubeBot[3]);
        Debug.line(cubeBot[3], cubeBot[0]);

        Debug.line(cubeTop[0], cubeTop[1]);
        Debug.line(cubeTop[1], cubeTop[2]);
        Debug.line(cubeTop[2], cubeTop[3]);
        Debug.line(cubeTop[3], cubeTop[0]);

        Debug.line(cubeBot[0], cubeTop[0]);
        Debug.line(cubeBot[1], cubeTop[1]);
        Debug.line(cubeBot[2], cubeTop[2]);
        Debug.line(cubeBot[3], cubeTop[3]);

        Debug.color(0, 0.8, 0, 1);
        Debug.line(xrect[0], xrect[1]);
        Debug.line(xrect[1], xrect[2]);
        Debug.line(xrect[2], xrect[3]);
        Debug.line(xrect[3], xrect[0]);

        Debug.color(0, 0.1, 1.0, 1);
        Debug.line(zrect[0], zrect[1]);
        Debug.line(zrect[1], zrect[2]);
        Debug.line(zrect[2], zrect[3]);
        Debug.line(zrect[3], zrect[0]);

        Debug.color(1, 0.2, 0.8, 1);
        Debug.line(yrect[0], yrect[1]);
        Debug.line(yrect[1], yrect[2]);
        Debug.line(yrect[2], yrect[3]);
        Debug.line(yrect[3], yrect[0]);
    }

    var mesh = new Mesh3D();

    function penta(a, b, c, d, e) {
        mesh.triangle(a, e, d);
        mesh.triangle(a, d, c);
        mesh.triangle(a, c, b);
    }

    penta(cubeTop[0], xrect[1], cubeTop[1], zrect[1], zrect[0]);
    penta(cubeTop[2], xrect[2], cubeTop[3], zrect[3], zrect[2]);

    penta(cubeBot[1], xrect[0], cubeBot[0], zrect[0], zrect[1]);
    penta(cubeBot[3], xrect[3], cubeBot[2], zrect[2], zrect[3]);

    penta(xrect[0], xrect[3], cubeBot[3], yrect[0], cubeBot[0]);
    penta(xrect[3], xrect[0], cubeBot[1], yrect[1], cubeBot[2]);

    penta(xrect[2], xrect[1], cubeTop[0], yrect[3], cubeTop[3]);
    penta(xrect[1], xrect[2], cubeTop[2], yrect[2], cubeTop[1]);

    penta(cubeTop[2], zrect[2], cubeBot[2], yrect[1], yrect[2]);
    penta(cubeBot[1], zrect[1], cubeTop[1], yrect[2], yrect[1]);

    penta(cubeBot[3], zrect[3], cubeTop[3], yrect[3], yrect[0]);
    penta(cubeTop[0], zrect[0], cubeBot[0], yrect[0], yrect[3]);

    return Solid.make(mesh);
}
</pre>

<h1 id="icosahedron">Icosahedron</h1>

<p>Finally we have the icosahedron. Again looking at <a href="http://en.wikipedia.org/wiki/Icosahedron#Cartesian_coordinates">the Wikipedia article</a>, there are a number of ways to construct this solid:</p>

<ul class="plist">
<li>In a similar way as the dodecahedron, using three rectangles for vertex placement. These have the nice property of being so-called <em>golden rectangles</em>, i.e. the aspect ratio of each rectangle is <em>&#934; : 1</em>, where &#934; (phi) is the golden ratio that we encountered earlier.</li>
<li>A regular octahedron can be subdivided along its edges so that the resulting vertices define an icosahedron. In this case the edges are subdivided using the golden ratio (once again).</li>
<li>It's also possible to use spherical coordinates to define an icosahedron. This is a mathematically somewhat more complex way to build the shape, but once the work is done, it can be expanded to other shapes that can be easily defined in spherical coordinates.</li>
</ul>

<p>Let's take a shortcut and create an icosahedron using the last approach, but instead of doing all the work ourselves, we'll just modify the existing <em>Sphere</em> example script.</p>

<div class='pbreak'></div>

<p>You can load the Sphere script either by creating a new shape or by choosing it from the list of example scripts:</p>

<div style="width: 100%"><img src="{@ResourceUrl:scripteditor-examples-menu.png}" alt="Examples" style="border: 1px solid black;"/></div>


<p>Once loaded, modify the following line in the script:</p>

<pre class="prettyprint">var ndivs = Tess.circleDivisions(r);
</pre>

<p>So that it reads:</p>

<pre class="prettyprint">var ndivs = 1;
</pre>

<p>Press <span class="ui-element">Save</span>, and you'll see the sphere replaced with an icosahedron.</p>

<p>Try changing <code>ndivs</code> to a higher value, for example 7, and the shape becomes more rounded:</p>

<div style="width: 100%"><img src="{@ResourceUrl:sphere-lod1.png}" alt="Sphere with lod=1" style="border: 1px solid black;"/></div>


<p>The sphere is generated using a <em>level-of-detail</em> (LOD) approach, so the number of faces will jump up in increments where basically each vertex of the icosahedron is subdivided into five more vertices. You can see this in the <code>while()</code> loop that calculates the LOD from the number of circle divisions: the <code>lod</code> variable is incremented for every multiple of six.</p>


<p>Ok, so we cheated a bit by making the icosahedron like this. There is another formulation available in the example scripts where the icosahedron is built as simply as possible from its basic math properties.</p>

<p>As an exercise you can try making the icosahedron in the same way as the dodecahedron: first create the three golden rectangles that define the icosahedron vertices, draw them using {Debug#line} to verify that the coordinates are what you expect, and then build the surface from triangles.</p>

<p>Thanks for reading this far! I hope you've learned something along the way. In closing, I give you this family portrait of Plato's brainchildren brought to the 21st century in the Autodesk Creative Platform. May your endeavors in the world of solid geometry be rewarding and fruitful.</p>

<div style="width: 100%"><img src="{@ResourceUrl:platonic-family-portrait.png}" style="border: 1px solid black;"/></div>

@topic Platonic Solid Generator - Part 2
@unlisted
**/
//refset.js

// Use the global index to avoid the clash when the same object is added to different sets.

var KEY_ATTR = '##key';

var generateKeyFromObject = function(){
	var index = 1;
	return function (ref){
	    if(!ref[KEY_ATTR]){
	        var uniqueKey="##uniqueKey" + (index++).toString();
	        Object.defineProperty(ref, KEY_ATTR, {
	            writable: false,
	            enumerable: false,
	            configurable: false,
	            value: uniqueKey
	        });
	   }
	    return ref[KEY_ATTR];
	}
}();


/**
Reference set  
@class _RefSet
@since 1.10.0
@private
**/
var _RefSet = function() {

	/**
	Stores the references
	@property data
	@private
	**/
    this._data = {};

};


_RefSet.prototype = {

	_add: function(ref) {
		if(typeof ref !== 'object'){
			return false;
		}
		var key = generateKeyFromObject(ref);
        if(!this._data[ key ]){
            this._data[ key ] = ref;
            return true;
        }

        return false;
	}, 

	_remove: function(ref) {
		if(typeof ref !== 'object'){
			return false;
		}
		var key = ref[KEY_ATTR];
        if(key && this._data[ key ]){
            delete this._data[ key ];
            return true;
        }

        return false;
	}, 

	_clear: function() {
		this._data = {};
	}, 

	_size: function() {
		return Object.keys(this._data).length;
	},

	_toArray: function(){
		var data = this._data;
		var keys = Object.keys(data);
		var len = keys.length;
		var i, arr=[];
		for (i = 0; i < len; i++) {
		  	arr.push(data[keys[i]]);
		}

		return arr;
	}
};


/**
It's a set to store the object references and provides the item added / removed event for client to subscribe. 
@class RefSet
@constructor
@since 1.10.0
@public
**/
var RefSet = function() {

	/**
    Creates the IMPL such that clients can't see it. Reference to the internal class.
    @private 
    @property {_Mesh3D} _impl
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _RefSet()
    });

    /**
	Event will be fired when an item is added.
	@event itemAdded
	@public
	@type {EventSource}
	**/
    this.itemAdded = new EventSource('itemadded');

    /**
	Event will be fired when an item is removed.
	@event itemRemoved
	@public
	@type {EventSource}
	**/
    this.itemRemoved = new EventSource('itemremoved');

};

RefSet.prototype = {

	/**
    Adds the reference to the set and fires the itemAdded event
    @method add
    @since 1.10.0
    @param {Object} ref the object to add
    @public
    @chainable
    **/
	add: function(ref) {
		if(this._impl._add(ref)){
			this.itemAdded.fire(ref);
		}
		return this;
	},

	/**
    Removes the reference from the set and fires the itemRemoved event. It returns a {Boolean} value to indicate if the removal succeeds
    @method remove
    @since 1.10.0
    @param {Object} ref the object to remove
    @return {Boolean} 
    @public
    **/
	remove: function(ref) {
		if (this._impl._remove(ref)){
			this.itemRemoved.fire(ref);	
			return true;
		}
		return false;
	}, 

	/**
	Clears all refs and fires the itemRemoved event for each removed ref
    @method clear
    @since 1.10.0
    @public
    @chainable
    **/
	clear: function(){
		var data = this._impl._data;
		var keys = Object.keys(data);
		var len = keys.length;
		for (var i = 0; i < len; i++) {
		  	this.remove(data[keys[i]]);
		}

		this._impl._clear();
		return this;

	},
	/**
	Returns the number of reference in the set
	@method size
	@since 1.10.0
	@return {Number} the number of the reference
	@public
	**/
	size: function(){
		return this._impl._size();
	},

	/**
	Returns an array containing all the reference objects 
	@method toArray
	@return {Array} the array that contains all the references
	@since 1.10.0
	@public
	**/
	toArray: function(){
		return this._impl._toArray();
	}
}


Library.exports.RefSet = RefSet;
initializeObjectMethods(RefSet, 'RefSet');
//footer.js
	};

	Host.creativePlatformLibrary1vxKXGNaLtrrev0 = creativePlatformLibrary1vxKXGNaLtrrev0;

})(typeof exports === 'undefined' ? window : exports);
//# sourceMappingURL=library.map
//header.js
/**
Welcome to the Autodesk Creative Platform UI Toolkit.  The team at Autodesk is really proud of the new 
UI Toolkit we've provided our users and partners.  The new UI Toolkit provides two important things:
<ul>
	<li><b>Templates</b><p>HTML5 templates are built using <a href="http://handlebarsjs.com/">Handlebars</a>, and industry-proven open technology.  
By adopting <a href="http://handlebarsjs.com/">Handlebars</a> our goals are to make it easy for others to incorporate the templates and build
templates that augment these easily and openly.</p></li>
	<li><b>Controls</b><p>Classes that provide behavioral and functional abilities to the templates.</p></li>
</ul>
Our goal is to provide best-in-class UX experiences and controls that can be leveraged anywhere.
@module aZS9YbvfqUX
@main
**/
(function(Host){

	"use strict";

	// This list of methods is taken from the following URL
	// https://developer.mozilla.org/en-US/docs/Web/API/console
	var console = {
		dir: function() { },
		error: function() { },
		group: function() { },
		groupCollapsed: function() { },
		groupEnd: function() { },
		info: function() { },
		log: function() { },
		time: function() { },
		timeEnd: function() { },
		trace: function() { },
		warn: function() { }
	};

	var creativePlatformLibraryaZS9YbvfqUXrev0 = function(Environment, Library){

		var CoreLibrary = Environment.libraryExports("1vxKXGNaLtr", 0);
		var Controls = {};
		var utility = null;
//manifest.js
if (Library) {
	Library.name = "Autodesk Creative Platform UI Toolkit";
	Library.description = "Comprehensive set of reusable HTML5 controls and templates";
	Library.resources = [
		{ "id": "gHWG9uWl87e", "name": "core.css" }
		,{ "id": "gsxjRGSdB1t", "name": "core-sprite1.png" }
		,{ "id": "7qjfMGq1dUt", "name": "example-logo.png" }
		,{ "id": "bAznT3KNk0P", "name": "example-logo-1.png" }
		,{ "id": "9kjxbRkb3Fg", "name": "example-logo-2.png" }
		,{ "id": "jo4vOHKkZbg", "name": "example-logo-3.png" }
		,{ "id": "aUB96jivLsf", "name": "example-logo-4.png" }
		,{ "id": "lpskZy35jqS", "name": "example-logo-5.png" }
		,{ "id": "5AVq1kgMAuJ", "name": "example-logo-6.png" }
		,{ "id": "bJyMcjOL4rh", "name": "example-logo-7.png" }
		,{ "id": "6kXjtkkecOE", "name": "example-logo-8.png" }
		,{ "id": "9Msi11eIBRz", "name": "robot-main-image.png" }
		,{ "id": "4bI6D76DZEv", "name": "robot-part-0.png" }
		,{ "id": "8XpShR8ppPW", "name": "robot-part-1.png" }
		,{ "id": "05Exgy4pdoP", "name": "robot-part-2.png" }
		,{ "id": "5IVMZn3tmk4", "name": "robot-part-3.png" }
		,{ "id": "73biEtB2zgM", "name": "robot-part-4.png" }
		,{ "id": "dzH4SlWMkFm", "name": "robot-part-5.png" }
		,{ "id": "crX3EY2kQ9t", "name": "robot-part-6.png" }
		,{ "id": "7wuQ0vKZb4X", "name": "robot-map-image.png" }
		,{ "id": "eNUXHkS64GG", "name": "randomize-button.png" }
		,{ "id": "gg7kPMXYisP", "name": "content-builder.css" }
		,{ "id": "hg4uUVY6UJB", "name": "content-builder-sprite1.png" }
	];
}
//3rd.js
/**
Handlebars provides a way to build semantic templates and is used as the basis of the UI Toolkit.
@opensource Handlebars 1.0.0
@websiteurl http://handlebarsjs.com
@downloadurl http://builds.handlebarsjs.com.s3.amazonaws.com/handlebars-1.0.0.js
@licenseurl https://github.com/wycats/handlebars.js/blob/master/LICENSE
@licensetext Copyright (C) 2011-2014 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
@source handlebars.runtime.js 
@symbols Handlebars
**/

/**
jQuery is a set of client-side utilities for DOM manipulation.
@opensource jQuery 1.7.2
@websiteurl http://jquery.com/
@downloadurl http://code.jquery.com/jquery-1.7.2.min.js
@licenseurl https://jquery.org/license/
@licensetext Copyright 2014 jQuery Foundation and other contributors
http://jquery.com/

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
@source jquery.min.js
@symbols $, jQuery
**/
//output.handlebars.js
(function() {
  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};
templates['2dsketch'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n				";
  stack1 = self.invokePartial(partials.checkbox, 'checkbox', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n			";
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" style=\"width:";
  if (stack1 = helpers.width) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.width; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ";height:";
  if (stack1 = helpers.height) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.height; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + ";\" class=\"";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ui-sketch\">\n	<canvas id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "Canvas\" width=\"";
  if (stack1 = helpers.width) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.width; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" height=\"";
  if (stack1 = helpers.height) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.height; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"></canvas>\n	<div class=\"ui-sketch-settings\" title=\"Edit sketch settings\">\n		<div class=\"ui-sketch-settings-con\">\n			";
  stack1 = helpers['with'].call(depth0, depth0.checkbox, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n		</div>\n	</div>\n</div>";
  return buffer;
  });
templates['accordion'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-accordion";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"></div>\n";
  return buffer;
  });
templates['accordionitem'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-accordion-item\">\n	<div class=\"ui-accordion-item-icon\"></div>\n	<div class=\"ui-accordion-item-header\">";
  if (stack1 = helpers.header) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.header; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</div>\n	<div class=\"ui-accordion-item-content\">";
  if (stack1 = helpers.content) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.content; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</div>\n</div>\n";
  return buffer;
  });
templates['button'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += "\n		";
  options = {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data};
  stack2 = ((stack1 = helpers.compare || depth0.compare),stack1 ? stack1.call(depth0, ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.position), "eq", "left", options) : helperMissing.call(depth0, "compare", ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.position), "eq", "left", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n		";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data};
  stack2 = ((stack1 = helpers.compare || depth0.compare),stack1 ? stack1.call(depth0, ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.position), "eq", "right", options) : helperMissing.call(depth0, "compare", ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.position), "eq", "right", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n		";
  options = {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data};
  stack2 = ((stack1 = helpers.compare || depth0.compare),stack1 ? stack1.call(depth0, ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.position), "eq", "top", options) : helperMissing.call(depth0, "compare", ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.position), "eq", "top", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n		";
  options = {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data};
  stack2 = ((stack1 = helpers.compare || depth0.compare),stack1 ? stack1.call(depth0, ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.position), "eq", "bottom", options) : helperMissing.call(depth0, "compare", ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.position), "eq", "bottom", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n	";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "\n			<img src=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.url)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"ui-button-icon ui-button-icon-left\" style=\"width:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.width)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px; height:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.height)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px;\"></img>\n			<span class=\"ui-button-text ui-button-text\" style=\"height:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.height)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px; line-height:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.height)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px;\">";
  if (stack2 = helpers.text) { stack2 = stack2.call(depth0, {hash:{},data:data}); }
  else { stack2 = depth0.text; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span>\n		";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "\n			<span class=\"ui-button-text ui-button-text\" style=\"height:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.height)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px; line-height:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.height)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px;\">";
  if (stack2 = helpers.text) { stack2 = stack2.call(depth0, {hash:{},data:data}); }
  else { stack2 = depth0.text; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span>\n			<img src=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.url)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"ui-button-icon ui-button-icon-right\" style=\"width:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.width)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px; height:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.height)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px;\"></img>\n		";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "\n			<img src=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.url)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"ui-button-icon ui-button-icon-top\" style=\"width:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.width)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px; height:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.height)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px;\"></img>\n			<span class=\"ui-button-text ui-button-text\" style=\"display:block;\">";
  if (stack2 = helpers.text) { stack2 = stack2.call(depth0, {hash:{},data:data}); }
  else { stack2 = depth0.text; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</span>\n		";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n			<span class=\"ui-button-text ui-button-text\" style=\"display:block;\">";
  if (stack1 = helpers.text) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</span>\n			<img src=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.url)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"ui-button-icon ui-button-icon-top\" style=\"width:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.width)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px; height:"
    + escapeExpression(((stack1 = ((stack1 = depth0.icon),stack1 == null || stack1 === false ? stack1 : stack1.height)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "px;\"></img>\n		";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n		";
  if (stack1 = helpers.text) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "	\n	";
  return buffer;
  }

  buffer += "<button id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-button";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	";
  stack1 = helpers['if'].call(depth0, depth0.icon, {hash:{},inverse:self.program(12, program12, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</button>\n";
  return buffer;
  });
templates['checkbox'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "<label class=\"ui-checkbox-label ";
  stack1 = helpers['if'].call(depth0, depth0.labelCss, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" for=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">";
  if (stack1 = helpers.text) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</label>";
  return buffer;
  }
function program2(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.labelCss) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.labelCss; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program6(depth0,data) {
  
  
  return "checked=\"checked\"";
  }

  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data};
  stack2 = ((stack1 = helpers.compare || depth0.compare),stack1 ? stack1.call(depth0, depth0.labelPosition, "eq", "left", options) : helperMissing.call(depth0, "compare", depth0.labelPosition, "eq", "left", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "<input id=\"";
  if (stack2 = helpers.id) { stack2 = stack2.call(depth0, {hash:{},data:data}); }
  else { stack2 = depth0.id; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "\" type=\"checkbox\" class=\"ui-checkbox";
  stack2 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\" ";
  stack2 = helpers['if'].call(depth0, depth0.checked, {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "></input>";
  options = {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data};
  stack2 = ((stack1 = helpers.compare || depth0.compare),stack1 ? stack1.call(depth0, depth0.labelPosition, "neq", "left", options) : helperMissing.call(depth0, "compare", depth0.labelPosition, "neq", "left", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  return buffer;
  });
templates['dialog'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

function program3(depth0,data) {
  
  
  return "style=\"display:none;\"";
  }

function program5(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.contentcss) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.contentcss; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-dialog ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	<div class=\"ui-dialog-close\" ";
  stack1 = helpers['if'].call(depth0, depth0.hideClose, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></div>\n	<div class=\"ui-dialog-content\" ";
  stack1 = helpers['if'].call(depth0, depth0.contentcss, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"></div>\n	<div class=\"ui-dialog-footer\" ";
  stack1 = helpers['if'].call(depth0, depth0.hideFooter, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></div>\n</div>\n";
  return buffer;
  });
templates['docklayout'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, stack2, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "<div class=\"ui-dock-layout-left\">";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.left)),stack1 == null || stack1 === false ? stack1 : stack1.resizable), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "</div>";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return "<div class=\"ui-dock-layout-left-resizer\"><div>....</div></div>";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "<div class=\"ui-dock-layout-center\">";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.center)),stack1 == null || stack1 === false ? stack1 : stack1.top), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.center)),stack1 == null || stack1 === false ? stack1 : stack1.middle), {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.center)),stack1 == null || stack1 === false ? stack1 : stack1.bottom), {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "</div>";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "<div class=\"ui-dock-layout-top\">";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.center)),stack1 == null || stack1 === false ? stack1 : stack1.top)),stack1 == null || stack1 === false ? stack1 : stack1.resizable), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "</div>";
  return buffer;
  }
function program8(depth0,data) {
  
  
  return "<div class=\"ui-dock-layout-top-resizer\"><div>....</div></div>";
  }

function program10(depth0,data) {
  
  
  return "<div class=\"ui-dock-layout-middle\"></div>";
  }

function program12(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "<div class=\"ui-dock-layout-bottom\">";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.center)),stack1 == null || stack1 === false ? stack1 : stack1.bottom)),stack1 == null || stack1 === false ? stack1 : stack1.resizable), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "</div>";
  return buffer;
  }
function program13(depth0,data) {
  
  
  return "<div class=\"ui-dock-layout-bottom-resizer\"><div>....</div></div>";
  }

function program15(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "<div class=\"ui-dock-layout-right\">";
  stack2 = helpers['if'].call(depth0, ((stack1 = ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.right)),stack1 == null || stack1 === false ? stack1 : stack1.resizable), {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "</div>";
  return buffer;
  }
function program16(depth0,data) {
  
  
  return "<div class=\"ui-dock-layout-right-resizer\"><div>....</div></div>";
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-dock-layout ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	";
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.left), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.center), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  stack2 = helpers['if'].call(depth0, ((stack1 = depth0.dock),stack1 == null || stack1 === false ? stack1 : stack1.right), {hash:{},inverse:self.noop,fn:self.program(15, program15, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n</div>";
  return buffer;
  });
templates['dropdown'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.tabindex) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.tabindex; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

function program5(depth0,data) {
  
  var stack1;
  if (stack1 = helpers.title) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.title; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  return escapeExpression(stack1);
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n			";
  stack1 = helpers['if'].call(depth0, depth0.text, {hash:{},inverse:self.program(13, program13, data),fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n		";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n				";
  stack1 = helpers['if'].call(depth0, depth0.selected, {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n			";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n					<li id=\""
    + escapeExpression(((stack1 = depth0.value),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "_Li\" tag=\""
    + escapeExpression(((stack1 = depth0.value),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" selected=\"selected\" title=\""
    + escapeExpression(((stack1 = depth0.text),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">"
    + escapeExpression(((stack1 = depth0.text),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</li>\n				";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n					<li id=\""
    + escapeExpression(((stack1 = depth0.value),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "_Li\" tag=\""
    + escapeExpression(((stack1 = depth0.value),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" title=\""
    + escapeExpression(((stack1 = depth0.text),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">"
    + escapeExpression(((stack1 = depth0.text),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</li>\n				";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "";
  buffer += "\n				<li id=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "_Li\" tag=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\" title=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\">"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "</li>\n			";
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-dropdown";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" tabindex=\"";
  stack1 = helpers['if'].call(depth0, depth0.tabindex, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n    <div id=\"ui-dropdown-icon\" class=\"ui-dropdown-icon\">▼</div>\n	<input id=\"ui-dropdown-input";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-dropdown-input\" title=\"";
  stack1 = helpers['if'].call(depth0, depth0.title, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" tabindex=\"0\" readonly=\"readonly\">\n	<ul id=\"ui-dropdown-list";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-dropdown-list\">\n		";
  stack1 = helpers.each.call(depth0, depth0.items, {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	</ul>\n</div>\n";
  return buffer;
  });
templates['error'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "style=\"display:block\"";
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-error\">\n    <div class=\"ui-icon-container\">\n        <div class=\"ui-icon-error\"></div>\n    </div>\n    <div class=\"ui-verticalLine\" />\n    <div class=\"ui-description-container\">\n        <div class=\"ui-error-title\" ";
  stack1 = helpers['if'].call(depth0, depth0.title, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">";
  if (stack1 = helpers.title) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.title; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"ui-error-desc\">";
  if (stack1 = helpers.description) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.description; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</div>  \n    </div>\n    <div class=\"ui-dialog-close ui-error-dialog-close\"></div>\n</div>\n";
  return buffer;
  });
templates['feedback'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n			";
  stack1 = self.invokePartial(partials.rating, 'rating', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n		";
  return buffer;
  }

function program5(depth0,data) {
  
  
  return "none;";
  }

function program7(depth0,data) {
  
  
  return "block;";
  }

function program9(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n			";
  stack1 = self.invokePartial(partials.textarea, 'textarea', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n		";
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-feedback ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	<div>\n		";
  stack1 = helpers['with'].call(depth0, depth0.rating, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n		<div class=\"ui-feedback-updatepanel\">\n			<span class=\"ui-feedback-label\" style=\"display:";
  stack1 = helpers['if'].call(depth0, depth0.isEdit, {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">( Not Rated )</span>\n			<span class=\"ui-feedback-button\" style=\"display:";
  stack1 = helpers['if'].call(depth0, depth0.isEdit, {hash:{},inverse:self.program(5, program5, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">( <a id=\"save\" href=\"#\" style=\"display:none;\" title=\"Save feedback\">Save</a><div class=\"ui-feedback-buttonpipe\"> | </div><a id=\"clear\" href=\"#\" title=\"Delete feedback\">Delete</a> )</span>\n		</div>\n	</div>\n	<div style=\"clear:both;padding-top:5px;\">\n		";
  stack1 = helpers['with'].call(depth0, depth0.comment, {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	</div>\n</div>";
  return buffer;
  });
templates['fileupload'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-fileupload ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "content\" class=\"ui-file-content\">\n		<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "contenttext\" class=\"ui-file-content-text\"></div>\n	</div>\n	<div class=\"ui-file-progress-container\"><div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "progress\" class=\"ui-file-progress\" style=\"display:none;\"></div></div>\n	<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "buttonContainer\" class=\"ui-file-button-container\"></div>\n	<input id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "file\" type=\"file\" style=\"display:none;\">\n	<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "message\" class=\"ui-file-message\"></div>\n</div>\n";
  return buffer;
  });
templates['hoverarea'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.iconcss) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.iconcss; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program5(depth0,data) {
  
  
  return "ui-hoverarea-icon";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.direction) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.direction; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-hoverarea ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"><div class=\"";
  stack1 = helpers['if'].call(depth0, depth0.iconcss, {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"></div><div class=\"ui-hoverarea-direction ";
  stack1 = helpers['if'].call(depth0, depth0.direction, {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"></div></div>";
  return buffer;
  });
templates['imageedit'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-imageedit ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" style=\"height:";
  if (stack1 = helpers.height) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.height; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "px; width:";
  if (stack1 = helpers.width) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.width; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "px;\">\n	<canvas id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "canvas\" height=\"";
  if (stack1 = helpers.height) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.height; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" width=\"";
  if (stack1 = helpers.width) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.width; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" style=\"border:1px solid black;\"></canvas>\n	<img id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "image\" style=\"display:none;\" /><br/>\n	<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "zoomContainer\" title=\"Scale\" class=\"ui-image-edit-zoomcontainer\"></div>\n	<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "rotateContainer\" title=\"Rotate\" class=\"ui-image-edit-rotatecontainer\"></div>\n	<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "rotateLeft\" title=\"Rotate -90°\" class=\"ui-image-edit-rotate-left\"></div>\n	<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "rotateRight\" title=\"Rotate 90°\" class=\"ui-image-edit-rotate-right\"></div>\n	<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "close\" class=\"ui-image-edit-close\"></div>\n</div>";
  return buffer;
  });
templates['imagemap'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-imagemap ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	<div class=\"ui-imagemap-container\">\n		<img id='";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-main-image' class='ui-imagemap-item' src='";
  if (stack1 = helpers.mainimage) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.mainimage; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "'></img>\n		<img id='";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-hover-image' class='ui-imagemap-item ui-imagemap-hover'></img>\n		<img id='";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-active-image' class='ui-imagemap-item ui-imagemap-active'></img>\n		<canvas id='";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "-canvas-image' class='ui-imagemap-canvas-image'></canvas>\n	</div>\n</div>";
  return buffer;
  });
templates['itemslider'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-itemslider";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n    <div id=\"previousSlide\" slideid=\"\" class=\"ui-itempreviousslide\"><div class=\"ui-itemslideicon\"></div></div>\n	<div class=\"ui-itemslidercontainer ui-itemnavigation-show\"></div>\n	<div id=\"nextSlide\" slideid=\"\" class=\"ui-itemnextslide\"><div class=\"ui-itemslideicon\"></div></div>\n</div><div style=\"clear:both;\"></div>\n";
  return buffer;
  });
templates['libraryfeedback'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n		<div class=\"ui-libraryfeedback-row1\">\n			<div class=\"ui-libraryfeedback-col1\">All</div>\n			<div class=\"ui-libraryfeedback-col2\">\n				";
  stack1 = helpers['with'].call(depth0, depth0.rating, {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n			</div>\n		</div>\n		<div class=\"ui-libraryfeedback-row2\">\n			<div class=\"ui-libraryfeedback-col1\">You</div>\n			<div id=\"feedbackControlLinks\" class=\"ui-libraryfeedback-col2 ui-libraryfeedback-margin\">\n				<a class=\"ui-libraryfeedback-give\" href=\"#\" style=\"display:";
  stack1 = helpers['if'].call(depth0, depth0.isEdit, {hash:{},inverse:self.program(8, program8, data),fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">Give Feedback!</a>\n				<a class=\"ui-libraryfeedback-update\" href=\"#\" style=\"display:";
  stack1 = helpers['if'].call(depth0, depth0.isEdit, {hash:{},inverse:self.program(6, program6, data),fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">Update Feedback</a>\n			</div>\n			<div id=\"feedbackControl\" class=\"ui-libraryfeedback-col2\" style=\"display:none;\">\n				";
  stack1 = helpers['with'].call(depth0, depth0.feedback, {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n			</div>\n		</div>\n	";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n					";
  stack1 = self.invokePartial(partials.rating, 'rating', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n				";
  return buffer;
  }

function program6(depth0,data) {
  
  
  return "none;";
  }

function program8(depth0,data) {
  
  
  return "block;";
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n					";
  stack1 = self.invokePartial(partials.feedback, 'feedback', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n				";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n		";
  stack1 = helpers['with'].call(depth0, depth0.rating, {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	";
  return buffer;
  }
function program13(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n			";
  stack1 = self.invokePartial(partials.rating, 'rating', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n		";
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-libraryfeedback ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	";
  stack1 = helpers['if'].call(depth0, depth0.isUserId, {hash:{},inverse:self.program(12, program12, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>";
  return buffer;
  });
templates['libraryfeedbackpopup'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += "\n	    <li>\n			<div class=\"ui-feedbackpopup-feedbackavatar\"><a class=\"ui-feedbackpopup-user\" target=\"_blank\" href=\"";
  if (stack1 = helpers.userprofilelink) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.userprofilelink; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"><img src=\"";
  if (stack1 = helpers.avtar) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.avtar; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" /></a></div>\n			<div class=\"ui-feedbackpopup-details\">\n				";
  stack1 = helpers['with'].call(depth0, depth0.rating, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n				<div class=\"ui-feedbackpopup-ratingstring\">("
    + escapeExpression(((stack1 = ((stack1 = depth0.rating),stack1 == null || stack1 === false ? stack1 : stack1.rating)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " out of 5 Stars)</div>\n				";
  options = {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data),data:data};
  stack2 = ((stack1 = helpers.compare || depth0.compare),stack1 ? stack1.call(depth0, depth0.feedback, "eq", "", options) : helperMissing.call(depth0, "compare", depth0.feedback, "eq", "", options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n				<div class=\"ui-feedbackpopup-time\">";
  if (stack2 = helpers.datetime) { stack2 = stack2.call(depth0, {hash:{},data:data}); }
  else { stack2 = depth0.datetime; stack2 = typeof stack2 === functionType ? stack2.apply(depth0) : stack2; }
  buffer += escapeExpression(stack2)
    + "</div>\n			</div>\n	    </li>\n	";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n					";
  stack1 = self.invokePartial(partials.rating, 'rating', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n				";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n					<div class=\"ui-feedbackpopup-comments\"><a class=\"ui-feedbackpopup-user\" target=\"_blank\" href=\"";
  if (stack1 = helpers.userprofilelink) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.userprofilelink; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"><b>";
  if (stack1 = helpers.username) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.username; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</b></a></div>\n				";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n					<div class=\"ui-feedbackpopup-comments\"><a class=\"ui-feedbackpopup-user\" target=\"_blank\" href=\"";
  if (stack1 = helpers.userprofilelink) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.userprofilelink; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"><b>";
  if (stack1 = helpers.username) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.username; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</b></a> provided feedback: \"";
  if (stack1 = helpers.feedback) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.feedback; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"</div>\n				";
  return buffer;
  }

  buffer += "<ul class=\"ui-feedbackpopup-ul\">\n	";
  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</ul>\n<a class=\"ui-feedbackpopup-showall\" id=\"lnkshowall\" href=\"#\">Show all...</a>";
  return buffer;
  });
templates['panel'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n	<div class=\"ui-panel-header\" ";
  stack1 = helpers.unless.call(depth0, depth0.title, {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n		<span class=\"ui-panel-header-title\">";
  if (stack1 = helpers.title) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.title; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</span>\n		";
  stack1 = helpers['if'].call(depth0, depth0.collapsible, {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	</div><img class=\"ui-panel-icon\"></img><div class=\"ui-panel-content\"></div>";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return "style=\"display:none;\"";
  }

function program6(depth0,data) {
  
  
  return "<div class=\"ui-panel-header-collapse-button\"></div>";
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-panel ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	";
  stack1 = helpers.unless.call(depth0, depth0.suppressheader, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>";
  return buffer;
  });
templates['popup'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.cornercss) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.cornercss; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-popup ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	";
  if (stack1 = helpers.content) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.content; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	<div class=\"ui-popup-corner ";
  stack1 = helpers['if'].call(depth0, depth0.cornercss, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n		<div id=\"corner\" class=\"ui-popup-arrowblack\"></div>\n    	<div id=\"corner\" class=\"ui-popup-arrowwhite\"></div>\n	</div>\n</div>";
  return buffer;
  });
templates['progressbar'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-progressdialog\">\n    <div id=\"infinite\">\n        <div class=\"ui-indicator-container\">\n            <div class=\"ui-infinite-indicator\"></div>\n        </div>\n        <div class=\"ui-verticalLine\" />\n        <div class=\"ui-description-container\">\n            <div class=\"ui-progressdialog-title\">";
  if (stack1 = helpers.progressTitle) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.progressTitle; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</div>\n            <div class=\"ui-progressdialog-desc\">";
  if (stack1 = helpers.progressDesc) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.progressDesc; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</div>  \n        </div>\n    </div>\n    <div id=\"finite\">\n        <div class=\"ui-progressdialog-title\">";
  if (stack1 = helpers.progressTitle) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.progressTitle; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"ui-progressdialog-desc\">";
  if (stack1 = helpers.progressDesc) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.progressDesc; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"ui-progressbar\">\n            <div class=\"ui-progressbar-background\">\n                <div class=\"ui-progressbar-fill\"></div>\n            </div>\n        </div>\n    </div>\n</div>\n";
  return buffer;
  });
templates['rating'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += "\n		<div class=\"ui-rating\">\n			";
  options = {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data};
  stack2 = ((stack1 = helpers.times || depth0.times),stack1 ? stack1.call(depth0, depth0.rating, options) : helperMissing.call(depth0, "times", depth0.rating, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n			";
  options = {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data};
  stack2 = ((stack1 = helpers.times || depth0.times),stack1 ? stack1.call(depth0, depth0.max, options) : helperMissing.call(depth0, "times", depth0.max, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n			";
  options = {hash:{},inverse:self.program(11, program11, data),fn:self.program(8, program8, data),data:data};
  stack2 = ((stack1 = helpers.compare || depth0.compare),stack1 ? stack1.call(depth0, depth0.reviewCount, "eq", 0, options) : helperMissing.call(depth0, "compare", depth0.reviewCount, "eq", 0, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n		</div>\n	";
  return buffer;
  }
function program4(depth0,data) {
  
  
  return "\n				<div class=\"inline-div rating-stars-marked\">★</div>";
  }

function program6(depth0,data) {
  
  
  return "\n				<div class=\"inline-div rating-stars-unmarked\">★</div>\n			";
  }

function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n				<div ";
  stack1 = helpers['if'].call(depth0, depth0.hideReviewCount, {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " class=\"inline-div rating-count\"><a id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "ratingCount\" href=\"#\"></a></div>\n			";
  return buffer;
  }
function program9(depth0,data) {
  
  
  return "style=\"display:none;\"";
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += "\n				";
  options = {hash:{},inverse:self.program(14, program14, data),fn:self.program(12, program12, data),data:data};
  stack2 = ((stack1 = helpers.compare || depth0.compare),stack1 ? stack1.call(depth0, depth0.reviewCount, "eq", 1, options) : helperMissing.call(depth0, "compare", depth0.reviewCount, "eq", 1, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n			";
  return buffer;
  }
function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n					<div ";
  stack1 = helpers['if'].call(depth0, depth0.hideReviewCount, {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " class=\"inline-div rating-count\"><a id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "ratingCount\" href=\"#\">(";
  if (stack1 = helpers.reviewCount) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.reviewCount; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " Review)</a></div>\n				";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n					<div ";
  stack1 = helpers['if'].call(depth0, depth0.hideReviewCount, {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " class=\"inline-div rating-count\"><a id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "ratingCount\" href=\"#\">(";
  if (stack1 = helpers.reviewCount) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.reviewCount; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + " Reviews)</a></div>\n				";
  return buffer;
  }

function program16(depth0,data) {
  
  var buffer = "", stack1, stack2, options;
  buffer += "\n		<fieldset id=\"ratings";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-rating\">\n			";
  options = {hash:{},inverse:self.noop,fn:self.programWithDepth(17, program17, data, depth0),data:data};
  stack2 = ((stack1 = helpers.reversefor || depth0.reversefor),stack1 ? stack1.call(depth0, depth0.max, 0, 1, options) : helperMissing.call(depth0, "reversefor", depth0.max, 0, 1, options));
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n		</fieldset>	\n	";
  return buffer;
  }
function program17(depth0,data,depth1) {
  
  var buffer = "", stack1;
  buffer += "\n				<input type=\"radio\" id=\"ctrl"
    + escapeExpression(((stack1 = depth1.id),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "star"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\" name=\"rating"
    + escapeExpression(((stack1 = depth1.id),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" value=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\" /><label for=\"ctrl"
    + escapeExpression(((stack1 = depth1.id),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "star"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\">★</label>\n			";
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	";
  stack1 = helpers['if'].call(depth0, depth0.readonly, {hash:{},inverse:self.program(16, program16, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n\n";
  return buffer;
  });
templates['slider'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "ui-slider-area-has-text";
  }

function program5(depth0,data) {
  
  
  return "<div class=\"ui-slider-text\"></div>";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n			";
  stack1 = self.invokePartial(partials.textbox, 'textbox', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	";
  return buffer;
  }

  buffer += "<div id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-slider ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	<div class=\"ui-slider-area ";
  stack1 = helpers['if'].call(depth0, depth0.showtext, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n		<a class=\"ui-slider-handle\"><div class=\"ui-slider-icon\"></div></a>\n		<div class=\"ui-slider-background\"></div>\n	</div>\n	";
  stack1 = helpers['if'].call(depth0, depth0.showtext, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	";
  stack1 = helpers['with'].call(depth0, depth0.input, {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>";
  return buffer;
  });
templates['tab'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  
  return " style='display:none;'";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "<div id='"
    + escapeExpression(((stack1 = depth0.tabid),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "_TabHeader' class='ui-tabbutton ";
  stack2 = helpers['if'].call(depth0, depth0.headerCss, {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  stack2 = helpers['if'].call(depth0, depth0.isSelected, {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "' Tab='"
    + escapeExpression(((stack1 = depth0.tabid),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "' ";
  stack2 = helpers['if'].call(depth0, depth0.isSelected, {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += ">";
  stack2 = helpers['if'].call(depth0, depth0.headerImageStyle, {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += escapeExpression(((stack1 = depth0.headerText),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</div>";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + escapeExpression(((stack1 = depth0.headerCss),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

function program8(depth0,data) {
  
  
  return " ui-tabbuttonselected";
  }

function program10(depth0,data) {
  
  
  return "Selected='true'";
  }

function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "<div class='"
    + escapeExpression(((stack1 = depth0.headerImageStyle),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "'></div>";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "\n			<div id='"
    + escapeExpression(((stack1 = depth0.tabid),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "' class='ui-tabcontent ";
  stack2 = helpers['if'].call(depth0, depth0.contentCss, {hash:{},inverse:self.noop,fn:self.program(15, program15, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += " ";
  stack2 = helpers['if'].call(depth0, depth0.tabContent, {hash:{},inverse:self.noop,fn:self.program(17, program17, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "' ";
  stack2 = helpers.unless.call(depth0, depth0.isSelected, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += ">\n				"
    + escapeExpression(((stack1 = depth0.tabContent),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n			</div>\n		";
  return buffer;
  }
function program15(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + escapeExpression(((stack1 = depth0.contentCss),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  return buffer;
  }

function program17(depth0,data) {
  
  
  return " ui-tabcontentborder";
  }

  buffer += "<div id='";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "' class='ui-tab ";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "'>\n	<div class='ui-tabheaderlabel' ";
  stack1 = helpers.unless.call(depth0, depth0.tabHeader, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">";
  if (stack1 = helpers.tabHeader) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.tabHeader; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</div>\n	<div class='ui-tabheadercontainer'>\n		";
  stack1 = helpers.each.call(depth0, depth0.tabs, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	</div>\n	<div class='ui-tabcontainer'>\n		";
  stack1 = helpers.each.call(depth0, depth0.tabs, {hash:{},inverse:self.noop,fn:self.program(14, program14, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	</div>\n</div>";
  return buffer;
  });
templates['taglist'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n		<li val='";
  stack1 = helpers['if'].call(depth0, depth0.value, {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "' class=\"ui-tagitem ";
  stack1 = helpers['if'].call(depth0, depth0.selected, {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">";
  stack1 = helpers['if'].call(depth0, depth0.text, {hash:{},inverse:self.program(12, program12, data),fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "<a class=\"ui-tagitem-close\">x</a></li>\n	";
  return buffer;
  }
function program4(depth0,data) {
  
  var stack1;
  return escapeExpression(((stack1 = depth0.value),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  }

function program6(depth0,data) {
  
  
  return escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0));
  }

function program8(depth0,data) {
  
  
  return " selected ";
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " "
    + escapeExpression(((stack1 = depth0.text),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "";
  buffer += " "
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + " ";
  return buffer;
  }

  buffer += "<ul id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-taglist";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n	";
  stack1 = helpers.each.call(depth0, depth0.tags, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <li class=\"ui-tag-new\">\n    	<input id=\"txtNewTag";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" type=\"text\" class=\"ui-tag-input\">\n    </li>\n</ul>";
  return buffer;
  });
templates['textarea'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " maxlength=\"";
  if (stack1 = helpers.maxlength) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.maxlength; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

  buffer += "<textarea id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" type=\"text\" placeholder=\"";
  if (stack1 = helpers.placeholder) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.placeholder; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"ui-textarea";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers['if'].call(depth0, depth0.maxlength, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">";
  if (stack1 = helpers.text) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "</textarea>";
  return buffer;
  });
templates['textbox'] = template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  if (stack1 = helpers.css) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.css; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " maxlength=\"";
  if (stack1 = helpers.maxlength) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.maxlength; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

  buffer += "<input id=\"";
  if (stack1 = helpers.id) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.id; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" type=\"text\" class=\"ui-textbox";
  stack1 = helpers['if'].call(depth0, depth0.css, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" placeholder=\"";
  if (stack1 = helpers.placeholder) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.placeholder; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" value=\"";
  if (stack1 = helpers.text) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" ";
  stack1 = helpers['if'].call(depth0, depth0.maxlength, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></input>";
  return buffer;
  });
})();
//uitoolkit.js
/**
Static utility class. 

@class Utility
@namespace Controls
@static
@since 1.0.0
@example
function loadTheme() {

    //Load theme css based on theme id.
    Utility.loadTheme(Themes.Tinkercad); 

}
**/
var Utility =  (function() {
	
	return {
		/**
		* Load css file from url.
		* @public       
		* @method loadCSS
		* @param {String|Array[String]} link An url of css file or an array containing multiple css urls.
		* @param {Function(boolean)} [callback] A callback function will be called once css loaded in document. Success flag will be passed as an argument of this callback.
		* @param {String} [themeId] An id of theme css.
		* @param {Boolean} [forceLoad] Force load the css file. By default it is set to true.
		*/
		loadCSS: function (link, callback, themeId, forceLoad) {
			if(!link) return;
			var cssCount = 0;
			if(typeof link == 'string') {
				link = [link];
			}

			var _loadCss = function(url) {
				forceLoad = forceLoad !== undefined ? forceLoad : true;
				if(forceLoad) {
					if(url.indexOf('?') !== -1) url = url + '&_t=' + Date.now();
					else url = url + '?_t=' + Date.now();
				}
				var csselement = document.createElement("link");
				csselement.href = url;
				csselement.type = "text/css";
				csselement.rel = "stylesheet";
				if(themeId) csselement.id = Library.id + '-' + themeId; //append library id so that if any css having same name exist we can skip that
				$('head').append(csselement);

				if (csselement.addEventListener) {
					csselement.addEventListener('load', function() {
						cssCount++;
						if(cssCount === link.length && callback) callback(true);
					}, false);
					csselement.addEventListener('error', function() {
						if(callback) {
							callback(false);
						}
					}, false);
				}
			}

			for (var i = 0; i < link.length; i++) {
				if(!/[?&]type=/.test(link[i]))
					_loadCss(link[i] + '?type=compiled');
				else 
					_loadCss(link[i]);
			};
		},

		/**
		* Load theme providing theme id.
		* @public
		* @method loadTheme
		* @param {Controls.Themes} themeId Theme resource id.
		* @param {Function(boolean)} [callback] A callback function will be called once css loaded in document. Success flag will be passed as an argument of this callback.
		* @param {Boolean} forceLoad Force load the theme css. By default it is set to true.
		* @since 1.1.0
		*/
		loadTheme: function (themeId, callback, forceLoad) {
			this.loadCSS(Library.resourceURL(themeId + '.css'), callback, themeId, forceLoad !== undefined ? forceLoad : true);
			//remove old theme css links so we endup having one theme css in page at a time.
			$.each(Library.exports.Themes, function(key,value) {
				if(value !== themeId)
					$("link[type='text/css'][id='" + Library.id + "-" + value + "']").remove();
			});
		},

		/**
		* Get current theme.
		* @public
		* @method currentTheme
		* @return {String} Theme name.
		* @since 1.1.0
		*/
		currentTheme: function () {
			var theme;
			$.each(Library.exports.Themes, function(key,value) {
				if($("link[type='text/css'][id='" + Library.id + "-" + value + "']").size() > 0)
					theme = key;
			});
			return theme;
		},

		/**
		* Check value is valid number or not. 
		* @public       
		* @method isNumber
		* @param {Object} val Value to check. 
		* @return {Boolean} Identifies valid number or not?
		*/
		isNumber: function (val) {
			return !isNaN(parseInt(val, 10));
		},

		/**
		* Bind dom event.
		* @public       
		* @method bindEvent
		* @param {Object} control Control on which you want to bind an event. 
		* @param {String} event Valid javascript event name. 
		* @param {Object} callback Function to bind. 
		*/
		bindEvent: function (control, event, callback) {
			if (control != null) {
				var me = this;
				$(control).bind(event, function () {
					callback.apply(me, arguments);
				});
			}
		},

		/**
		* UnbindEvent dom event.
		* @public       
		* @method unbindEvent
		* @param {Object} control Control on which you want to bind an event. 
		* @param {String} event Valid javascript event name. 
		*/
		unbindEvent: function (control, event) {
			if (control != null) {
				$(control).unbind(event);
			}
		},

		/**
		* An ajax request.
		* @public       
		* @method ajax
		* @param {Object} options Ajax request options. 
		* @return {Object} jQuery diferred object. 
		*/
		ajax : function (options) {
			var apiurl = Environment.getVariable(["urls", "api"]);
			options.url = apiurl + options.url;
			options.dataType = options.dataType || 'json';
			options.xhrFields = { withCredentials: true };
			return $.ajax(options);
		},

		/**
		* Create object url pointing to BLOB data.
		* @public       
		* @method createObjectUrl
		* @param {string} dataUrl File data in base64 stream.
		* @return {string} Valid object url pointing to BLOB data.
		*/
		createObjectUrl: function(dataUrl){
			var strBase64 = ';base64,', dataBLOB = null;
            if (dataUrl.indexOf(strBase64) == -1) {
                var parts = dataUrl.split(',');
                var contentType = parts[0].split(':')[1];
                var raw = parts[1];

                dataBLOB = new Blob([raw], {type: contentType});
            } else {
                var parts = dataUrl.split(strBase64);
                var contentType = parts[0].split(':')[1];
                var raw = window.atob(parts[1]);
                var rawLength = raw.length;

                var uInt8Array = new Uint8Array(rawLength);

                for (var i = 0; i < rawLength; ++i) {
                    uInt8Array[i] = raw.charCodeAt(i);
                }

                dataBLOB = new Blob([uInt8Array], {type: contentType});
            }
            var objUrl = window.URL || window.webkitURL;
            return objUrl.createObjectURL(dataBLOB);
		},

		/**
		* Unload file data from memory.
		* @public       
		* @method unloadFileFromMemory
		* @param {string} objectUrl Valid object url pointing to BLOB data.
		*/
		unloadFileFromMemory: function(objectUrl) {
			var objUrl = window.URL || window.webkitURL;
            objUrl.revokeObjectURL(objectUrl);
		},

		/**
		* Set a cookie 
		* @public
		* @method setCookie
		* @param {string} key The unique identifier for the key value pair to be stored in the cookie
		* @param {string} value The corresponding value of the key value pair
		* @param {Number} expiration Cookie expiration in days
		* @param {string} domain Set domain specific cookie. Example, somedomain.com
		*/
		setCookie: function (key, value, expiration, domain) {

			var expires = '';
			if (expiration) //null or 0 - Session cookie
			{
			    if (expiration == -1) //Infinite = Set 1 Year
			    {
			        expiration = 365;
			    }
			    var date = new Date();
			    date.setTime(date.getTime() + (expiration * 24 * 60 * 60 * 1000));
			    expires = "; expires=" + date.toGMTString();
			}

			if (domain) {
			    domain = '; domain=' + domain;
			}

			document.cookie = key + "=" + escape(value) + expires + '; path=/ ' + (domain||'');
		},

		/**
		* Retrieve a previously set cookie if it exists
		* @public
		* @method getCookie
		* @param {string} key The unique identifier for the key value pair which is used to fetch the cookie
		* @return {string} the value that is stored for this key or null if the key does not exist
		*/
		getCookie: function (key) {
		    var cookies = document.cookie.split(';');
		    var l = cookies.length;
		    for (var i = 0; i < l; i++) {
		        var itemkey = cookies[i].trim();
		        if (itemkey.indexOf(key) < 0) {
		            continue;
		        }
		        var itemval = itemkey.substr(itemkey.indexOf('=') + 1);
		        itemkey = itemkey.substr(0, itemkey.indexOf('='));
		        if (key == itemkey) {
		            return unescape(itemval);
		        }
		    }
		},

		/**
		* Deletes a cookie 
		* @public
		* @method deleteCookie
		* @param {string} key the unique identifier for the cookie to be deleted
		* @param {string} domain Domain on which cookie is set
		*/
		deleteCookie: function (key,domain) {
		    Autodesk.CookieManager.setCookie(key, '', -1,domain);
		}


	};
	
})();


/**   
This enum lists all the supported themes. Use this enum to load specific theme.
@enum Themes
@since 1.1.0
@see Controls.Utility#loadTheme
@static
@unlisted
@example
function loadTheme() {

    //Load theme css based on theme id.
    Utility.loadTheme(Themes.Tinkercad); 

}
**/
Library.exports.Themes = {
	/**
    @property Tinkercad
    @readonly
    **/
	'Tinkercad': 'core',
	/**
    @property Andes
    @readonly
    **/
	'Andes': 'andes',
	'AndesVanilla': 'andes-vanilla',
	'DivineHammer': 'divine-hammer',
	'ContentBuilder': 'content-builder'
};

Handlebars.registerHelper('times', function (n,block) {
	var accum = '';
	for(var i=0;i<n;++i) {
		accum += block.fn(i);
	}
	return accum;
});

Handlebars.registerHelper('for', function(from, to, incr, block) {
    var accum = '';
    for(var i = from; i < to; i += incr)
        accum += block.fn(i);
    return accum;
});

Handlebars.registerHelper('reversefor', function(from, to, decr, block) {
    var accum = '';
    for(var i = from; i > to; i -= decr)
        accum += block.fn(i);
    return accum;
});

Handlebars.registerHelper( "compare", function( v1, op, v2, options ) {
	var c = {
		'eq': function( v1, v2 ) {
			return v1 == v2;
		},
		'neq': function( v1, v2 ) {
			return v1 != v2;
		}
	};

	if( Object.prototype.hasOwnProperty.call( c, op ) ) {
		return c[op].call(this, v1, v2) ? options.fn(this) : options.inverse(this);
	}
	return options.inverse(this);
});

Handlebars.registerHelper("math", function(lvalue, operator, rvalue, options) {
    lvalue = parseFloat(lvalue);
    rvalue = parseFloat(rvalue);
        
    return {
        "+": lvalue + rvalue,
        "-": lvalue - rvalue,
        "*": lvalue * rvalue,
        "/": lvalue / rvalue,
        "%": lvalue % rvalue
    }[operator];
});
/**
Abstract class for all controls.
All controls must derive from the BaseControl at the root.

@class BaseControl
@namespace Controls
@constructor
*/
var BaseControl = function () { };

BaseControl.prototype = {
    /** 
    Extend control and add base class methods
    @private
    @method _extend
    @param {Object} target An instance of control class which you want to extend with BaseControl.
    **/
    _extend: function (target) {
        var me = this;
        var props = Object.getOwnPropertyNames(this.prototype);
        props.forEach(function(propName) {
            if(target.__proto__){
                if(!target.__proto__.hasOwnProperty(propName))
                    Object.defineProperty(target.__proto__, propName, Object.getOwnPropertyDescriptor(me.prototype, propName));
            }else{ // For IE 9/10, there's no __proto__ property, we should use getPrototypeOf() instead
                var __proto__ = Object.getPrototypeOf(target);
                if(!__proto__.hasOwnProperty(propName))
                    Object.defineProperty(__proto__, propName, Object.getOwnPropertyDescriptor(me.prototype, propName));
            }
        });
        return target;
    },

    /** 
    Initialize control and add default keyboard and mouse events into it.
    @private
    @method initialize
    **/
    initialize: function () {
        
        /**
        Fires when a user is pressing a key
        @event keydown
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.keydown = new CoreLibrary.EventSource('keydown');
        this._bindEvent('keydown');

        /**
        Fires when a user presses a key
        @event keypress
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.keypress = new CoreLibrary.EventSource('keypress');
        this._bindEvent('keypress');

        /**
        Fires when a user releases a key
        @event keyup
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.keyup = new CoreLibrary.EventSource('keyup');
        this._bindEvent('keyup');

        /**
        Fires on a mouse click on the element 
        @event click
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.click = new CoreLibrary.EventSource('onclick');
        this._bindEvent('click');

        /**
        Fires on a mouse double-click on the element
        @event dblclick
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.dblclick = new CoreLibrary.EventSource('dblclick');
        this._bindEvent('dblclick');

        /**
        Fires when the mouse pointer moves out of an element 
        @event focusout
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.focusout = new CoreLibrary.EventSource('focusout');
        this._bindEvent('focusout');

        /**
        Fires when the mouse pointer enters and leaves an element
        @event hover
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.hover = new CoreLibrary.EventSource('hover');
        this._bindEvent('hover');

        /**
        Fires when the mouse enters an element
        @event mouseenter
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.mouseenter = new CoreLibrary.EventSource('mouseenter');
        this._bindEvent('mouseenter');

        /**
        Fires when the mouse leaves an element
        @event mouseout
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.mouseout = new CoreLibrary.EventSource('mouseout');
        this._bindEvent('mouseout');

        /**
        Fires when mouse movement happenes on an element
        @event mousemove
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.mousemove = new CoreLibrary.EventSource('mousemove');
        this._bindEvent('mousemove');

        /**
        Fires when a mouse button is pressed down on an element
        @event mousedown
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.mousedown = new CoreLibrary.EventSource('mousedown');
        this._bindEvent('mousedown');

        /**
        Fires when a mouse button is released over an element
        @event mouseup
        @public
        @type {CoreLibrary.EventSource}
        **/
        this.mouseup = new CoreLibrary.EventSource('mouseup');
        this._bindEvent('mouseup');

        /**
        Get control's id
        @property {String} id
        @readonly
        **/
        Object.defineProperty(this, "id",{
            get : function () {
                return $(this._element).attr('id');
            },
            enumerable : true
        });

        /**
        Get control's parent element
        @property {Object} parentElement
        @readonly
        **/
        Object.defineProperty(this, "parentElement",{
            get : function () {
                return $(this._element).parent();
            },
            enumerable : true
        });

        /**
        Get control's parent element
        @property {Boolean} isDisabled
        @readonly
        **/
        Object.defineProperty(this, "isDisabled",{
            get : function () {
                if (!$(this._element).attr('disabled')) {
                    return false;
                }
                return true;
            },
            enumerable : true
        });

        /**
        Get or set control's inner html
        @property {String} innerHTML
        **/
        Object.defineProperty(this, "innerHTML",{
            get : function () {
                return $(this._element).html();
            },
            set : function (html) {
                $(this._element).html(html);
            },
            enumerable : true
        });

        //add css namespace -for toolkit hardcode version as we don't have version specific css yet
        $(this._element).parent().addClass('l' + Library.id + Library.version);

        this.onInitialize.call(this);
    },
    /** 
    Bind an event to underlying dom element
    @private
    @method _bindEvent
    **/
    _bindEvent: function (event) {
        var me = this;
        $(this._element).bind(event, function (e) {
            if(me[event] && me[event].fire) {
                me[event].fire(null, e);
            }
        });
    },
    
    /** 
    Get control's attribute value.
    @public
    @method getAttribute
    @param {String} attribute Pass attribute name to get value of it.
    @return {String} Attribute value.
    **/
    getAttribute: function (attribute) {
        if(!attribute) return;
        return $(this._element).attr(attribute);
    },

    /** 
    Set control's attribute value.
    @public
    @method setAttribute
    @param {String} attribute An attribute to set.
    @param {String} value Value of an attribute.
    @chainable
    **/
    setAttribute: function (attribute, value) {
        if(!attribute) return;
        $(this._element).attr(attribute, value);
        return this;
    },

     /** 
    Adds a CSS class to the control's underlying HTML Element
    @public
    @method addClass
    @param {String} classname Valid css class name.
    @chainable
    **/
    addClass: function (classname) {
        $(this._element).addClass(classname);
        return this;
    },

    /** 
    Removes a CSS class from the control's underlying HTML Element
    @public
    @method removeClass
    @param {String} classname Valid css class name.
    @chainable
    **/
    removeClass: function (classname) {
        $(this._element).removeClass(classname);
        return this;
    },

    /** 
    Hide control.
    Control's onHide callback will be called after hide 
    @public
    @method hide
    @chainable
    **/
    hide: function () {
        $(this._element).hide();
        this.onHide();
        return this;
    },

    /** 
    Show control.
    Control's onShow callback will be called after show
    @public
    @method show
    @chainable
    **/
    show: function () {
        $(this._element).show();
        this.onShow();
        return this;
    },

    /** 
    Remove control.
    Control's onRemove callback will be called before remove
    @public
    @method remove
    @chainable
    **/
    remove: function () {
        this.onRemove();
        $(this._element).remove();
        return this;
    },

    /** 
    Enable control.
    Control's onEnable callback will be called after enabling control
    @public
    @method enable
    @chainable
    **/
    enable: function () {
        $(this._element).removeAttr('disabled');
        this.onEnable();
        return this;
    },

    /** 
    Disable control.
    Control's onDisable callback will be called after disabling control
    @public
    @method disable
    @chainable
    **/
    disable: function () {
        $(this._element).attr('disabled', 'disabled');
        this.onDisable();
        return this;
    },

    /** 
    Set control's focus.
    Control's onFocusIn callback will be called when focus get in control
    @public
    @method focus
    @chainable
    **/
    focus: function () {
        $(this._element).focus();
        this.onFocusIn();
        return this;
    },

    /** 
    Focus out from control.
    Control's onFocusOut callback will be called when focus get out of control
    @public
    @method blur
    @chainable
    **/
    blur: function () {
        $(this._element).blur();
        this.onFocusOut();
        return this;
    },

    /** 
    Control's onInitialize callback will be called when initialization process completes.
    Child class can override this method to run code after initialization process.
    @protected
    @method onInitialize
    **/
    onInitialize : function () { },
    
    /** 
    This callback will be called when this control get enabled.
    Child class can override this method to run code when control get enabled.
    @protected
    @method onEnable
    **/
    onEnable: function () { },
    /** 
    This callback will be called when this control get disabled.
    Child class can override this method to run code when control get disabled.
    @protected
    @method onDisable
    **/
    onDisable: function () { },

    /** 
    This callback will be called when this control show up in page.
    Child class can override this method to run code when control showed up.
    @protected
    @method onShow
    **/
    onShow: function () { },
    /** 
    This callback will be called when this control hides from page.
    Child class can override this method to run code when control hides.
    @protected
    @method onHide
    **/
    onHide: function () { },
    /** 
    This callback will be called when this control removed from page.
    Child class can override this method to run code when control get removed.
    @protected
    @method onRemove
    **/
    onRemove: function () { },

    /** 
    This callback will be called when focus comes in control.
    Child class can override this method to run code when focus comes in control.
    @protected
    @method onFocusIn
    **/
    onFocusIn: function () { },
    /** 
    This callback will be called when focus goes out from control.
    Child class can override this method to run code when focus goes out from control.
    @protected
    @method onFocusOut
    **/
    onFocusOut: function () { }
    
};

/** 
Extend custom control.
@public
@static
@method extend
@param {Object} control An instance of control class which you want to extend with BaseControl.

@example
//Constructor of CustomControl
var CustomControl = function (control) {
    this._element = control; //dom element, set _element before calling base control's extend
    BaseControl.extend(this); //will add base control's default events, methods & properties to CustomControl
};
*/
BaseControl.extend = function (control) {
    if(!control) return;
    //copy all methods
    this.prototype._extend.call(this, control);
   
    //initialize base first
    //add default keyboard and mouse events to control
    this.prototype.initialize.call(control);

    return control;
};

Controls.BaseControl = BaseControl;

/**   
Sketch2D control parameters.
@class SketchParams
@since 1.0.0
@see Controls.Sketch2D
@unlisted
**/
var SketchParams = function(){

    /**
    An id of sketch control.
    @property {String} id
    @default 'sketch'
    **/
    this.id = undefined;

    /**
    Parent of sketch control. Pass valid id or jQuery object of parent.
    If parent is not set then Sketch2D control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

	/**
    Width of Sketch2D control.
    @property {Number} width
    @default 200
    **/
    this.width = undefined;

    /**
    Height of Sketch2D control.
    @property {Number} height
    @default 200
    **/
    this.height = undefined;

};

/**   
Sketch2D control's theme.
@class SketchTheme
@since 1.1.0
@see Controls.Sketch2D
@unlisted
**/
var SketchTheme = {
	/**
    @property Tinkercad
    @readonly
    **/
	'Tinkercad': {
		background: '#F9F9F9',
		backgroundLine: '#a5ddef',
		pathLine: 'rgba(0,192,255,0.9)',
		controlPoint: 'rgba(0,0,0,0.7)',
		controlPointBG: 'rgba(255,255,255,1.0)',
		controlPointHitBG: 'rgba(255,0,0,1.0)'
	},
	/**
    @property Andes
    @readonly
    **/
	'Andes': {
		background: 'rgba(0,0,0,0.5)',
		backgroundLine: 'rgba(255,255,255,0.5)',
		pathLine: 'rgba(255,255,255,0.9)',
		controlPoint: 'rgba(255,255,255,0.9)',
		controlPointBG: 'rgba(0,0,0,1)',
		controlPointHitBG: 'rgba(255,255,255,1)'
	},
	/**
    @property AndesVanilla
    @readonly
    **/
	'AndesVanilla': {
		background: '#F9F9F9',
		backgroundLine: '#E99C51',
		pathLine: '#e47911',
		controlPoint: '#e47911',
		controlPointBG: '#F9F9F9',
		controlPointHitBG: '#E75116'
	},
	/**
    @property DivineHammer
    @readonly
    **/
	'DivineHammer': {
		background: 'rgba(127,127,127,1)',
		backgroundLine: 'rgba(255,255,255,0.5)',
		pathLine: 'rgba(255,255,255,0.9)',
		controlPoint: 'rgba(255,255,255,0.9)',
		controlPointBG: 'rgba(255,255,255,1)',
		controlPointHitBG: 'rgba(248,151,40,1)'
	},
	/**
    @property ContentBuilder
    @readonly
    **/
	'ContentBuilder': {
		background: '#F9F9F9',
		backgroundLine: '#88B3BE',
		pathLine: '#2e6270',
		controlPoint: '#2e6270',
		controlPointBG: '#ffffff',
		controlPointHitBG: '#ffffff'
	}
};

/**
An HTML5 control that allows an user to modify a {CoreLibrary.Sketch2D}.   For an interactive demonstration please see: {Interactive Control Demos}.

@class Sketch2D
@param {Controls.SketchParams} params Sketch2D control parameters.
@namespace Controls
@since 1.0.0
@constructor
@example
function CreateSketcher() {
	//Downloads the Creative Platform UI Toolkit using the runtime
	creativePlatformRuntime.require(
		//List of libraries that we're interested in
		[{id: "aZS9YbvfqUX", version: 0}],

		//Callback when successful
		function(library) {
			var controls = library.Controls;
			var params = {
					'id':'sketchControl',
					'parent': '2dsketch', // or $('#2dsketch'),
					'width': 250, 
					'height': 250, 
					'css': 'sketchControl'
				};
			var sketch2d = new controls.Sketch2D(params);
		},

		//Callback when failed
		function() {
			alert('Failed to load uitoolkit');
		}
	);
}
**/
var Sketch2D = function (params) {
	if(params instanceof HTMLElement || params.jquery) { //bind control
		this._element = $(params);
	} else { //create control
		this._element = this._createControl(params);
	}
	var parentId = '#' + $(this._element).attr('id');

    this._chkSnap = Checkbox.bind($(this._element).find('input:checkbox'));
    this._canvas = $(this._element).find(parentId + 'Canvas')[0];
    this._canvasWidth = $(this._canvas).width() || parseInt($(this._canvas).attr('width'));
	this._canvasHeight = $(this._canvas).height() || parseInt($(this._canvas).attr('height'));
	this._ctx = this._canvas.getContext("2d");
    this._sketch2D;

    /**
    Get/Set an underlying Sketch2D object from which control is drawn.
    @property {CoreLibrary.Sketch2D} value
    **/
    Object.defineProperty(this, 'value', {
        get : function() {
        	//TODO: need to return deep copy of an object with prototype inheritance
        	return this._sketch2D;
        },
        set : function (sketch2d) {
			this._sketch2D = sketch2d;
			this._reset();
			this.change.fire();
		},
        enumerable : true
    });

    this._tol = 0.5;
    this._snapValue;
	this._snapping = false;
	this.refreshTheme();
	/**
	Enable/Disable snapping
	@property {boolean} snap
	@default false
	**/
	Object.defineProperty(this, "snap",{
		get : function () {
			return this._snapping; 
		},
		set : function (snap) {
			this._snapping = snap;
			this._chkSnap.checked = snap;
		},
		enumerable : true
	});

    this._dragging = false;
	
	//center of user control
	this._cX = this._canvasWidth/2;
	this._cY = this._canvasHeight/2;

	/**
	Event will be fired when user start modifying sketch.
	@event beginchange
	@public
	@type {CoreLibrary.EventSource}
	**/
	this.beginchange = new CoreLibrary.EventSource('beginchange');

	/**
	Event will be fired when sketch changes.
	@event change
	@public
	@type {CoreLibrary.EventSource}
	**/
	this.change = new CoreLibrary.EventSource('change');

	/**
	Event will be fired after sketch change.
	@event endchange
	@public
	@type {CoreLibrary.EventSource}
	**/
	this.endchange = new CoreLibrary.EventSource('endchange');

	this._initialize();

};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.SketchParams} params Sketch control parameters 
@return {Object} jQuery object of Sketch2D control.
**/
Sketch2D.prototype._createControl = function (params) {
	var id = params.id || 'sketch';
	var width = params.width || 200;
	var height = params.height || 200;
	var css = params.css || '';

	var options = {
		'id': id,
		'width': width + 'px',
		'height': height + 'px',
		'css': css,
		'checkbox': {
			'id': id + 'Checkbox',
			'text': 'Snap'
		}
	};
	var parent = $('body');
	if(typeof params.parent === 'string')
		parent = $('#' + params.parent);
	else 
		parent = $(params.parent);
	parent.append(Handlebars.templates['2dsketch'](options));
	return parent.find('#' + id);
};

/** 
Initialize control
@private
@method _initialize
**/
Sketch2D.prototype._initialize = function () {
	this._snapping = this._chkSnap.checked;
	this._bindEvents();
};

/** 
Initialize control
@private
@method _initialize
**/
Sketch2D.prototype.refreshTheme = function () {
	var sketchTheme = SketchTheme[Utility.currentTheme()];
	if(!sketchTheme)
		this._theme = SketchTheme.Tinkercad;
	else 
		this._theme = sketchTheme;
	if(this._sketch2D) this._draw();
};

/** 
Resize sketch control. Client can call this method to dynamically resize sketch control based on parent sizing.
@public
@method resize
@param {Number} size Width & height will be set to size.
**/
Sketch2D.prototype.resize = function (size) {
	if(!size) return;

	this._canvasWidth = parseInt(size);
	this._canvasHeight = this._canvasWidth;

	//find new center
	this._cX = this._canvasWidth/2;
	this._cY = this._canvasHeight/2;

	//update size
	$(this._canvas).attr('width', this._canvasWidth);
	$(this._canvas).attr('height', this._canvasHeight);
	$(this._element).width(this._canvasWidth);
	$(this._element).height(this._canvasHeight);

	this._reset();
};

/** 
Removes the control's underlying DOM and marks it for removal
@public
@method remove
**/
Sketch2D.prototype.remove = function () {
	this._element.remove();
};

/** 
Reset underlying calculations when control is loaded with new value
@private
@method _reset
**/
Sketch2D.prototype._reset = function () {
	if(this._sketch2D) {
		//center of bounding box
		var bounds = this._sketch2D.bounds();
		if(bounds) {
			var min = bounds.min;
			var max = bounds.max;

		    this._sX = min.x + (max.x - min.x) / 2;	// Example position on Sketch (X)
			this._sY = min.y + (max.y - min.y) / 2;	// Example position on Sketch (Y)

			this._s2cScaleX = (this._canvasWidth / (bounds.length() + 20)); //Define the X scale from Sketch --> User Control + some value
			this._s2cScaleY = (-this._canvasHeight / (bounds.width() + 20)); //Define the Y scale from Sketch --> User Control + some value
			
			var zero = this._viewToSketch2D(0,0);
			var dragPoint = this._viewToSketch2D(5,5); //Drag handle width-height
			this._tol = zero.distanceTo(dragPoint);
			
			zero = this._sketch2DToView(0,0);
			var snapPoint = this._sketch2DToView(1,1); //Draw 1mm snap grid
			this._snapValue = zero.distanceTo(snapPoint);
			this._draw();
		}
	}
};

/** 
Bind control's mouse and sub control events
@private
@method _bindEvents
**/
Sketch2D.prototype._bindEvents = function () {
	var me = this;
	this._chkSnap.change.bind(function() {
		me._snapping = me._chkSnap.checked;
	});
	
	var mouseCoords = function (ev) {
		if (ev.pageX || ev.pageY) {
			return {
				x:ev.pageX,
				y:ev.pageY
			};
		}
		return {
			x: ev.clientX + document.body.scrollLeft - document.body.clientLeft,
			y: ev.clientY + document.body.scrollTop  - document.body.clientTop
		};
	};

	var getMouseOffset = function (ev) {
		ev = ev || window.event;
		var targetOrig = getElementOrigin();
		var mousePos  = mouseCoords(ev);
		return {
			x: mousePos.x - targetOrig.x,
			y: mousePos.y - targetOrig.y
		};
	};

	var getElementOrigin = function () {
		var offset = $(me._canvas).offset();
		return {
			x: offset.left,
			y: offset.top
		};
	};

	this._canvas.addEventListener("mousemove", function(ev) {
		if (me._dragging)
			return;

		ev = ev || window.event;
		
		var mousePos = getMouseOffset(ev);

		me._hit = me._hitTest(mousePos.x, mousePos.y);
		me._draw();

	}, false);

	this._canvas.addEventListener("contextmenu", function(ev) {
		if (ev.preventDefault)
			ev.preventDefault();
	}, false);

	this._canvas.addEventListener("mousedown", function(ev) {
		ev = ev || window.event;
		if (ev.preventDefault)
			ev.preventDefault();

		//focus out other element
		document.activeElement.blur();
		
		var mousePos = getMouseOffset(ev);

		if (ev.which === 1 && me._hit !== null) {
			me._dragStartX = mousePos.x;
			me._dragStartY = mousePos.y;

			var point = me._sketch2DToView(me._hit.position.x, me._hit.position.y);
			me._dragOrigX = point.x;
			me._dragOrigY = point.y;

			me._dragging = true;
			me.beginchange.fire();
		}

		me._draw();
		
	}, false);

	this._element[0].addEventListener("mouseup", function(ev) {
		ev = ev || window.event;
		if (ev.preventDefault)
			ev.preventDefault();
		
		if(me._dragging)
			me.endchange.fire();

		me._dragging = false;
		me._draw();

	}, false);

	this._element[0].addEventListener("mousemove", function(ev) {
		// Handle view dragging
		if (!me._dragging)
			return;
		ev = ev || window.event;
		var mousePos = getMouseOffset(ev);
		
		if (me._hit !== null) {
			var dx = mousePos.x - me._dragStartX;
			var dy = mousePos.y - me._dragStartY;
			var newPoint2D;
			if (me._snapping) {
				newPoint2D = me._viewToSketch2D(Math.round((me._dragOrigX + dx)/me._snapValue)*me._snapValue, Math.round((me._dragOrigY + dy)/me._snapValue)*me._snapValue);
			} else {
				newPoint2D = me._viewToSketch2D(me._dragOrigX + dx, me._dragOrigY + dy);
			}

			var movedToNewPoint = !me._hit.position.equals(newPoint2D);
			if(movedToNewPoint) { //if hit point is moved to new location, calculate (dx,dy) so can move cps by that distance
				var p1 = me._sketch2DToView(me._hit.position.x, me._hit.position.y);
				var p2 = me._sketch2DToView(newPoint2D.x, newPoint2D.y);
				dx = p2.x - p1.x;
				dy = p2.y - p1.y;
			}

			me._hit.position = newPoint2D;
			var pathLength = me._sketch2D.paths.length;
			for (var i = 0; i < pathLength; i++) {
				if(me._sketch2D.paths[i] === me._hit.curve.path) {
					var updateCPoint = function (curveIndex, cPointIndex, point) {
						var cPoints = me._sketch2D.paths[i].curveAt(curveIndex).controlPoints;
						cPoints[cPointIndex] = point;
						me._sketch2D.paths[i].curveAt(curveIndex).controlPoints = cPoints;								
					};

					if(me._hit.curveStart || me._hit.curveEnd) { //start or end point hit
						if(me._hit.curveStart) {
							me._sketch2D.paths[i].curveAt(me._hit.curve.index).start = newPoint2D;
						} else {
							me._sketch2D.paths[i].curveAt(me._hit.curve.index).end = newPoint2D;
						}
						if (me._hit.curve instanceof CoreLibrary.Bezier2D && me._hit.controlPoint && movedToNewPoint) { //move control points along with start/end point
							var movePoint = function (point) {
								var v1 = me._sketch2DToView(point.x, point.y).move(dx, dy);
								return me._viewToSketch2D(v1.x, v1.y);
							};
							if(me._hit.controlPoint.length === 2) {
								var cp1 = movePoint(me._hit.controlPoint[0]);
								var cp2 = movePoint(me._hit.controlPoint[1]);
								me._hit.controlPoint[0] = cp1;
								me._hit.controlPoint[1] = cp2;

								if(me._hit.curveStart) {
									updateCPoint(me._hit.curve.index, 0, cp1);
									var prevCurveIndex;
									me._hit.curve.prev() ? prevCurveIndex = me._hit.curve.prev().index : prevCurveIndex = me._sketch2D.paths[i].lastCurve().index;
									updateCPoint(prevCurveIndex, 1, cp2);
								} else {
									updateCPoint(me._hit.curve.index, 1, cp1);
									var nextCurveIndex;
									me._hit.curve.next() ? nextCurveIndex = me._hit.curve.next().index : nextCurveIndex = me._sketch2D.paths[i].firstCurve().index;
									updateCPoint(nextCurveIndex, 0, cp2);
								}
							} else if (me._hit.controlPoint.length === 1) {
								var cp1 = movePoint(me._hit.controlPoint[0]);
								me._hit.controlPoint[0] = cp1;
								updateCPoint(me._hit.curve.index, 0, cp1);
							}
						}
					} else if(me._hit.controlPoint) { //control point hit
						updateCPoint(me._hit.curve.index, me._hit.controlPoint[0], newPoint2D);
						if(!ev.altKey && me._hit.controlPoint.length === 2) {
							var rPoint, curv;
							if(0 === me._hit.controlPoint[0]) { //fist control point hit
								curv = me._hit.curve.prev() ? me._hit.curve.prev() : me._sketch2D.paths[i].lastCurve();
								rPoint = newPoint2D.clone();
								rPoint.rotate(Math.PI, curv.end.x, curv.end.y);
							} else { //last control point
								curv = me._hit.curve.next() ? me._hit.curve.next() : me._sketch2D.paths[i].firstCurve();
								rPoint = newPoint2D.clone();
								rPoint.rotate(Math.PI, curv.start.x, curv.start.y);
							}
							
							updateCPoint(curv.index, me._hit.controlPoint[1], rPoint);
						}

					} else { //path hit
						
					}
				}
			}

		}

		me._draw();
		if(me._hit !== null)
			me.change.fire();
		
	}, false);

};

/** 
Draw control's background and snap grid
@private
@method _drawBG
**/
Sketch2D.prototype._drawBG = function() {
	// Clear bg.
	this._ctx.fillStyle = this._theme.background;
	this._ctx.fillRect(0,0,this._canvasWidth,this._canvasHeight);

	this._ctx.beginPath();
	for (var i = 0; i < this._canvasWidth; i += this._snapValue) {
		this._ctx.moveTo(i+0.5,0);
		this._ctx.lineTo(i+0.5,this._canvasHeight);
	}
	for (var i = 0; i < this._canvasHeight; i += this._snapValue) {
		this._ctx.moveTo(0,i+0.5);
		this._ctx.lineTo(this._canvasWidth,i+0.5);
	}
	this._ctx.lineWidth = 0.5;
	this._ctx.strokeStyle = this._theme.backgroundLine;
	this._ctx.closePath();
	this._ctx.stroke();

	this._ctx.beginPath();
	this._ctx.moveTo(0,0);
	this._ctx.lineTo(this._canvasWidth, 0);

	this._ctx.moveTo(this._canvasWidth, 0);
	this._ctx.lineTo(this._canvasWidth,this._canvasHeight);

	this._ctx.moveTo(this._canvasWidth,this._canvasHeight);
	this._ctx.lineTo(0,this._canvasHeight);

	this._ctx.moveTo(0,this._canvasHeight);
	this._ctx.lineTo(0,0);

	this._ctx.lineWidth = 2.0;
	this._ctx.closePath();
	this._ctx.strokeStyle = this._theme.pathLine;
	this._ctx.stroke();
};

/** 
Draw control's paths, drag handle & hit point
@private
@method _draw
**/
Sketch2D.prototype._draw = function () {
	//Draw bg
	this._drawBG();

	var pathLength = this._sketch2D.paths.length, me = this;
	var drawDragPoint = function (x, y, hit) {
		me._ctx.fillStyle = me._theme.controlPoint;
		me._ctx.beginPath();
		me._ctx.rect(x-4,y-4,8,8);
  		me._ctx.closePath();
		me._ctx.fill();

		// centers
		if(hit) {
			me._ctx.fillStyle = me._theme.controlPointHitBG;
		} else {
			me._ctx.fillStyle = me._theme.controlPointBG;
		}
		me._ctx.beginPath();
		me._ctx.rect(x-2,y-2,4,4);
		me._ctx.closePath();
		me._ctx.fill();
	};

	var drawControlPoint = function (x, y, hit) {
		me._ctx.fillStyle = me._theme.controlPoint;
		me._ctx.beginPath();
		me._ctx.arc(x,y,4,0,Math.PI*2,true); 
  		me._ctx.closePath();
		me._ctx.fill();

		// centers
		if(hit) {
			me._ctx.fillStyle = me._theme.controlPointHitBG;
		} else {
			me._ctx.fillStyle = me._theme.controlPointBG;
		}
		me._ctx.beginPath();
		me._ctx.arc(x,y,2,0,Math.PI*2,true);  
		me._ctx.closePath();
		me._ctx.fill();
	};

	var drawHitPoint = function() {
		if (me._hit) {
			var point = me._sketch2DToView(me._hit.position.x, me._hit.position.y);
			if(me._hit.curveStart || me._hit.curveEnd) { //End point hit
				drawDragPoint(point.x, point.y, true);
			} else if(undefined !== me._hit.controlPoint) { //control point hit
				drawControlPoint(point.x, point.y, true);
			}
		}
	};

	var setLineDash = function(isSet) {
		var dash = [];
		if(isSet) {
			dash = [3];
		}
		if (!me._ctx.setLineDash) { //Firefox
	    	me._ctx.mozDash = dash;
		} else { //Chrome
			me._ctx.setLineDash(dash);
		}
	};
	
	//Draw polygons
	for (var i = 0; i < pathLength; i++) {
		var polygons = this._sketch2D.paths[i].toPolygons();
		var polygonLength = polygons.length;
		
		for (var j = 0; j < polygonLength; j++) {
			var points = polygons[j];
			var npts = points.length/2;
			
			this._ctx.beginPath();
			for (var k = 0; k < npts; k++) {
				var point = this._sketch2DToView(points[k*2+0], points[k*2+1]);
				if (k === 0) {
					this._ctx.moveTo(point.x, point.y);
				} else {
					this._ctx.lineTo(point.x, point.y);
				}
			}

			this._ctx.closePath();
			this._ctx.lineWidth = 2.0;
			this._ctx.strokeStyle = this._theme.pathLine;
			this._ctx.stroke();
			
		}

		//Draw drag handles for each curve,
		var curve = this._sketch2D.paths[i].firstCurve();
		while(curve) {
			var startPoint = this._sketch2DToView(curve.start.x, curve.start.y);
			var endPoint = this._sketch2DToView(curve.end.x, curve.end.y);
			
			if(curve instanceof CoreLibrary.Bezier2D) {
				var controlPoints = curve.controlPoints;
				if(controlPoints.length === 2) { //Cubic Bezier
					var len = controlPoints.length/2;
					for (var c = 0; c < len; c++) {
						var controlPoint1 = this._sketch2DToView(controlPoints[c].x, controlPoints[c].y);
						var controlPoint2 = this._sketch2DToView(controlPoints[c+1].x, controlPoints[c+1].y);
						
						setLineDash(true);
						this._ctx.beginPath();
						this._ctx.moveTo(controlPoint1.x, controlPoint1.y);
						this._ctx.lineTo(startPoint.x, startPoint.y);
						
						this._ctx.moveTo(controlPoint2.x, controlPoint2.y);
						this._ctx.lineTo(endPoint.x, endPoint.y);
						
						this._ctx.lineWidth = 1.0;
						this._ctx.strokeStyle = this._theme.controlPoint;
						this._ctx.closePath();
						this._ctx.stroke();
						setLineDash(false);

						drawControlPoint(controlPoint1.x, controlPoint1.y);
						drawControlPoint(controlPoint2.x, controlPoint2.y);
					}
				} else if (controlPoints.length === 1) { //Quadratic Bezier
					var controlPoint = this._sketch2DToView(controlPoints[0].x, controlPoints[0].y);
					
					setLineDash(true);
					this._ctx.beginPath();
					this._ctx.moveTo(controlPoint.x, controlPoint.y);
					this._ctx.lineTo(startPoint.x, startPoint.y);

					this._ctx.moveTo(controlPoint.x, controlPoint.y);
					this._ctx.lineTo(endPoint.x, endPoint.y);

					this._ctx.lineWidth = 1.0;
					this._ctx.strokeStyle = this._theme.controlPoint;
					this._ctx.closePath();
					this._ctx.stroke();
					setLineDash(false);

					drawControlPoint(controlPoint.x, controlPoint.y);
				}

			}
			drawDragPoint(startPoint.x, startPoint.y);
			drawDragPoint(endPoint.x, endPoint.y);

			curve = curve.next();
		}

    }

    //Draw hit
    drawHitPoint();

};

/** 
Convert sketch2d coordinates to view coordinates
@private
@method _sketch2DToView
@return {CoreLibrary.Point2D} view point is returned.
**/
Sketch2D.prototype._sketch2DToView = function(sketch2DX, sketch2DY) {
	var userControlX = this._cX + ((sketch2DX - this._sX) * this._s2cScaleX);
	var userControlY = this._cY + ((sketch2DY - this._sY) * this._s2cScaleY);
	return new CoreLibrary.Point2D(userControlX, userControlY);
};

/** 
Convert view coordinates to sketch2d coordinates
@private
@method _viewToSketch2D
@return {CoreLibrary.Point2D} sketch2d point is returned.
**/
Sketch2D.prototype._viewToSketch2D = function(canvas2DX, canvas2DY) {
	var sketch2DX = this._sX + ((canvas2DX - this._cX) / this._s2cScaleX);
	var sketch2DY = this._sY + ((canvas2DY - this._cY) / this._s2cScaleY);
	return new CoreLibrary.Point2D(sketch2DX, sketch2DY);
};


/** 
Hit test based on given mouse coordinates 
@method _hitTest
@private
@param {Number} x X Mouse coordinate 
@param {Number} y Y Mouse coordinate
@return {Object} result Hit test information is returned. The object with the following key / value pairs:
  @return {CoreLibrary.Point2D} result.position Matched index of path.
  @return {CoreLibrary.Path2D} result.curve Matched hit point.
  @return {Boolean} result.curveStart Update start point of returned curve.
  @return {Boolean} result.curveEnd Update end point of returned curve.
  @return {Array[Number]|Array[CoreLibrary.Point2D]} result.controlPoint Array containing selected control point indexes/Path2D objects.
**/
Sketch2D.prototype._hitTest = function(x, y) {
	var hit = { position: null, curve: null, curveStart: null, curveEnd: null, controlPoint: null };
	var sketchPoint = this._viewToSketch2D(x, y);
	var point = new CoreLibrary.Point2D(sketchPoint.x, sketchPoint.y);
	var pathLength = this._sketch2D.paths.length;
	for (var i = 0; i < pathLength; i++) {
		var curves = this._sketch2D.paths[i].curvesByPoint(point, this._tol); //curves nearby given mouse position
		// Priority 1: Check if the point hit start or end point
		for (var j = curves.length - 1; j > -1; j--) {
			var curve = curves[j];
			if(point.distanceTo(curve.start) < this._tol) {
				hit = {'position': curve.start, 'curve': curve, 'curveStart': true};
				if (curve instanceof CoreLibrary.Bezier2D) { // Only Bezier curves have control points
					if(!hit.controlPoint) hit.controlPoint = [];
					if(curve.controlPoints.length === 2) { //Cubic bezier
						hit.controlPoint.push(curve.controlPoints[0]);
						var prevCurve;
						curve.prev() ? prevCurve = curve.prev() : prevCurve = this._sketch2D.paths[i].lastCurve();
						if(prevCurve instanceof CoreLibrary.Bezier2D && prevCurve.controlPoints && prevCurve.controlPoints.length === 2) {
							hit.controlPoint.push(prevCurve.controlPoints[1]);
						}
					} else if (curve.controlPoints.length === 1) { //quadratic bezier
						hit.controlPoint.push(curve.controlPoints[0]);
					}
				}
				break;
			} else if (point.distanceTo(curve.end) < this._tol) {
				hit = {'position': curve.end, 'curve': curve, 'curveEnd': true};
				if (curve instanceof CoreLibrary.Bezier2D) { // Only Bezier curves have control points
					if(!hit.controlPoint) hit.controlPoint = [];
					if(curve.controlPoints.length === 2) { //Cubic bezier
						hit.controlPoint.push(curve.controlPoints[1]);
						var nextCurve;
						curve.next() ? nextCurve = curve.next() : nextCurve = this._sketch2D.paths[i].firstCurve();
						if(nextCurve instanceof CoreLibrary.Bezier2D && nextCurve.controlPoints && nextCurve.controlPoints.length === 2) {
							hit.controlPoint.push(nextCurve.controlPoints[0]);
						}
					} else if (curve.controlPoints.length === 1) { //qudratic bezier
						hit.controlPoint.push(curve.controlPoints[0]);
					}
				}
				break;
			}
    	}

		// Priority 2: Check if any control point is hit
		for (var j = curves.length - 1; j > -1; j--) {
			var curve = curves[j];
			if (curve instanceof CoreLibrary.Bezier2D) { // Only Bezier curves have control points
				var controlPoints = curve.controlPoints;
				for (var k = 0; k< controlPoints.length; k++) {
					if(point.distanceTo(controlPoints[k]) < this._tol) {
						hit = {'position': controlPoints[k], 'curve': curve};
						if(!hit.controlPoint) hit.controlPoint = [];
						if(controlPoints.length === 2) { //Cubic bezier
							if(k===0) { //first control point hit
								var prevCurve;
								curve.prev() ? prevCurve = curve.prev() : prevCurve = this._sketch2D.paths[i].lastCurve();
								if(prevCurve instanceof CoreLibrary.Bezier2D && prevCurve.controlPoints && prevCurve.controlPoints.length === 2) {
									hit.controlPoint = [k, k+1];
								} else {
									hit.controlPoint = [k];
								}
							} else { //second control point hit
								var nextCurve;
								curve.next() ? nextCurve = curve.next() : nextCurve = this._sketch2D.paths[i].firstCurve();
								if(nextCurve instanceof CoreLibrary.Bezier2D && nextCurve.controlPoints && nextCurve.controlPoints.length === 2) {
									hit.controlPoint = [k, k-1];
								} else {
									hit.controlPoint = [k];
								}
							}
						} else if (controlPoints.length === 1) { //Quadratic bezier
							hit.controlPoint = [k];
						}
						break;
					} 
				}
			}
		}
		
		// Priority 3: return the hit closest curve because no start|end point and control point is hit. 
		// if(!hit.position && curves.length > 0) {
		// 	hit = {'position': point, 'curve': curves[curves.length-1]};
		// 	//console.log('curve hit');
		// }
	}

	if (!hit.position)
		hit = null;

	return hit;

};

/** 
Bind a Sketch2D control to specific dom element.
@method bind
@public
@param {Object} sketch A DOM or jQuery object to which you want to bind this Sketch2D object. 
@return {Controls.Sketch2D}
**/
Sketch2D.bind = function (sketch) {
	return new Sketch2D(sketch);
};

Controls.Sketch2D = Sketch2D;


/**   
Accordion control parameters.
@class AccordionParams
@since 1.5.0
@see Controls.Accordion
@unlisted
**/
var AccordionParams = function(){

    /**
    An id of Accordion control.
    @property {String} id
    @default 'Accordion'
    **/
    this.id = undefined;

    /**
    Parent of Accordion control. Pass valid id or jQuery object of parent.
    If parent is not set then Accordion control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

};

/**
An HTML Accordion control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Accordion
@param {Controls.AccordionParams} params Accordion control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.5.0
@constructor
@example
function CreateAccordion() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    'id':'accordion',
                    'parent': 'AccordionParent', // or $('#AccordionParent')
                    'css': 'AccordionControlCss'
                };
            var Accordion = new controls.Accordion(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Accordion = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    this._items = [];
    
    /**
    Accordion items
    @property {Array[Controls.AccordionItem]} items
    @public
    **/
    Object.defineProperty(this, "items",{
        get : function () {
            return this._items;
        },
        enumerable : true
    });

    /**
    Selected item
    @property {Controls.AccordionItem} selectedItem
    @readonly
    @public
    **/
    Object.defineProperty(this, "selectedItem",{
        get : function () {
            var header = this._element.find('.ui-accordion-item-header[selected=selected]');
            if(header.size() === 1) {
                var itm = header.parent();
                var indexes = [itm.index()];
                if(!itm.parent().hasClass('ui-accordion')) {
                    var whileStart = new Date();
                    while (1 == 1) {
                        if((new Date() - whileStart)/1000 > 5) break; //end the infinite loop if nothing found in 5 sec
                        if(itm.parent().hasClass('ui-accordion')) {
                            break;
                        } else if (itm.parent().hasClass('ui-accordion-item-content')) {
                            indexes.push(itm.parent().parent().index());
                            itm = itm.parent().parent();
                        }
                    }
                }
                var items = this._items, item;
                for (var i = indexes.length - 1; i >= 0; i--) {
                    item = items[indexes[i]];
                    if(i !== 0) items = item.items;
                }
                return item;

            } else return;
        },
        enumerable : true,
        configurable: true
    });

    BaseControl.call(this);
    //initialize base first
    //add default keyboard and mouse events to control
    this.initialize();
    
    /**
    Fires when any item get selected.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

};

Accordion.prototype = Object.create(BaseControl.prototype, {
    constructor:{
        value:Accordion
    }
});

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.AccordionParams} params Accordion control parameters 
@return {Object} jQuery object of Accordion control.
**/
Accordion.prototype._createControl = function (params) {
    var id = params.id || 'accordion';
    var css = params.css || '';

    var options = {
        'id': id,
        'css': css
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else
        parent = $(params.parent);

    parent.append(Handlebars.templates['accordion'](options));
    return parent.find('#' + id);
};

/** 
Initialize Accordion
@private
@method onInitialize
**/
Accordion.prototype.onInitialize = function () {
    this._refresh();
};

/** 
Bind events and refresh ui
@private
@method _refresh
**/
Accordion.prototype._refresh = function () { 
    var me = this;
    this._element.on('click', '.ui-accordion-item-header', function() {
        me._element.find('.ui-accordion-item-header').removeAttr('selected');
        $(this).attr('selected', 'selected');
        me.change.fire();
    });
    this._element.on('click', '.ui-accordion-item-icon', function() {
        if($(this).hasClass('ui-accordion-item-icon-down')) $(this).removeClass('ui-accordion-item-icon-down');
        else $(this).addClass('ui-accordion-item-icon-down');
    });
};

/** 
Add accordion item(s)
@method add
@param {Array[Controls.AccordionItemParams]|Controls.AccordionItemParams|String} items Accordion items
@examples
accordion.add([
{
    'header': 'item1',
    'content': 'content text' //text as content
},
{
    'header': 'item2',
    'content': document.getElementById('itemcontent') //other dom element as content
},
'item3' //an empty item by passing header text
]);

//or

accordion.add({
    'header': 'item1',
    'content': 'content text' //text as content
});

//or

accordion.add('item1');

**/
Accordion.prototype.add = function (items) {
    if(items) {
        if(!(items instanceof Array)) items = [items];
        
        var length = items.length, item;
        for (var i = 0; i < length; i++) {
            if(items[i].header && items[i].content) {
                item = new AccordionItem({
                    'id': items[i].id ? $.trim(items[i].id) : undefined,
                    'header': items[i].header,
                    'content': items[i].content
                });
            } else {
                item = new AccordionItem({
                    'id': items[i].id ? $.trim(items[i].id) : undefined,
                    'header': items[i].header ? $.trim(items[i].header) : $.trim(items[i])
                });
            }
            this._element.append(item.element);
            this._items.push(item);
        }
    }
};

/** 
Clear accordion content or accordion item content.
@method clear
@param {Number} index Pass an index of item which need to be cleared.
**/
Accordion.prototype.clear = function (index) {
    if(undefined === index) {
        this._items = [];
        this._element.find('.ui-accordion-item').remove();
    } else if(this._items.length > index) {
        this._items[index].clear();
    }
};

/** 
Remove accordion or accordion item content.
@method remove
@param {Number} index Pass an index of item which need to be removed.
**/
Accordion.prototype.remove = function (index) {
    if(undefined === index) {
        this._element.remove();
    } else if(this._items.length > index) {
        this._items[index].element.remove();
        this._items.splice(index, 1);
    }
    this.onRemove();
};

Controls.Accordion = Accordion;

/**   
AccordionItem parameters.
@class AccordionItemParams
@since 1.5.0
@see Controls.Accordion
@unlisted
**/
var AccordionItemParams = function(){

    /**
    An id of accordion item control.
    @property {String} id
    @default undefined
    @optional
    **/
    this.id = undefined;

    /**
    Header of Accordion control.
    @property {String|Object} header Header string or DOM element or jQuery element
    **/
    this.header = undefined;

    /**
    Content of Accordion control.
    @property {String|Object} content Content as string or DOM element or jQuery element
    **/
    this.content = undefined;

};

/**   
AccordionItem class.
@class AccordionItem
@namespace Controls
@extends Controls.BaseControl
@since 1.5.0
@see Controls.Accordion
**/
var AccordionItem = function (params) {
    
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control

        var id = params.id || '';
    
        var options = {
            'id': id,
            'header': typeof params.header === 'string' ? params.header : '',
            'content': typeof params.content === 'string' ? params.content : ''
        };

        this._element = $(Handlebars.templates['accordionitem'](options));

        if(params.header && typeof params.header !== 'string') this._element.find('.ui-accordion-item-header').append($(params.header));
        if(params.content && typeof params.content !== 'string') this._element.find('.ui-accordion-item-content').append($(params.content));
    }
    this._items = [];

    /**
    Nested item collection.
    @property {Array[Controls.AccordionItem]} items
    @public
    **/
    Object.defineProperty(this, "items",{
        get : function () {
            return this._items;
        },
        enumerable : true
    });

    /**
    jQuery element holding accordion item div
    @property {Object} element
    @public
    **/
    Object.defineProperty(this, "element",{
        get : function () {
            return this._element;
        },
        enumerable : true
    });

    /**
    jQuery element holding header div.
    Passed DOM Element or jQuery element will be appended to header div when this property is set.
    @property {Object} header
    @public
    **/
    Object.defineProperty(this, "header",{
        get : function () {
            return this._header;
        },
        set : function (element) {
            $(this._header).html('');
            $(this._header).append(element);
        },
        enumerable : true
    });

    /**
    jQuery element holding content div.
    Passed DOM Element or jQuery element will be appended to content div when this property is set. Pass null to clear content.
    @property {Object} content
    @public
    **/
    Object.defineProperty(this, "content",{
        get : function () {
            return this._content;
        },
        set : function (element) {
            if(element === null) $(this._content).html('');
            else $(this._content).append(element);
            this._refresh();
        },
        enumerable : true
    });
    
    BaseControl.call(this);
    //initialize base first
    //add default keyboard and mouse events to control
    this.initialize();

    /**
    Fires when item get selected.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

};

AccordionItem.prototype = Object.create(BaseControl.prototype, {
    constructor:{
        value:AccordionItem
    }
});

/** 
Initialize AccordionItem
@private
@method onInitialize
**/
AccordionItem.prototype.onInitialize = function () {
    this._icon = this._element.find('.ui-accordion-item-icon');
    this._header = this._element.find('.ui-accordion-item-header');
    this._content = this._element.find('.ui-accordion-item-content');
    this._refresh();
};

/** 
Bind events and refresh ui
@private
@method _refresh
**/
AccordionItem.prototype._refresh = function () {
    if(this._content.html() === '') this._icon.addClass('ui-accordion-item-noicon');
    else this._icon.removeClass('ui-accordion-item-noicon');
};

/** 
Add nested item(s)
@method add
@param {Array[Controls.AccordionItemParams]|Controls.AccordionItemParams|String} items Nested items
@examples
accordionItem.add([
{
    'header': 'item1',
    'content': 'content text' //text as content
},
{
    'header': 'item2',
    'content': document.getElementById('itemcontent') //other dom element as content
},
'item3' //an empty item by passing header text
]);

//or

accordionItem.add({
    'header': 'item1',
    'content': 'content text' //text as content
});

//or

accordionItem.add('item1');

**/
AccordionItem.prototype.add = function (items) {
    if(items) {
        if(!(items instanceof Array)) items = [items];
        
        var length = items.length, item;
        for (var i = 0; i < length; i++) {
            if(items[i].header && items[i].content) {
                item = new AccordionItem({
                    'id': items[i].id ? $.trim(items[i].id) : undefined,
                    'header': items[i].header,
                    'content': items[i].content
                });
            } else {
                item = new AccordionItem({
                    'id': items[i].id ? $.trim(items[i].id) : undefined,
                    'header': items[i].header ? $.trim(items[i].header) : $.trim(items[i])
                });
            }
            this._content.append(item.element);
            this._items.push(item);
        }
        if(length > 0) this._refresh();
    }
};

/** 
Clear accordion content.
@method clear
**/
AccordionItem.prototype.clear = function () {
    if(undefined === index) {
        this._items = [];
        this._element.empty();
    } else if(this._items.length > index) {
        this._items[index].clear();
    }
};

/** 
Remove accordion item by index.
@method remove
@param {Number} index Pass an index of item which need to be removed.
**/
AccordionItem.prototype.remove = function (index) {
    if(undefined === index) {
        this._items = [];
        this._element.remove();
    } else if(this._items.length > index) {
        this._items[index].element.remove();
        this._items.splice(index, 1);
    }
};

/** 
Bind a AccordionItem control to specific dom element 
@method bind
@public
@param {Object} item A DOM or jQuery object to which you want to bind this Accordion item object. 
@return {Controls.Accordion}
**/
AccordionItem.bind = function (item) {
    return new AccordionItem(Accordion);
};

Controls.AccordionItem = AccordionItem;


var _BlockControl = function (blockcontrol) {

    /** @private The element this blockcontrol is bound to */
    this._element = blockcontrol;
    this._mode = null;
    this._defaultClass = null;

    BaseControl.call(this);
    
    this.initialize();
};

_BlockControl.prototype = Object.create(BaseControl.prototype, {
    constructor:{
        value:_BlockControl
    }
});


_BlockControl.create = function (parent, id, css) {
    var args = {};
    args.id = id;
    var str = '<div id="'+ id +'blockControl" class="blockUI '+ css + '" style="display: none;"></div>';
    var container = parent || $('body');
    return new _BlockControl($(str).prependTo(container));
};

_BlockControl.bind = function (blockcontrol) {
    return new _BlockControl(blockcontrol);
};


var BlockControl = function () {

    this._blockControl = null;

    this._activeControl = null;

    this._controlStack = [];
};


BlockControl.instance = function () {
    if (!BlockControl._instance) {

        BlockControl._instance = new BlockControl();
        BlockControl._instance._bind(_BlockControl.create(null, 'appBlockUI'));
    }
    return BlockControl._instance;
};

BlockControl.prototype = {

    
    _bind: function (blockControl) {
        this._blockControl = blockControl;
    }
};


BlockControl.prototype._sortControlStack = function (a, b) {
    return a.priority > b.priority;
};

BlockControl.prototype._pushToStack = function (blockuicontrol) {
    $(blockuicontrol._element).css('z-index', '');
    $(blockuicontrol._element).hide();
    this._controlStack.push(blockuicontrol);
    this._controlStack.sort(this._sortControlStack);
};


BlockControl.prototype.unblock = function (blockuicontrol, remove) {
    var control = blockuicontrol._element;
    this._hide(blockuicontrol, remove);
    if (this._controlStack.length == 0) {
        this._blockControl.hide();
        this._activeControl = null;
    }
    else {
        if (this._activeControl == blockuicontrol) {
            this._show(this._controlStack.pop());
        }
        else {
            var idx = this._controlStack.indexOf(blockuicontrol);
            if (idx >= 0) {
                this._controlStack.splice(idx, 1);
            }
        }
    }
    if (this.hideonclickfn) {
        $(this._blockControl._element).unbind('click', this.hideonclickfn);
    }
};


BlockControl.prototype.blockDialog = function (blockuicontrol, closebutton, externalclosebutton) {
    $(blockuicontrol._element).addClass('blockUIDialog');
    this.block(blockuicontrol, closebutton, externalclosebutton);
};


BlockControl.prototype.block = function (blockuicontrol, closebutton, externalclosebutton) {

    if (closebutton != null && closebutton == true) {
        this._addCloseButton(blockuicontrol, externalclosebutton);
    }
    if (this._activeControl != null) {
        if (this._activeControl.priority <= blockuicontrol.priority) {
            this._pushToStack(this._activeControl);
        }
        else {
            this._pushToStack(blockuicontrol);
            return;
        }
    }

    this._show(blockuicontrol);
};

BlockControl.prototype._show = function (blockuicontrol) {
    this._activeControl = blockuicontrol;
    $(blockuicontrol._element).css('z-index', blockuicontrol.priority);

    if (this._activeControl.hideonclick) {
        var me = this;
        $(this._blockControl._element).unbind('click');
        $(this._blockControl._element).bind('click', function () {
            me.unblock(blockuicontrol, false);
            blockuicontrol.close.fire();
        });
    }
    else {
        $(this._blockControl._element).unbind('click');
    }

    $(blockuicontrol._element).show();
    this._blockControl.show();

};

BlockControl.prototype._hide = function (blockuicontrol, remove) {

    $(blockuicontrol._element).css('z-index', '');
    if (remove === true) {
        $(blockuicontrol._element).remove();
    }
    else {
        $(blockuicontrol._element).hide();
    }

};


BlockControl.prototype._addCloseButton = function (blockuicontrol, externalclosebutton) {
    var control = blockuicontrol._element;

    var btnclass = 'closeuidialog';
    if (externalclosebutton != null && externalclosebutton == true) {
        btnclass += ' closeuidialogexternal';
    }
    if ($(control).find('#closeuidialogbutton').length == 0) {
        var closebuttonstr = '<div id="closeuidialogbutton"></div>';
        $(control).append(closebuttonstr);
    }
    var me = this;
    var button = $(control).find('#closeuidialogbutton');
    $(button).attr('class', btnclass);
    $(button).click(function () {
        blockuicontrol.unblock();
    });
};


var BlockUI = function (control, priority, hideonclick) {
    
    this._element = control;
    this.hideonclick = hideonclick;
    this.priority = 3000 + (((priority == null) || isNaN(priority)) ? 1 : priority);
    
    
    this.close = new CoreLibrary.EventSource('additem');
};


BlockUI.create = function (control, priority, hideonclick) {
    return new BlockUI(control, priority, hideonclick);
};

BlockUI.prototype.blockDialog = function (closebutton, externalclosebutton) {
    BlockControl.instance().blockDialog(this, closebutton, externalclosebutton);
};

BlockUI.prototype.block = function (closebutton, externalclosebutton) {
    BlockControl.instance().block(this, closebutton, externalclosebutton);
};

BlockUI.prototype.unblock = function (remove) {
    BlockControl.instance().unblock(this, remove);
};

Controls.BlockControl = BlockControl;
Controls.BlockUI = BlockUI;/**   
Button control parameters.
@class ButtonParams
@since 1.0.0
@see Controls.Button
@unlisted
**/
var ButtonParams = function(){

    /**
    An id of button control.
    @property {String} id
    @default 'button'
    **/
    this.id = undefined;

    /**
    Parent of button control. Pass valid id or jQuery object of parent.
    If parent is not set then Button control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Button text.
    @property {String} text
    **/
    this.text = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    A json object containing icon information.
    @property {Object} icon
    @example 
    var buttonParams = {
        'id': 'btnHelloWorld'
        ...
        ...
        'icon': {
            'url': '/icons/hello-world.png', //absolute or relative path
            'position': 'left' //position values are: top, bottom, left, right    
        }
    }

    **/
    this.icon = undefined;

};

/**
An HTML button control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Button
@param {Controls.ButtonParams} params Button control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.0.0
@constructor
@example
function CreateButton() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    'id':'btnHello',
                    'parent': 'buttonParent', // or $('#buttonParent')
                    'text': 'Hello' 
                    'css': 'buttonControl'
                };
            var button = new controls.Button(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Button = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    if(params.icon) this._iconParams = params.icon;

    /**
    Text property of button.
    @property {String} text
    @public
    **/
    Object.defineProperty(this, "text",{
        get : function () {
            return $(this._element).text();
        },
        set : function (text) {
            var spantext = $(this._element).find('span');
            if(spantext.size()) {
                spantext.text(text);
            } else {
                $(this._element).text(text);
            }
        },
        enumerable : true
    });

    /**
    Icon property of button.
    Setting this property will change the icon/position based on the input arguments.
    @property {Object} icon
    @example 
        myButton.icon = {
            'url': '/icons/hello-world.png', //absolute or relative path
            'position': 'left' //position values are: top, bottom, left, right    
        }
    @public
    **/
    Object.defineProperty(this, "icon",{
        get : function () {
            return this._iconParams;
        },
        set : function (value) {
            this._iconParams = value;
            var iconElem = $(this._element).find('img');
            if(!iconElem.size()) return;
            if(value.position) {
                if(value.position === 'top' || value.position === 'left') {
                    iconElem.prependTo(this._element);
                } else {
                     iconElem.appendTo(this._element);
                }
            }
            if(value.url) {
                iconElem[0].src = value.url;
            }
        },
        enumerable : true
    });

    BaseControl.extend(this);
    //add button specific events here

};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.ButtonParams} params Button control parameters 
@return {Object} jQuery object of Button control.
**/
Button.prototype._createControl = function (params) {
    var id = params.id || 'button';
    var text = params.text || '';
    var css = params.css || '';
    var icon = params.icon || null;

    if(icon !== null) {
        if(!icon.position) icon.position = 'left';
        if(!icon.width) icon.width = 20;
        if(!icon.height) icon.height = 20;
    }
    var options = {
        'id': id,
        'text': text,
        'css': css,
        'icon': icon
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['button'](options));
    return parent.find('#' + id);
};

/** 
Initialize button
@private
@method onInitialize
**/
Button.prototype.onInitialize = function () {
    this._icon = this._element.find('.ui-button-icon');
    
};

/** 
Bind a Button control to specific dom element 
@method bind
@public
@param {Object} button A DOM or jQuery object to which you want to bind this Button object. 
@return {Controls.Button}
**/
Button.bind = function (button) {
	return new Button(button);
};

Controls.Button = Button;

/**   
Checkbox control parameters.
@class CheckboxParams
@since 1.0.0
@see Controls.Checkbox
@unlisted
**/
var CheckboxParams = function() {

    /**
    An id of checkbox control.
    @property {String} id
    @default 'checkbox'
    **/
    this.id = undefined;

    /**
    Parent of checkbox control. Pass valid id or jQuery object of parent.
    If parent is not set then Checkbox control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Checkbox text.
    @property {String} text
    **/
    this.text = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    An initial state of checkbox.
    @property {Boolean} checked
    @default false
    **/
    this.checked = undefined;

    /**
    An initial position of checkbox label.
    @property {Controls.CheckboxLabelPosition} labelPosition
    @since 1.2.0
    @default
    **/
    this.labelPosition = undefined;

    /**
    An external css class for label.
    @property {String} labelCss
    @since 1.2.0
    **/
    this.labelCss = undefined;

};

/**   
This enum lists all the supported label positions.
@enum CheckboxLabelPosition
@since 1.2.0
@static
@unlisted
**/
var CheckboxLabelPosition = {
    /**
    @property Left
    @readonly
    **/
    'Left': 'left',
    /**
    @property Right
    @readonly
    **/
    'Right': 'right'
};

/**
An HTML Checkbox control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Checkbox
@param {Controls.CheckboxParams} params Checkbox control parameters.
@namespace Controls
@since 1.0.0
@extends Controls.BaseControl
@constructor
@example
function CreateCheckbox() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    'id':'chkHello',
                    'parent': 'checkboxParent', // or $('#checkboxParent')
                    'text': 'Hello',
                    'checked': true,
                    'css': 'checkboxControl'
                };
            var checkbox = new controls.Checkbox(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Checkbox = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    this._label = undefined;
    BaseControl.extend(this);

    /**
    Get or set checked property of checkbox.
    @property {Boolean} checked
    @public
    **/
    Object.defineProperty(this, "checked",{
        get : function () {
            return $(this._element).is(':checked');
        },
        set : function (value) {
            value ? $(this._element).attr('checked', 'checked') : $(this._element).removeAttr('checked');
        },
        enumerable : true
    });

    /**
    Get or set value property of checkbox.
    @property {String} value
    @public
    **/
    Object.defineProperty(this, "value",{
        get : function () {
            return $(this._element).attr('value');
        },
        set : function (value) {
            $(this._element).attr('value', value);
        },
        enumerable : true
    });

    /**
    Get or set text property of checkbox.
    @property {String} text
    @public
    **/
    Object.defineProperty(this, "text",{
        get : function () {
            return $(this._label).text();
        },
        set : function (text) {
            $(this._label).text(text);
        },
        enumerable : true
    });

    /**
    Fires on check change of checkbox. 
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');
    this._bindEvent('change');

};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.CheckboxParams} params Checkbox control parameters 
@return {Object} jQuery object of Checkbox control.
**/
Checkbox.prototype._createControl = function (params) {
    var id = params.id || 'checkbox';
    var text = params.text || '';
    var css = params.css || '';
    var labelCss = params.labelCss || '';
    var labelPosition = params.labelPosition || CheckboxLabelPosition.Right;
    if(labelPosition == CheckboxLabelPosition.Left) {
        css = css + ' ui-checkbox-leftmargin';
    } else {
        css = css + ' ui-checkbox-rightmargin';
    }

    var options = {
        'id': id,
        'text': text,
        'css': css,
        'labelCss': labelCss,
        'labelPosition': labelPosition
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['checkbox'](options));
    return parent.find('#' + id);
};

/** 
Initialize checkbox
@private
@method onInitialize
**/
Checkbox.prototype.onInitialize = function () {
    var nextCtrl = $(this._element).next();
    if(nextCtrl.attr('for') === this.id) {
        this._label = nextCtrl;
    } else {
        var ctrl = $('body').find('[for="'+ this.id +'"]');
        if(ctrl.size() > 0)
            this._label = ctrl;
    }
};

/** 
Remove additional elements.
@private
@method onRemove
**/
Checkbox.prototype.onRemove = function() {
    this._label.remove();
};

/** 
Bind a Checkbox control to specific dom element 
@method bind
@public
@param {Object} checkbox A DOM or jQuery object to which you want to bind this Checkbox object. 
@return {Controls.Checkbox}
**/
Checkbox.bind = function(checkbox) {
    return new Checkbox(checkbox);
};

Controls.Checkbox = Checkbox;
Controls.CheckboxLabelPosition = CheckboxLabelPosition;
/**   
Dialog control parameters.
@class DialogParams
@since 1.5.0
@see Controls.Dialog
@unlisted
**/
var DialogParams = function(){

    /**
    An id of Dialog control.
    @property {String} id
    @default 'Dialog'
    **/
    this.id = undefined;

    /**
    Parent of Dialog control. Pass valid id or jQuery object of parent.
    If parent is not set then Dialog control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    Hide close button.
    @property {Boolean} hideClose
    @default false
    **/
    this.hideClose = undefined;

    /**
    Hide footer of dialog.
    @property {Boolean} hideFooter
    @default false
    **/
    this.hideFooter = undefined;

    /**
    Set if it is a model dialog.
    @property {Boolean} isModel
    @default true
    **/
    this.isModel = undefined;    

};

/**
An HTML Dialog control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Dialog
@param {Controls.DialogParams} params Dialog control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.5.0
@constructor
@example
function CreateDialog() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    'id':'Dialog',
                    'parent': 'DialogParent', // or $('#DialogParent')
                    'css': 'DialogControlCss'
                };
            var Dialog = new controls.Dialog(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Dialog = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    this._items = [];
    params.isModel !== undefined ? this._isModel = params.isModel : this._isModel = true;

    BaseControl.call(this);
    //initialize base first
    //add default keyboard and mouse events to control
    this.initialize();

    /**
    Content element.
    @property {Object} content
    @public
    **/
    Object.defineProperty(this, "content",{
        get : function () {
            return this._content;
        },
        set : function (content) {
            this._content.empty().append(content);
        },
        enumerable : true
    });

    /**
    @event close
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.close = new CoreLibrary.EventSource('close');
    
};

Dialog.prototype = Object.create(BaseControl.prototype, {
    constructor:{
        value:Dialog
    }
});

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.DialogParams} params Dialog control parameters 
@return {Object} jQuery object of Dialog control.
**/
Dialog.prototype._createControl = function (params) {
    var id = params.id || 'dialog';
    var css = params.css || '';
    var hideClose = params.hideClose || false;
    var hideFooter = params.hideFooter || false;

    var options = {
        'id': id,
        'css': css,
        'hideClose': hideClose,
        'hideFooter': hideFooter
    };
    var dialog = $(Handlebars.templates['dialog'](options));
    $('body').append(dialog);
    return dialog;
};

/** 
Initialize Dialog
@private
@method onInitialize
**/
Dialog.prototype.onInitialize = function () {
    var me = this;
    this._createBlockUI();
    this._content = this._element.find('.ui-dialog-content');
    this._close = this._element.find('.ui-dialog-close');
    this._close.click(function() {
        me.hide();
        me.close.fire();
    });
};

/** 
On show callback
@private
@method onShow
**/
Dialog.prototype.onShow = function () {
    this._createBlockUI();
};

/** 
Create block ui
@private
@method _createBlockUI
**/
Dialog.prototype._createBlockUI = function () {
    if (this._isModel && !this._blockid) {
        var me = this;
        this._blockid = BlockUI.create(this._element, 1, true);
        this._blockid.blockDialog();
        this._blockid.close.bind(function() {
            me.onRemove();
            me.close.fire();
        });
    }
};

/** 
Remove block ui
@private
@method _deleteBlockUI
**/
Dialog.prototype._deleteBlockUI = function () {
    if (this._isModel && this._blockid) {
        this._blockid.unblock();
        delete this._blockid;
    }
};

/** 
On hide callback
@private
@method onHide
**/
Dialog.prototype.onHide = function () {
    this._deleteBlockUI();
};

/** 
On remove callback
@private
@method onRemove
**/
Dialog.prototype.onRemove = function () {
    this._deleteBlockUI();
};

Controls.Dialog = Dialog;

/**   
DockLayout control parameters.
@class DockLayoutParams
@since 1.1.0
@see Controls.DockLayout
@unlisted
**/
var DockLayoutParams = function(){

    /**
    Id of the dock layout control.
    @property {String} id
    @default 'docklayout'
    **/
    this.id = undefined;

    /**
    Parent of the panel control. Requires valid id or jQuery object of parent.
    If parent is not set then the Panel control will be appended to the body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;


};

/**
Creates a DockLayout to hold controls. The DockLayout arranges content based on the docking side.
For an interactive demonstration please see: {Interactive Control Demos}.

@class DockLayout
@param {Controls.DockLayoutParams} params DockLayout control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.0.0
@constructor
@example
function CreateDockLayout() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var dockLayout = new controls.DockLayout({
                id:'panelControl'
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var DockLayout = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    BaseControl.extend(this);

    /**
    Fires when the panel is resized
    @event resize
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.resize = new CoreLibrary.EventSource('resize');

    this._dockLocations = {};
    var _contentArea = {};

    var left = $(this._element).find('.ui-dock-layout-left');
    var center = $(this._element).find('.ui-dock-layout-center');
    var right = $(this._element).find('.ui-dock-layout-right');
    var top = $(this._element).find('.ui-dock-layout-top');
    var bottom = $(this._element).find('.ui-dock-layout-bottom');
    var middle = $(this._element).find('.ui-dock-layout-middle');

    var ResizerDimensioner = function (direction, control) {
        this.direction = direction;
        this.control = control;
        this.handle = $(control).children('.ui-dock-layout-' + direction + '-resizer');
        var self = this;
        this.oldDimension = undefined;
        this.oldPosition = undefined;
    };

    ResizerDimensioner.prototype = {

        setDimension: function (e) {
            
            var controlWidth = this.handle.width();
            var controlHeight = this.handle.height();
            
            switch(this.direction) {
                case 'left':
                    this.control.width(this.oldDimension - (this.oldPosition - e.pageX) + controlWidth);
                break;
                case 'right':
                    this.control.width(this.oldDimension + (this.oldPosition - e.pageX) + controlWidth);
                break;
                case 'top':
                    this.control.height(this.oldDimension - (this.oldPosition - e.pageY) + controlHeight);
                break;
                case 'bottom':
                    this.control.height(this.oldDimension + (this.oldPosition - e.pageY) + controlHeight);
                break;
            }
        },

        storePositions: function(e) {
            if(this.direction == 'left' || this.direction == 'right') {
                this.oldDimension =  this.control.width();
                this.oldPosition = e.pageX;
            } else {
                this.oldDimension =  this.control.height();
                this.oldPosition = e.pageY;
            }
        }
    };

    var self = this;
    var bindResizer = function (direction, control) {
        var elem = $(control).children('.ui-dock-layout-' + direction + '-resizer');
        if(!elem.size()) return;
        var dimensioner = new ResizerDimensioner(direction, control);
        var isDragging = false;
        var onMouseMove = function (e) {
            isDragging = true;
            dimensioner.setDimension(e);
            self.update();
            self.resize.fire();
        };

        var onMouseUp = function (e) {
            var wasDragging = isDragging;
            isDragging = false;
            $(self._element).removeClass('ui-disable-selection');
            $(window).unbind("mousemove");
            $(window).unbind("mouseup");
            if(!wasDragging) {
                self.update();
            }
        };

        elem.mousedown(function (e) {
            $(self._element).addClass('ui-disable-selection');
            dimensioner.storePositions(e);
            $(window).mousemove(onMouseMove);
            $(window).mouseup(onMouseUp);
        });
    };

    if(left.size()) {
        this._dockLocations.left = left;
        _contentArea.left =  new Controls.Panel({id: this.id + '-left-panel', parent: left, css: 'ui-dock-layout-panel', suppressHeader: true});
        bindResizer('left', left);
        this.resize.bind(function () { _contentArea.left.resize.fire(); });
    }
    if(center.size()) {
        this._dockLocations.center = center;
    }
    if(right.size()) {
        this._dockLocations.right = right;
        _contentArea.right = new Controls.Panel({id: this.id + '-right-panel', parent: right, css: 'ui-dock-layout-panel', suppressHeader: true});
        bindResizer('right', right);
        this.resize.bind(function () { _contentArea.right.resize.fire(); });
    }
    if(top.size()) {
        this._dockLocations.top = top;
        _contentArea.top = new Controls.Panel({id: this.id + '-top-panel', parent: top, css: 'ui-dock-layout-panel', suppressHeader: true});
        bindResizer('top', top);
        this.resize.bind(function () { _contentArea.top.resize.fire(); });
    }
    if(bottom.size()) {
        this._dockLocations.bottom = bottom;
        _contentArea.bottom = new Controls.Panel({id: this.id + '-bottom-panel', parent: bottom, css: 'ui-dock-layout-panel', suppressHeader: true});
        bindResizer('bottom', bottom);
        this.resize.bind(function () { _contentArea.bottom.resize.fire(); });
    }
    if(middle.size()) {
        this._dockLocations.middle = middle;
        _contentArea.fill = new Controls.Panel({id: this.id + '-middle-panel', parent: middle, css: 'ui-dock-layout-panel', suppressHeader: true});
        this.resize.bind(function () { _contentArea.fill.resize.fire(); });
    }


    /**
    Returns the content within which the content needs to be created.
    @property {Controls.Panel} content
    @public
    @readonly
    **/
    Object.defineProperty(this, "content",{
        get : function () {
            return _contentArea;
        },
        enumerable : true
    });
   

    this.update();
    
};


/** 
Recalculates the layout
@method update
**/
DockLayout.prototype.update = function (params) {
    var totalWidth = $(this._element).width();
    var totalHeight = $(this._element).height();
    var tolerance = 1;
    //Set the width of the Center div. 
    //This div should take up all the space that is not being taken by the left and right divs
    if(this._dockLocations.center){
        var usedWidth = 0;
        if(this._dockLocations.left){
            usedWidth = usedWidth + $(this._dockLocations.left).outerWidth(true);
        }
        if(this._dockLocations.right){
            usedWidth = usedWidth + $(this._dockLocations.right).outerWidth(true);
        }
        var calculatedWidth = Math.round(totalWidth - usedWidth);
        var currentWidth = $(this._dockLocations.center).width();
        if(Math.abs(calculatedWidth - currentWidth) > tolerance) {
            $(this._dockLocations.center).css('width',calculatedWidth);
        }
    }

    //Set the height of the middle div. 
    //This div should take up all the space that is not being taken by the top and bottom divs
    if(this._dockLocations.middle) {
        var usedHeight = 0;
        if(this._dockLocations.top){
            usedHeight = usedHeight + $(this._dockLocations.top).outerHeight(true);
        }
        if(this._dockLocations.bottom){
            usedHeight = usedHeight + $(this._dockLocations.bottom).outerHeight(true);
        }
        
        var calculatedHeight = Math.round(totalHeight - usedHeight);
        var currentHeight = $(this._dockLocations.middle).height();
        if(Math.abs(calculatedHeight - currentHeight) > tolerance) {
            $(this._dockLocations.middle).css('height',calculatedHeight);
        }
    }
};

/** 
Create control from handlebar template.
@private
@method _createControl
@return {Object} jQuery object of DockLayout control.
**/
DockLayout.prototype._createControl = function (params) {
    var id = params.id || 'docklayout';
    var css = params.css || '';
   
   var paramsdock = params.dock;
   var dock = {};
   if(paramsdock) {
       dock = {
        left: paramsdock.left || false,
        right: paramsdock.right || false,
        center: (paramsdock.top || paramsdock.bottom || paramsdock.fill) ? { top: paramsdock.top || false, bottom: paramsdock.bottom || false, middle: paramsdock.fill || false} : false,
       };
    }


    var options = {
        id: id,
        css: css,
        dock : dock
    };

    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else
        parent = $(params.parent);

    parent.append(Handlebars.templates['docklayout'](options));
    return parent.find('#' + id);
};

Controls.DockLayout = DockLayout;
/**   
Dropdown control parameters.
@class DropdownParams
@since 1.0.0
@see Controls.Dropdown
@unlisted
**/
var DropdownParams = function(){

    /**
    An id of dropdown control.
    @property {String} id
    @default 'dropdown'
    **/
    this.id = undefined;

    /**
    Parent of dropdown control. Pass valid id or jQuery object of parent.
    If parent is not set then Dropdown control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Dropdown items that shall be displayed in the list.
    @property {Array} items
    **/
    this.items = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    Tab index.
    @property {Number} tabIndex
    **/
    this.tabIndex = undefined;

};

/**
An HTML dropdown control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Dropdown
@param {Controls.DropdownParams} params Dropdown control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.0.0
@constructor
@example
function CreateDropdown() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    'id':'dropdown',
                    'parent': 'dropdownParent', // or $('#dropdownParent')
                    'css': 'dropdownControl'
                };
            var dropdown = new controls.Dropdown(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Dropdown = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    BaseControl.extend(this);

    this._items = params.items || [];

    /**
    Selected value. Return empty string if nothing is selected.
    @property {String} selectedValue
    @public
    **/
    Object.defineProperty(this, "selectedValue",{
        get : function () {
            return this._getValue();
        },
        set : function (value) {
            value = $.trim(value);
            if(value !== '') {
                this._setValue(value);
            }
        },
        enumerable : true
    });

    /**
    Selected index. Return -1 if nothing is selected.
    @property {Number} selectedIndex
    @public
    **/
    Object.defineProperty(this, "selectedIndex",{
        get : function () {
            if(this.selectedText !== '') return $(this._ullist).find('li[selected="selected"]').index();
            else return -1;
        },
        set : function (index) {
            if(index >= 0) {
                this._setValue($(this._ullist).find('li:nth-child('+ (index+1) +')').attr('tag'));
            }
        },
        enumerable : true
    });

    /**
    Selected text. Return empty string if nothing is selected.
    @property {String} selectedText
    @public
    **/
    Object.defineProperty(this, "selectedText", {
        get : function () {
            return $.trim($(this._text).val());
        },
        set : function (text) {
            text = $.trim(text);
            if(text !== '') {
                this._setValue($(this._ullist).find('li').filter(function() { return $(this).text() == text;}).attr('tag'));
            }
        },
        enumerable : true
    });

    /*
    Object.defineProperty(this, "readonly",{
        get : function () {
            return $(this._text).attr('readonly') === 'readonly' ? true : false;
        },
        set : function (isreadonly) {
            isreadonly ? $(this._text).attr('readonly', 'readonly') : $(this._text).removeAttr('readonly');
        },
        enumerable : true
    });*/

    /**
    Dropdown list items.
    @property {Array} items
    @readonly
    @public
    **/
    Object.defineProperty(this, "items",{
        get : function () {
            return this._items;
        },
        enumerable : true
    });

    /**
    Fires when dropdown value changes.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.DropdownParams} params Dropdown control parameters 
@return {Object} jQuery object of Dropdown control.
**/
Dropdown.prototype._createControl = function (params) {
    var id = params.id || 'dropdown';
    //var items = params.items || [];
    var css = params.css || '';
    var tabindex = params.tabIndex || 1;
    var title = params.title || '';
    var items = params.items || [];

    var options = {
        'id': id,
        'items': items,
        'css': css,
        'tabindex': tabindex,
        'title': title
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['dropdown'](options));
    return parent.find('#' + id);
};

/** 
Initialize dropdown
@private
@method onInitialize
**/
Dropdown.prototype.onInitialize = function () {
    var me = this;
    this._text = this._element.find('input#ui-dropdown-input' + this.id);
    this._ullist = this._element.find('ul#ui-dropdown-list' + this.id);
    this._btnDown = this._element.find('.ui-dropdown-icon');
    this._btnDown.click(function () {
        me._ullist.toggle();
    });
    this._text.click(function () {
        me._ullist.toggle();
    });
    this.hide();
    this._ullist.find('li').click(function() {
        me._setValue($(this).attr('tag'));
        me.hide();
    });
    $('body').bind('click', function(e) { //hide on body click
        if(!$(e.target).closest(me._element).length) me.hide();
    });
};

/** 
Get selected value.
@private
@method _getValue
**/
Dropdown.prototype._getValue = function () {
    return $(this._ullist).find('li[selected="selected"]').attr('tag');
};

/** 
Set selected value.
@private
@method _setValue
**/
Dropdown.prototype._setValue = function (value) {
    this.clear();
    var li = $(this._ullist).find('li[tag="'+ value +'"]');
    this._text.val(li.text());
    li.attr('selected', 'selected');
    this.change.fire();
};

/** 
Clear selection.
@public
@method clear
**/
Dropdown.prototype.clear = function () {
    $(this._ullist).find('li[selected="selected"]').removeAttr('selected');
    $(this._text).val('');
};

/** 
User focus in control.
@private
@method onFocusIn
**/
Dropdown.prototype.onFocusIn = function () {
    this._text.focus();
};

/** 
Roll up dropdown options.
@public
@method hide
**/
Dropdown.prototype.hide = function () {
    this._ullist.hide();
};

/** 
Roll down dropdown options.
@public
@method show
**/
Dropdown.prototype.show = function () {
    this._ullist.show();
};

/** 
Bind a Dropdown control to specific dom element 
@method bind
@public
@param {Object} dropdown A DOM or jQuery object to which you want to bind this Dropdown object. 
@return {Controls.Dropdown}
**/
Dropdown.bind = function (dropdown) {
	return new Dropdown(dropdown);
};

Controls.Dropdown = Dropdown;

/**
An HTML Error dialog. For an interactive demonstration please see: {Interactive Control Demos}.

@class ErrorDialog
@param {Controls.ErrorParams} params Error control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.5.0
@constructor
@example
function ShowError() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var Controls = library.Controls;
            
            Controls.ErrorDialog.instance().show({
                'title': 'Please wait',
                'description': 'Saving..',
                'blockUI': true
            });

        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var _Error = function () {

    this._element = null;
    this._description = null;
    this._title = null;
    
    this._refCount = 0;
    
    /**
    Error title
    @property {String} title
    @public
    **/
    Object.defineProperty(this, "title",{
        get : function () {
            return this._title.text();
        },
        set : function (text) {
            this._title.text($.trim(text)).show();
        },
        enumerable : true
    });

    /**
    Error description
    @property {String} description
    @public
    **/
    Object.defineProperty(this, "description",{
        get : function () {
            return this._descripton.text();
        },
        set : function (text) {
            this._descripton.text($.trim(text));
        },
        enumerable : true
    });

    BaseControl.call(this);
    this.initialize();
};

_Error.prototype = Object.create(BaseControl.prototype, {
    constructor:{
        value:Error
    }
});

/** 
Initialize Error
@private
@method onInitialize
**/
_Error.prototype.onInitialize = function () {
    var args = {};
    args.id = 'errorDialog';
    args.title = '';
    args.description = '';
    var me = this;
    var dialogStr = Handlebars.templates['error'](args);

    this._parent = $('body');
    var dialog = $(dialogStr).prependTo(this._parent);
    this._element = $('#' + args.id);

    this._title = $(this._element).find('.ui-error-title');
    this._descripton = $(this._element).find('.ui-error-desc');
    this._btnClose = $(this._element).find('.ui-dialog-close');
    this._btnClose.bind('click', function() {
        me.hide();
    });

    this.hide();
};

/** 
Show error message
@method show
@param {Object} params Error's initial parameters. Title property is optional.
@examples

Error.instance().show({
    'title': 'Please wait',
    'description': 'Saving file..',
    'blockUI': true,
    'priority': 1
});

**/
_Error.prototype.show = function (params) {
    if (++this._refCount == 1) {
        if (!this._blockid) {
            this._blockid = BlockUI.create(this._element, params.priority);
        }
        this._blockid.blockDialog();
        $(this._element).show();
        if(params.title || $.trim(params.title) === '') this.title = params.title; else this._title.hide();
        if(params.description) this.description = params.description;
    }
    this.onShow();
};

/** 
Hide error message.
@method hide
**/
_Error.prototype.hide = function () {
    if (--this._refCount <= 0) {
        $(this._element).hide();
        this._refCount = 0;
        if (this._blockid) {
            this._blockid.unblock();
            delete this._blockid;
        }
    }
    this.onHide();
};

var ErrorDialog = (function () {
    var instance;
    return {
        instance: function () {

            if ( !instance ) {
                instance = new _Error();
            }
            return instance;
        }
    };
 
})();

Controls.ErrorDialog = ErrorDialog;
/**   
Feedback control parameters.
@class FeedbackParams
@since 1.0.0
@see Controls.Feedback
@unlisted
**/
var FeedbackParams = function(){

    /**
    An id of Feedback control.
    @property {String} id
    @default 'feedback'
    **/
    this.id = undefined;

    /**
    Parent of feedback control. Pass valid id or jQuery object of parent.
    If parent is not set then Feedback control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    External css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    Initial rating.
    @property {Number} rating
    @default 0
    **/
    this.rating = undefined;

    /**
    Initial comment.
    @property {String} comment
    **/
    this.comment = undefined;

    /**
    Feedback control's mode. Set it to false if it is first feedback else set it to true.
    @property {String} isEdit
    @default false
    **/
    this.isEdit = undefined;

};

/**
An HTML feedback control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Feedback
@param {Controls.FeedbackParams} params Feedback control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.0.0
@constructor
@example
function CreateFeedback() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var feedback = new controls.Feedback({
                id:'feedbackControl',
                parent: 'feedbackExample'
            });
            feedback.submit.bind(function () {
                $('#feedbackMessage').text(feedback.comment);       
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Feedback = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    if(params.rating !== undefined) this._rating = params.rating; //initial value if any, so we can set it after creating control
    if(params.isEdit !== undefined) this._isEdit = params.isEdit;
    BaseControl.extend(this);

    /**
    User rating.
    @property {Number} rating
    @public
    **/
    Object.defineProperty(this, "rating",{
        get : function () {
            return this._ratingControl.rating;
        },
        set : function (rating) {
            this._ratingControl.rating = rating;
            this._updateUIAndBindEvents();
        },
        enumerable : true
    });

    /**
    User comment.
    @property {String} comment
    @public
    **/
    Object.defineProperty(this, "comment",{
        get : function () {
            return this._txtComment.text;
        },
        set : function (comment) {
            this._txtComment.text = comment;
            this._updateUIAndBindEvents();
        },
        enumerable : true
    });

    /**
    Feedback control mode.
    @property {Boolean} isEdit
    @public
    **/
    Object.defineProperty(this, "isEdit",{
        get : function () {
            return this._isEdit;
        },
        set : function (isEdit) {
            this._isEdit = isEdit;
            this._updateUIAndBindEvents();
        },
        enumerable : true
    });

    /**
    Fires when feedback get submitted.
    @event submit
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.submit = new CoreLibrary.EventSource('submit');

    /**
    Fires when feedback get deleted.
    @event delete
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.delete = new CoreLibrary.EventSource('delete');
    
};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.FeedbackParams} params Feedback control parameters 
@return {Object} jQuery object of Feedback control.
**/
Feedback.prototype._createControl = function (params) {
    var id = params.id || 'feedback';
    var css = params.css || '';
    
    var rating, comment;
    rating = params.rating || 0;
    comment = $.trim(params.comment) || '';

    var options = {
        id: id,
        css: css,
        isEdit: this.isEdit
    };

    //rating
    var rating = {
        id: id + 'rating',
        rating: rating, //initial rating
        max: 5,
        readonly: false
    };

    options.rating = rating;

    //comment
    var comment = {
        id: id + 'txtComment',
        text: comment
    };
    options.comment = comment;

    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['feedback'](options));
    return parent.find('#' + id);
};

/** 
Initialize Feedback
@private
@method onInitialize
**/
Feedback.prototype.onInitialize = function () {
    var me = this;
    this._saveFeedbackButton = this._element.find('a#save');
    this._clearFeedbackButton = this._element.find('a#clear');
    this._pipeDiv = this._element.find('.ui-feedback-buttonpipe');
    this._txtComment = Textarea.bind(this._element.find('#' + this.id + 'txtComment'));
    this._ratingControl = Rating.bind(this._element.find('#' + this.id + 'rating'), {
        rating: this._rating,
        readonly: false
    });
    var showHideButtons = function () {
        if(!me._saveFeedbackButton.is(':visible')) {
            me._saveFeedbackButton.show();
            me._pipeDiv.show();
            if(!me._isEdit) {
                me._element.find('.ui-feedback-label').hide();
                me._element.find('.ui-feedback-button').show();
                me._clearFeedbackButton.hide();
                me._pipeDiv.hide();
            }
        }
    };
    if(this._isEdit) this._pipeDiv.hide();
    this._ratingControl.change.bind(function () {
        showHideButtons();
    });
    this._txtComment.keyup.bind(function () {
        showHideButtons();
    })
    this._updateUIAndBindEvents();
};

/** 
Virtual function implementation.
@private
@method onEnable
**/
Feedback.prototype.onEnable = function () {
    this._txtComment.enable();
    this._saveFeedbackButton.removeClass('ui-feedback-disable');
    this._clearFeedbackButton.removeClass('ui-feedback-disable');
    this._updateUIAndBindEvents();
    this._rating.enable();
};

/** 
Virtual function implementation.
@private
@method onDisable
**/
Feedback.prototype.onDisable = function () {
    this._txtComment.disable();
    this._saveFeedbackButton.unbind('click').addClass('ui-feedback-disable');
    this._clearFeedbackButton.unbind('click').addClass('ui-feedback-disable');
    this._rating.disable();
};

/** 
Update UI and bind events
@private
@method _updateUIAndBindEvents
**/
Feedback.prototype._updateUIAndBindEvents = function () {
    var me = this;
    this._saveFeedbackButton.unbind('click').bind('click', function (e) {
        me.submit.fire();
        e.preventDefault();
    });
    this._clearFeedbackButton.unbind('click').bind('click', function (e) {
        me.delete.fire();
        e.preventDefault();
    });
    this._updateUIAndChangeMode();
};

/** 
Update UI and change mode
@private
@method _updateUIAndChangeMode
**/
Feedback.prototype._updateUIAndChangeMode = function () {
    if(!this._isEdit) {
        this._element.find('.ui-feedback-label').show();
        this._element.find('.ui-feedback-button').hide();
        this._clearFeedbackButton.hide();
        this._saveFeedbackButton.hide();
    } else {
        this._element.find('.ui-feedback-label').hide();
        this._element.find('.ui-feedback-button').show();
        this._clearFeedbackButton.show();
        this._pipeDiv.hide();
        this._saveFeedbackButton.hide();
    }
};

/** 
Bind a Feedback control to specific dom element 
@method bind
@public
@param {Object} feedback A DOM or jQuery object to which you want to bind this Feedback object. 
@param {Object} params Control's initial params.
    @param {Number} params.rating Initial rating.
    @param {String} params.comment Initial comment.
    @param {Boolean} params.isEdit Feedback control's mode. Set it to false if it is first feedback else set it to true.
@return {Controls.Feedback}
**/
Feedback.bind = function (feedback, params) {
    var ctrl = new Feedback(feedback);
    if(params.rating !== undefined) ctrl._ratingControl.rating = params.rating;
    var comment = $.trim(params.comment);
    if(comment !== '') ctrl._txtComment.text = comment;
    if(params.isEdit !== undefined) {
        ctrl._isEdit = params.isEdit;
        ctrl._updateUIAndChangeMode();
        ctrl._pipeDiv.hide();
    }
    return ctrl;
};

Controls.Feedback = Feedback;


/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
This is an internal class that hold the implementation for managing File Handlers used by the FileManager
@private
@class _fileHandlers
**/
var _fileHandlers = function () {

    /**
    Key-Value pair of the File Handlers attached to the instance
    @private 
    @property _fileHandlers
    **/
    this._fileHandlers = {};
};

_fileHandlers.prototype = {

    /**
    Adds a File Handler to the collection and stores it against its accept type.
    @private
    @method _addFileHandler
    @param {String} id Unique id of the handler. The handler will be used based on the id matching the corresponding type in the parameter definition.
    @param {Controls.IFileHandler} handler The handler implementing the IFileHandler class
    **/
    _addFileHandler : function (id, handler) {
        var handlers = this._fileHandlers;
        handlers[id] = handler;
    },

    /**
    Removes a File Handler from the handler collection.
    @private
    @method _removeFileHandler
    @param {String} id Unique id of the handler.
    **/
    _removeFileHandler : function (id) {
        var handlers = this._fileHandlers;
        if(handlers[id] !== undefined) {
            delete handlers[id];
        }
    }
};

/**   
File type enum to list supported file type.
@enum FileHandlerTypeEnum
@since 1.3.0
@see Controls.FileManager
@static
**/
var FileHandlerTypeEnum = {
    /**
    @property File
    @readonly
    **/
    File:'file',

    /**
    @property Image
    @readonly
    **/
    Image:'image'
};

/**   
Singleton of the FileHandlers class that allows adding/removing File Handlers as well as accessing them by accept type.
There can be only one file handler for each accept type. While adding handler for particular accept type if handler already exists then it will be replaced by new one.
Clients can define their own handler for any accept type and write their corresponding handlers and add them.
@class FileHandlers
@static
@namespace Controls
@since 1.3.0
@see Controls.FileManager
@example
function addNewFileHandler() {
    
    FileHandlers.addFileHandler('image/*', object-of-Handler);
    
}
**/
var FileHandlers = (function () {

    var handlerinstance = new _fileHandlers();
    var parseHandlerType = function(accept) {
        var image = new RegExp(/((.jpg|.jpeg|.png|.bmp)$)|(^image\/\*$)/);
        var file = new RegExp(/\.[a-z]+$/);
        if(image.test(accept)) {
            return FileHandlerTypeEnum.Image;
        } else if(file.test(accept)) {
            return accept.replace(/[^\w]/gi, '');
        } else if (accept === '*.*') {
            return 'default';
        }
    };

    return {

        /**
        Returns the current collection of File Handlers.
        @method fileHandlers
        @static
        @return {Array[Controls.IFileHandler]} Collection of FileHandlers.
        **/
        fileHandlers : function () { return $.extend( {}, handlerinstance._fileHandlers);},

        /**
        Adds a File Handler.
        @method addFileHandler
        @static
        @param {String} accept A valid accept type. See valid accept types here: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#attr-accept
        @param {Controls.IFileHandler} handler The handler implementing the IFileHandler class
        **/
        addFileHandler : function (accept, handler) {
            handlerinstance._addFileHandler(parseHandlerType(accept),handler);
        },
        /**
        Removes a File Handler.
        @method removeFileHandler
        @static
        @param {String} accept A valid accept type.
        **/
        removeFileHandler : function (accept) {
            handlerinstance._removeFileHandler(parseHandlerType(accept));
        },
        /**
        Get a File Handler
        @method getFileHandler
        @static
        @param {String} accept A valid accept type. See valid accept types here: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#attr-accept
        @return {Controls.IFileHandler} handler An instance of the handler implementing the IFileHandler class
        **/
        getFileHandler : function (accept) {
            var id = parseHandlerType(accept);
            if(handlerinstance._fileHandlers[id] !== undefined) {
                return handlerinstance._fileHandlers[id];
            } else if (id !== undefined && accept !== 'default') {
                return handlerinstance._fileHandlers['default'];
            }
            return undefined;
        }
    };

})();

/**   
FileManager control parameters.
@class FileManagerParams
@since 1.3.0
@see Controls.FileManager
@unlisted
**/
var FileManagerParams = function() {

    /**
    An id of FileManager control.
    @property {String} id
    **/
    this.id = undefined;

    /**
    Parent of FileUpload control. Pass valid id or jQuery object of parent.
    If parent is not set then FileUpload control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Parent of File editor control. Pass valid id or jQuery object of parent.
    This field is optional and only valid if there is any file editor control.
    @property {String|Object} parent
    @default 'body'
    **/
    this.editorParent = undefined;

    /**
    File type filter. File upload control will limit file selection based on this property.
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#attr-accept
    @property {String} accept
    **/
    this.accept = undefined;

    /**
    Maximum file size. Value is in killobytes.
    @property {Number} maxsize
    @default 10240
    **/
    this.maxsize = undefined;

};

/**
Creates a FileManager which is responsible for managing file handlers based on accept type.

@class FileManager
@param {Controls.FileManagerParams} params FileManager control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.3.0
@constructor
@example
function CreateFileManager() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var fileManager = new controls.FileManager({
                id:'fileMamanger',
                parent: 'fileUpload',
                editorParent: 'imageEdit',
                accept: 'image/*'
            });
            fileManager.change.bind(function() {
                console.log(fileManager.value.fileURL);
            });
            fileManager.endchange.bind(function() {
                window.open(fileManager.value.fileURL);
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var FileManager = function (params) {
    this._value = undefined;
    this._hander = undefined;
    this._handlerData = {};
    /**
    Selected file.
    @property {Object} value
    @public
    **/
    Object.defineProperty(this, "value",{
        get : function () {
            return this._value;
        },
        set: function(value){
            if(value !== undefined) {
                this._value = value;
                if(this._handlerData !== undefined && this._handlerData.onValueChange !== undefined) {
                    this._handlerData.onValueChange(value);
                }
            }
        },
        enumerable : true
    });

    /**
    Underlying file handler data.
    @property {Object} handlerData
    @readonly
    @public
    **/
    Object.defineProperty(this, "handlerData",{
        get : function () {
            return this._handlerData;
        },
        enumerable : true
    });

    /**
    Event will be fired when value begin to change.
    @event beginchange
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.beginchange = new CoreLibrary.EventSource('beginchange');

    /**
    Event will be fired when file selection get changed.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

    /**
    Event will be fired when value change ends.
    @event endchange
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.endchange = new CoreLibrary.EventSource('endchange');
    this._create(params);

};

/** 
Create control from handlebar template.
@private
@method _create
@param {Controls.FileManagerParams} params FileManager control parameters
@return {Object} jQuery object of FileManager control.
**/
FileManager.prototype._create = function (params) {
    var handler = FileHandlers.getFileHandler(params.accept);
    if(handler !== undefined) {
        handler.create(params, this);
    }
};

/** 
Removes control created by FileHandler.
@method remove
**/
FileManager.prototype.remove = function () {
    if(this._handlerData !== undefined && this._handlerData.removeControls !== undefined) {
        this._handlerData.removeControls();
    }
};

/** 
Removes control created by FileHandler.
@method remove
**/
FileManager.prototype.resize = function () {
    if(this._handlerData !== undefined && this._handlerData.resize !== undefined) {
        this._handlerData.resize();
    }
};

/**
An Abstract class for creating File Handlers. All File Handlers must extend this class.
@class IFileHandler
@namespace Controls
@since 1.1.0
@constructor
**/
var IFileHandler = function () {};

/**
Static method that listens to change in a value.
@method onValueChange
@static
@param {Object} value New value
**/
IFileHandler.prototype.onValueChange = function (value) {
    
};

/**
Static method that is responsible to remove control from DOM.
FileHandler is creating UI controls so it should also remove controls from DOM when needed.
@method removeControls
@static
**/
IFileHandler.prototype.removeControls = function () {
    
};

/**
Static method that extends the Class with the IFileHandler Class to allow the Class to be used as a FileHandler.
@method extend
@static
@param {Object} control New Class
**/
IFileHandler.extend = function (control) {
    var basemethods = Object.getOwnPropertyNames(IFileHandler.prototype);
    for(var i=0, len=basemethods.length;i<len;i++) {
        var method = basemethods[i];
        if(typeof IFileHandler.prototype[method] === 'function' && method !== 'constructor' && control[method] === undefined) {
            control[method] = IFileHandler.prototype[method];
        }
    }
};

var DefaultFileUploadHandler = function () {
    IFileHandler.extend(this);
};

DefaultFileUploadHandler.prototype.create = function (params, filemanager) {
    var me = this;
    var handlerData = filemanager.handlerData;
    handlerData.fileManager = filemanager;
    handlerData.fileUpload = new FileUpload({
        id: params.id + 'fileUploadControl',
        parent: params.parent,
        accept: params.accept,
        maxsize: params.maxSize,
        uploadUrl: params.uploadUrl ? params.uploadUrl : undefined
    });
    
    handlerData.fileUpload.complete.bind(function(data) {
        return function(e) {
            data.fileManager._value = {
                url: data.fileUpload.value.url,
                fileURL: data.fileUpload.value.objectUrl + '#' + encodeURIComponent(data.fileUpload.fileName),
            };
            data.fileManager.endchange.fire();
        };
    }(handlerData));

    handlerData.removeControls = function(data) {
        return function () {
            data.fileUpload.remove();
            delete data.fileUpload;
        };
    }(handlerData);

    handlerData.onValueChange = function(data) {
        return function (value) {
            if(value.url || value.fileURL) {
                var valclone = $.extend({}, value);
                var file = Host.creativePlatformRuntime.createFile(valclone);
                var success = function(dataView) {
                    if(!data.fileUpload) return;
                    var blob;
                    try {
                        blob = new Blob([dataView]);
                    }
                    catch (e) {
                        if(e.name == 'InvalidStateError') {
                            blob = new Blob([dataView.buffer]);
                        }
                    }
                    
                    var objUrl = window.URL || window.webkitURL;
                    
                    //set fileupload control value
                    var val = {
                        fileName : file.name,
                        objectUrl : objUrl.createObjectURL(blob),
                        url : valclone.url
                    };

                    data.fileUpload.changeFile(val);
                };
                file.readAsDataView(success);
            }
        };
    }(handlerData);
};

var FileUploadAndEditHandler = function () {
    IFileHandler.extend(this);
};

FileUploadAndEditHandler.prototype.create = function (params, filemanager) {
    var me = this;
    var handlerData = filemanager.handlerData;
    handlerData.value = {
        url: '',
        fileURL: undefined,
        editor: {
            original: '',
            operations: []
        }
    };
    handlerData.params = params;
    handlerData.fileUpload = new FileUpload({
        id: params.id + 'fileUploadControl',
        parent: params.parent,
        accept: params.accept,
        maxsize: params.maxSize,
        uploadUrl: params.uploadUrl ? params.uploadUrl : undefined
    });
    if(params.config && params.config.mask) {
        handlerData.mask = new CoreLibrary.Sketch2D(params.config.mask);
    }

    handlerData.fnEndEdit = function (data) {
        return function() {
            if(data.value && data.value.fileURL)
                Utility.unloadFileFromMemory(data.value.fileURL);

            data.value.fileURL = data.imageEdit.image + '#' + encodeURIComponent(data.fileUpload.fileName);
            data.value.editor.operations.push({
                'xform': data.imageEdit.transformMatrix.elements
            });

            filemanager._value = data.value;
            $(data.params.editorParent).hide();
            data.imageEdit.hide();
            filemanager.change.fire();

            //upload new file to server
            var val = data.fileUpload.value;
            val.objectUrl = data.imageEdit.image;
            data.fileUpload.value = val;
            //filemanager._value.fileURL = val.objectUrl;
            data.fileUpload.uploadFile();
        };
    }(handlerData);

    handlerData.fileUpload.uichange.bind(function(data) {
        return function(e) {
            if(e.data === UIChangeTypeEnum.SelectFile) {
                filemanager.beginchange.fire();
            } else if(e.data === UIChangeTypeEnum.BeginImageEdit && data.imageEdit) {
                $(data.params.editorParent).show();
                data.imageEdit.show();
                data.imageEdit.change.unbind();
                data.imageEdit.change.bind(function() {
                    data.fileUpload._onEndImageEdit();
                    data.fnEndEdit();
                });
                filemanager.beginchange.fire();
            } else if (e.data === UIChangeTypeEnum.EndImageEdit && data.imageEdit) {
                data.fnEndEdit();
            }
        };
    }(handlerData));

    handlerData.fileUpload.complete.bind(function(data) {
        return function(e) {
            if(!data.fileUpload) return;
            if(data.params.editorParent && data.params.editorParent !== '') {
                if(data.fileChanged) {
                    if(data.imageEdit) data.imageEdit.remove();
                    
                    data.imageEdit = new ImageEdit({
                        id: data.params.id + 'imageEditControl',
                        parent: data.params.editorParent,
                        width: typeof data.params.editorParent == 'string' ? $('#'+ data.params.editorParent).width() : $(data.params.editorParent).width(),
                        height: typeof data.params.editorParent == 'string' ? $('#'+ data.params.editorParent).height() : $(data.params.editorParent).height(),
                        mask: data.mask
                    });
                    
                    data.imageEdit.image = data.fileUpload.value.objectUrl;
                    if(data.params.uploadUrl) //connected- set url and original to server url of uploaded image
                        data.value.editor.original = data.value.url = data.fileUpload.value.url;
                    else //disconnected- set blob url as original one
                        data.value.editor.original = data.value.fileURL;

                    $(data.params.editorParent).hide();
                    data.imageEdit.hide();
                    data.fileChanged = false;

                } else {
                    if(data.params.uploadUrl) //connected- set url and original to server url of uploaded image
                        data.value.url = data.fileUpload.value.url;
                }
                filemanager._value = data.value;
                filemanager.endchange.fire();
            }
        };
    }(handlerData));

    handlerData.fileUpload.change.bind(function(data) {
        return function() {
            data.fileChanged = true;
            // if(data.value && data.value.fileURL)
            //     Utility.unloadFileFromMemory(data.value.fileURL);
            data.value = {
                url: '',
                fileURL: data.fileUpload.value.objectUrl + '#' + encodeURIComponent(data.fileUpload.fileName),
                editor: {
                    original: '',
                    operations: []
                }
            };
            filemanager._value = data.value;
            filemanager.change.fire();
        };
    }(handlerData));

    handlerData.resize = function(data) {
        return function () {
            if(data.imageEdit){
                data.imageEdit.resize($(data.params.editorParent).width(), $(data.params.editorParent).height());
            }
        };
    }(handlerData);

    handlerData.removeControls = function(data) {
        return function () {
            data.fileUpload.remove();
            delete data.fileUpload;
            if(data.imageEdit) data.imageEdit.remove();
            $(data.params.editorParent).hide();
        };
    }(handlerData);

    handlerData.onValueChange = function(data) {
        return function (value) {
            if(value && value.editor && value.editor.original && value.editor.original !== '') {
                var obj = {
                    url: value.editor.original
                };
                data.value = $.extend({}, value);
                var file = Host.creativePlatformRuntime.createFile(obj);
                var success = function(dataView) {
                    if(!data.fileUpload) return;
                    var blob;
                    try {
                        blob = new Blob([dataView]);
                    }
                    catch (e) {
                        if(e.name == 'InvalidStateError') {
                            blob = new Blob([dataView.buffer]);
                        }
                    }
                    var objUrl = window.URL || window.webkitURL;
                    
                    //set fileupload control value
                    var val = data.fileUpload.value;
                    val.fileName = file.name;
                    val.objectUrl = objUrl.createObjectURL(blob);
                    val.url = value.editor.original;
                    data.fileUpload.changeFile(val);

                    //set image edit control value
                    var mask;
                    if(data.params.config && data.params.config.mask) {
                        mask = new CoreLibrary.Sketch2D(data.params.config.mask);
                    }
                    if(data.imageEdit) data.imageEdit.remove();
                    data.imageEdit = new ImageEdit({
                        id: data.params.id + 'imageEditControl',
                        parent: data.params.editorParent,
                        width: typeof data.params.editorParent == 'string' ? $('#'+ data.params.editorParent).width() : $(data.params.editorParent).width(),
                        height: typeof data.params.editorParent == 'string' ? $('#'+ data.params.editorParent).height() : $(data.params.editorParent).height(),
                        mask: mask
                    });
                    data.imageEdit.image = val.objectUrl;
                    data.imageEdit.change.bind(function(){
                        if(value.editor.operations.length !== 0) { // apply transformation
                            for (var i = 0; i < value.editor.operations.length; i++) {
                                data.imageEdit.transformMatrix = new CoreLibrary.Matrix2D(value.editor.operations[i].xform);
                            }
                        }
                    });
                    $(data.params.editorParent).hide();
                    data.imageEdit.hide();
                };
                file.readAsDataView(success);
            }
        };
    }(handlerData);

};

var initializeDefaultFileHandlers = function() {
    FileHandlers.addFileHandler('image/*', new FileUploadAndEditHandler());
    FileHandlers.addFileHandler('*.*', new DefaultFileUploadHandler());
};

Controls.FileManager = FileManager;
Controls.FileHandlers = FileHandlers;

/**   
UIChangeTypeEnum type enum.
@enum UIChangeTypeEnum
@since 1.3.0
@see Controls.FileUploadParams
@static
@unlisted
**/
var UIChangeTypeEnum = {
    /**
    @property BeginImageEdit
    @readonly
    **/
    BeginImageEdit:0,

    /**
    @property EndImageEdit
    @readonly
    **/
    EndImageEdit:1,

    /**
    @property SelectFile
    @readonly
    **/
    SelectFile:2
};

/**   
FileUpload control parameters.
@class FileUploadParams
@since 1.3.0
@see Controls.FileUpload
@unlisted
**/
var FileUploadParams = function() {

    /**
    An id of FileUpload control.
    @property {String} id
    @default 'fileupload'
    **/
    this.id = undefined;

    /**
    Parent of FileUpload control. Pass valid id or jQuery object of parent.
    If parent is not set then FileUpload control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    File type filter. File upload control will limit file selection based on this property. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#attr-accept
    @property {String} accept
    **/
    this.accept = undefined;

    /**
    Maximum file size. Value is in bytes.
    @property {Number} maxsize
    @default 10485760
    **/
    this.maxsize = undefined;

    /**
    If this parameter is set, file upload control will automatically upload selected file to server. Otherwise file upload control will work in disconnected mode and return blob url.
    Pass valid upload url in this property.
    @property {String} uploadUrl
    **/
    this.uploadUrl = undefined;

};

/**   
FileUpload control value.
@class FileUploadValue
@since 1.3.0
@see Controls.FileUpload
@unlisted
**/
var FileUploadValue = {

    /**
    A selected file name.
    @property {String} fileName
    **/
    fileName: undefined,

    /**
    A valid server url.
    @property {String} url
    **/
    url: undefined,

    /**
    An object url pointing to file's blob data.
    @property {String} objectUrl
    **/
    objectUrl: undefined

};

/**
An HTML FileUpload control.

@class FileUpload
@param {Controls.FileUploadParams} params FileUpload control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.3.0
@constructor
@example
function CreateFileUpload() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var fileUpload = new controls.FileUpload({
                id: 'fileUploadControl',
                parent: 'uploadParent',
                accept: 'image/*',
                maxsize: 10240
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var FileUpload = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    this._maxSize = (params.maxsize !== undefined && parseInt(params.maxsize)) && params.maxsize ? params.maxsize : 10485760; //10 mb
    this._accept = params.accept ? $.trim(params.accept) : undefined;
    this._imagePattern = new RegExp(/((.jpg|.jpeg|.png|.bmp)$)|(^image\/\*$)/);
    if(this._imagePattern.test(this._accept)) {
        this._type = FileHandlerTypeEnum.Image;
        this._browseText = 'Drag a picture here';
    } else {
        this._type = FileHandlerTypeEnum.File;
        this._browseText = 'Drag a file here';
    }
    this._value = $.extend({},FileUploadValue);

    this._disconnected = true;
    if(params.uploadUrl) {
        this._uploadURL = params.uploadUrl;
        this._disconnected = false;
    }
    
    /**
    Allowed max file size.
    @property {Number} maxsize
    @public
    @readonly
    **/
    Object.defineProperty(this, "maxsize",{
        get : function () {
            return this._maxSize;
        },
        enumerable : true
    });

    /**
    Selected file name.
    @property {String} fileName
    @public
    @readonly
    **/
    Object.defineProperty(this, "fileName",{
        get : function () {
            return this._value.fileName;
        },
        enumerable : true
    });

    /**
    Control value.
    @property {FileUploadValue} value
    @public
    @readonly
    **/
    Object.defineProperty(this, "value",{
        get : function () {
            return this._value;
        },
        set: function(value) {
            this._value = value;
        },
        enumerable : true
    });

    /**
    Event will be fired when file upload complete.
    @event complete
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.complete = new CoreLibrary.EventSource('complete');

    /**
    Event will be fired when file selection get changed.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

    /**
    Event will be fired when any ui change happens. {Controls.UIChangeTypeEnum} will be passed in as data so that listeners can react to that ui change.
    Currently it is only valid in case of {Controls.FileHandlerTypeEnum}'s Image type.
    @event uichange
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.uichange = new CoreLibrary.EventSource('uichange');

    /**
    Event will be fired when any error occurs.
    @event error
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.error = new CoreLibrary.EventSource('error');

    BaseControl.extend(this);
    
};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.FileUploadParams} params FileUpload control parameters 
@return {Object} jQuery object of FileUpload control.
**/
FileUpload.prototype._createControl = function (params) {
    var id = params.id || 'fileUpload';
    var css = params.css || '';
    
    var options = {
        'id': id,
        'css': css
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['fileupload'](options));
    return parent.find('#' + id);
};

/** 
Initialize FileUpload
@private
@method onInitialize
**/
FileUpload.prototype.onInitialize = function () {
    var me = this;
    this._content = this._element.find('#' + this.id + 'content');
    this._contentText = this._element.find('#' + this.id + 'contenttext');
    this._contentText.text(this._browseText);
    this._progress = this._element.find('#' + this.id + 'progress');
    this._message = this._element.find('#' + this.id + 'message');
    var dataSize = this._parseSizeAndDisplayuinit();

    if(this._type === FileHandlerTypeEnum.Image) {
        this._btnAdjustImage = new Button({
            id: this.id + 'adjustImage',
            text: 'Adjust',
            parent: this._element.find('#' + this.id + 'buttonContainer')
        });
        this._btnAdjustImage.hide();
        this._btnAdjustImage.click.bind(function(e){
            me._adjustImage.call(me, e);
        });

        this._btnDoneEditing = new Button({
            id: this.id + 'doneEditing',
            text: 'Done Adjusting',
            parent: this._element.find('#' + this.id + 'buttonContainer')
        });
        this._btnDoneEditing.hide();
        this._btnDoneEditing.click.bind(function(e){
            //update value
            me._onEndImageEdit();
            me.uichange.fire(UIChangeTypeEnum.EndImageEdit);
        });
        this._message.text('Accepts .png .jpg .bmp under ' + dataSize.size + ' ' + dataSize.displayUnit + ' for best results');
    } else {
        this._message.text('Accepts ' + this._accept + ', under ' + dataSize.size + ' ' + dataSize.displayUnit);
    }
    this._btnBrowseFile = new Button({
        id: this.id + 'browsefile',
        text: 'Or choose one',
        parent: this._element.find('#' + this.id + 'buttonContainer')
    });

    this._file = this._element.find('#' + this.id + 'file');

    if(this._accept) { //accept="audio/*|video/*|image/*|MIME_type"
        this._file.attr('accept', this._accept);
    }
    this._btnBrowseFile.click.bind(function () {
        me.uichange.fire(UIChangeTypeEnum.SelectFile);
        me._file.click();
    });

    var handleFileSelect = function(e) {
        me._content.removeClass('ui-file-content-hover');
        me._handleFileSelect.call(me, e);
    };

    var handleDragOver = function(e) {
        me._handleDragOver.call(me, e);
    };

    this._file.change(handleFileSelect);
    this._content[0].addEventListener('dragover', handleDragOver, false);
    this._content[0].addEventListener("dragleave", handleDragOver, false);
    this._content[0].addEventListener("drop", function(e){
        me.uichange.fire(UIChangeTypeEnum.SelectFile);
        handleFileSelect(e);
    }, false);

    $(document).bind('drop dragover', function (e) {
         e.preventDefault();
    });

};

FileUpload.prototype._parseSizeAndDisplayuinit = function() {
    var maxSize = parseInt(this._maxSize/1048576), displayUnit = 'MB'; //in mb
    if(maxSize < 1) {
        maxSize = parseInt(this._maxSize/1024); //in kb
        displayUnit = 'KB';
    }
    return {
        size: maxSize,
        displayUnit: displayUnit
    };
};

/** 
Reset control
@method reset
**/
FileUpload.prototype.reset = function () {
    this._file.wrap('<form>').closest('form').get(0).reset();
    if(this._type === FileHandlerTypeEnum.Image) {
        this._btnAdjustImage.hide();
        this._btnDoneEditing.hide();
    }
    this._content.html('').text(this._browseText).removeClass('ui-file-content-selected');
    this.setError(false);
};

/** 
Do UI changes on begin image edit
@private
@method onBeginImageEdit
**/
FileUpload.prototype._onBeginImageEdit = function () {
    this._btnAdjustImage.hide();
    this._btnDoneEditing.show();
    this._content.addClass('ui-file-content-thumb-blur');
};

/** 
Do UI changes on end image edit
@private
@method onEndImageEdit
**/
FileUpload.prototype._onEndImageEdit = function () {
    this._btnAdjustImage.show();
    this._btnDoneEditing.hide();
    this._content.removeClass('ui-file-content-thumb-blur');
};

/** 
Handles drag over.
@private
@method _handleDragOver
**/
FileUpload.prototype._handleDragOver = function (e) {
    e.stopPropagation();
    e.preventDefault();
    if(e.type == "dragover") {
        this._content.addClass('ui-file-content-hover');
    } else {
        this._content.removeClass('ui-file-content-hover');
    }
};

FileUpload.prototype._setContent = function() {
    if(this._type === FileHandlerTypeEnum.Image) {
        this._btnAdjustImage.show();
        this._btnDoneEditing.hide();
        this._btnBrowseFile.text = 'Change';
        var img = $('<img class="ui-file-content-thumb" src="'+ this._value.objectUrl + '" title="' + this._value.fileName + '"/>');
        this._content.addClass('ui-file-content-selected').html(img);
        img[0].onload = function() { //resize small image to some value
            if(img.height() < 110) {
                img.css({
                    'height': '110px',
                    'width': 'auto'
                });
            }
        };
    } else {
        this._content.html(this._value.fileName);
    }
};

FileUpload.prototype._createBlob = function(objUrl, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', objUrl, true);
    xhr.responseType = 'blob';
    xhr.onload = function(e) {
        //fix for firefox as it doesnt seem to handle object urls well with xhr and 
        //sets the status to 0 despite returning the correct result.
        if (this.status == 200 || (this.status === 0 && this.response)) {
            callback(this.response);
        }
    };
    xhr.send();
};

/** 
Handles file select.
@private
@method _handleFileSelect
**/
FileUpload.prototype._handleFileSelect = function (e) {
    var me = this;
    if(e) {
        e.stopPropagation();
        e.preventDefault();
        var files = e.target.files || e.dataTransfer.files; // FileList object
        if(files.length > 0) {
            //validate file before moving ahead
            if(!this._validate(files[0])) return;

            this._content.removeClass('ui-file-content-selected').removeClass('ui-file-content-thumb-blur');
            this._value = $.extend({},FileUploadValue);
            this._value.fileName = files[0].name;
            
            var reader = new FileReader();
            reader.onload = (function(theFile) {
                return function(evt) {
                    //create blob from base64
                    var url =  Utility.createObjectUrl(evt.target.result);
                    me._value.objectUrl = url;
                    me._setContent();
                    me.change.fire();

                    //read file and then upload to server
                    if(!me._disconnected) {
                        me._createBlob(url, function(blob) {
                            me._uploadFile.call(me, blob).done(function(fileUrl) {
                                me._value.url = fileUrl;
                                me.complete.fire();
                                blob = null;
                            });
                        });
                    } else {
                        me._value.url = '';
                        me.complete.fire();
                    }
                };
            })(files[0]);
            reader.readAsDataURL(files[0]);
        }
    }
};

/** 
Read file data from object url set in value and then upload it to server.
Must set valid object url in control value before calling this method.
@method uploadFile
**/
FileUpload.prototype.uploadFile = function (value) {
    var me = this;
    if(!this._disconnected) { //if file isn't exsist on server then upload it
        this._createBlob(this._value.objectUrl, function(blob) {
            me._uploadFile.call(me, blob).done(function(fileUrl) {
                me._value.url = fileUrl;
                me.complete.fire();
                blob = null;
            });
        });
    } else {
        this.complete.fire();
    }
};

/** 
Auto select file from given value.
@method changeFile
@param {FileUploadValue} value Control value.
**/
FileUpload.prototype.changeFile = function (value) {
    this._value = value;
    this._setContent();
};

/** 
Control indicates error in selecting file.
@method setError
@param {Boolean} hasError Error flag.
**/
FileUpload.prototype.setError = function (hasError) {
    if(hasError) this._message.addClass('ui-file-message-error');
    else this._message.removeClass('ui-file-message-error');
};

/** 
Validates selected file before uploading it to server.
@private
@method _validate
**/
FileUpload.prototype._validate = function (file) {
    var error = '';
    var ext = file.name.split('.')[file.name.split('.').length - 1].toLowerCase();
    if(this._type === FileHandlerTypeEnum.Image && !new RegExp(/((jpg|jpeg|png|bmp)$)/).test(ext)) {
        error = 'Please select an image';
        error = new Error(error);
        error.name = 'FileTypeError';
    } else if (this._type !== FileHandlerTypeEnum.Image && this._accept.indexOf(ext) < 0) {
        error = 'Please select a valid file. Allowed files are: ' + this._accept;
        error = new Error(error);
        error.name = 'FileTypeError';
    }
    if(error === '' && (parseInt(file.size) > this._maxSize)) {
        if(this._type === FileHandlerTypeEnum.Image)
            error = 'Please select image smaller than ' + this._parseSizeAndDisplayuinit().size + ' ' + this._parseSizeAndDisplayuinit().displayUnit;
        else 
            error = 'Please select file smaller than ' + this._parseSizeAndDisplayuinit().size + ' ' + this._parseSizeAndDisplayuinit().displayUnit;
        error = new Error(error);
        error.name = 'FileSizeError';
    }
    if(error) {
        if(this._value.fileName === undefined)
            this.reset();
        this.error.fire(error);
        return false;
    }
    return true;
};

/** 
Handles image edit.
@private
@method _adjustImage
**/
FileUpload.prototype._adjustImage = function () {
    this._onBeginImageEdit();
    this.uichange.fire(UIChangeTypeEnum.BeginImageEdit);
};

/** 
Upload file to server.
@private
@method _uploadFile
@param {Object} blob File data in blob format.
@return {Object} jQuery's deferred object will be returned.
**/
FileUpload.prototype._uploadFile = function (blob) {
    var me = this, formData = new FormData(), url = '';
    formData.append('file', blob, encodeURIComponent(this._value.fileName));
    if(this._value.url && this._value.url !== '') {
        url = /(.*)\/[^\/]*\/[^\/]*/.exec(this._value.url)[1];
    } else 
        url = this._uploadURL + '/userdata/public';
    var dfd = new $.Deferred();
    $.ajax({
        url: url,
        type: 'POST',
        xhrFields: { withCredentials: true },
        xhr: function()
        {
            var xhr = new XMLHttpRequest();
            //upload progress
            xhr.upload.addEventListener("progress", function(evt){
              if (evt.lengthComputable) {
                if(evt.loaded !== evt.total)
                    me._progress.width(parseInt(evt.loaded / evt.total) + '%');
                else
                    me._progress.width('100%');
              }
            }, false);
            
            return xhr;
        },
        beforeSend: function() {
            me._progress.width('0%').show();
        },
        success: function(a, b, xhr) { //check status code 201
            me._progress.fadeOut(1000);
            dfd.resolve(me._uploadURL + xhr.getResponseHeader('location'));
        },
        error: function(a, b, xhr) {
            dfd.reject();
        },
        // Form data
        data: formData,
        //Options to tell jQuery not to process data or worry about content-type.
        cache: false,
        contentType: false,
        processData: false
    });
    return dfd;
};

Controls.FileUpload = FileUpload;
/**
A hover area marker control that shows UI selectors for HTML areas and allows clients to bind to the hover/click on selection those areas.

@class HoverArea
@namespace Controls
@since 1.5.0
@constructor
@example
function CreateHoverArea() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var hoverArea = new controls.HoverArea();
            hoverArea.bind(items); 
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
function HoverArea () {

	var items = {};

	/**
    Key value pair containing HoverItems
    @property {Object[String, Controls.HoverItem]} items 
    @public
    **/
    Object.defineProperty(this, "items",{
        get : function () {
            return items;
        },
        enumerable : true
    });

	this.hover = new CoreLibrary.EventSource('hover');
	this.click = new CoreLibrary.EventSource('click');
	
	var me = this;
	$(window).resize(function () {
		me.update();
		window.setTimeout( function () {
			me.update();	
		},500);
	});

	//HACK: fires an update the first time after 500ms to ensure that things are aligned correctly
	window.setTimeout(function () {
		me.update();
	},500);
}

HoverArea.prototype = {

	/** 
	Binds an area based on the input arguments.
	@method bind
	@param {Controls.HoverItemParams|Array[Controls.HoverItemParams]} params A collection of Hover Item parameters or a single parameter.
	**/
	bind: function (params) {
		var me = this;
		var _bind = function (param) {
			param.parent = param.parent || $('body');
			var item = new HoverItem(param);
			me.items[param.id] =  item;
			item.itemclick.bind(function (sender) {
				me.click.fire(sender.data,sender.originalEvent);
			});
			item.itemhover.bind(function (sender) {
				me.hover.fire(sender.data,sender.originalEvent);
			});
		};

		if(params instanceof Array) {
			for(var i=0,len=params.length;i<len;i++)
				_bind(params[i]);
		} else {
			_bind(params);
		}
	},

	/** 
	Removes a hover item based on the id
	@method remove
	@param {String} id Id of the HoverItem provided in the arguments to the bind method.
	**/
	remove: function (id) {
		if(this.items[id]) {
			this.items[id].remove();
			delete this.items[id];
		}
	},

	/** 
	Removes all the bound items
	@method clear
	**/
	clear: function () {
		for(var id in this.items) {
			this.remove(id);
		}
	},

	/** 
	Re-evaluates the layout of all the bound items
	@method update
	**/
	update: function () {
		for(var id in this.items) {
			var item = this.items[id];
			item.update();
		}
	}
};

/**   
HoverItemParams control parameters.
@class HoverItemParams
@since 1.5.0
@see Controls.HoverItem
@see Controls.HoverArea
@unlisted
**/
var HoverItemParams = function() {

    /**
    An id of HoverItem control.
    @property {String} id
    **/
    this.id = undefined;

    /**
    Parent of HoverItem control. Pass valid id or jQuery object of parent.
    If a parent is not set then the HoverItem control will be appended to the body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Specifies the type of Hover Item that needs to be displayed.
    @property {string} type
    **/
    this.type = undefined;

    /**
    The target element on which to set the HoverItem
    @property {HTMLElement} target
    **/
    this.target = undefined;

    /**
    Direction of the HoverItem 
    @property {String} direction
    **/
    this.direction = undefined;

    /**
    Css for the icon
    @property {String} iconcss
    **/
    this.iconcss = undefined;

    /**
    Additional Css for the HoverItem
    @property {String} css
    **/
    this.css = undefined;

};

/**
@class HoverItem
@namespace Controls
@since 1.5.0
@constructor
@example
function CreateHoverItem() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var hoverItem = new controls.HoverItem({
				id: 'someid',
				parent : document.getElementById('parentElement'),
				direction : 'top',
				target : document.getElementById('targetElement')
            });

            var hoverArea = new controls.HoverArea();
            hoverArea.bind(hoverItem); 
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
function HoverItem(params) {
	if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }

    this.parent = params.parent ? $(params.parent) : $('body');
	this.id = params.id;
	this.type = params.type;
	this.target = $(params.target);
	this.direction = params.direction;
	this.css = params.css;
	this.iconcss = params.iconcss;

	var me = this;

	BaseControl.extend(this);

	$(this._element).hover(function () {
		$(me.target).addClass('ui-hover-target-hover');
		$(me._element).addClass('ui-hoverarea-item-hover');
	}, function () {
		$(me.target).removeClass('ui-hover-target-hover');
		$(me._element).removeClass('ui-hoverarea-item-hover');
	});

	this.itemhover = new CoreLibrary.EventSource('itemhover');
	this.itemclick = new CoreLibrary.EventSource('itemclick');

	$(this._element).hover(function(e) {
		me.itemhover.fire(me,e);
	});
	$(this._element).click(function(e) {
		me.itemclick.fire(me,e);
	});

	this.update();
	
}

HoverItem.prototype = {

	_absoluteParent: function (source, parent) {
		var src = $(source).get(0);
        var mainparent = parent ? $(parent).get(0) : $(document).get(0);

        if (src.offsetParent) {
            var left = src.offsetLeft;
            var top = src.offsetTop;
            if (src.offsetParent != mainparent) {
                var parentPos = this._absoluteParent(src.offsetParent, parent);
                if (parentPos) {
                    left = left + parentPos.left;
                    top = top + parentPos.top;
                }
            }
            return { 'left': left, 'top': top };
        }
	},

	/** 
	Re-evaluates the layout of the hover item
	@method update
	**/
	update: function () {
		if(!this.direction || this.direction === 'left') {
			this._element.addClass('ui-hoverarea-direction-horizontal');
		} else if (this.direction === 'right') {
			this._element.addClass('ui-hoverarea-direction-horizontal');
			this._element.find('.ui-hoverarea-icon').appendTo(this._element);
		}
		else if (this.direction === 'top') {
			this._element.addClass('ui-hoverarea-direction-vertical');
		} else {
			this._element.addClass('ui-hoverarea-direction-vertical');
			this._element.find('.ui-hoverarea-icon').appendTo(this._element);
		}

		var position = this._absoluteParent(this.target, this.parent);
		var directionElement = this._element.find('.ui-hoverarea-direction');
		var width = this._element.width();
		var height = this._element.height();
		var targetWidth = this.target.width();
		var targetHeight = this.target.height();
		if(!this.direction || this.direction === 'left') {
			this._element.css('left', position.left - width);
			this._element.css('top', position.top + (targetHeight/2));
		} else if (this.direction === 'right') {
			this._element.css('left', position.left + targetWidth);
			this._element.css('top', position.top + (targetHeight/2));
		}
		else if (this.direction === 'top') {
			this._element.css('top', position.top - height);
			this._element.css('left', position.left + (targetWidth/2));
		} else {
			this._element.css('top', position.top + targetHeight);
			this._element.css('left', position.left + (targetWidth/2));
		}
	},

	onRemove: function () {
		$(this._element).unbind('click').unbind('hover');
		this.itemhover.unbind();
		this.itemclick.unbind();
	}
};


/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.HoverItemParams} params Feedback control parameters 
@return {Object} jQuery object of Feedback control.
**/
HoverItem.prototype._createControl = function (params) {
    var id = params.id;
    var css = params.css || '';
    
    var direction, iconcss;
    iconcss= params.iconcss || '';

    var options = {
        id: id,
        css: css,
        iconcss: iconcss,
        direction: direction
    };

    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['hoverarea'](options));
    return parent.find('#' + id);
};


Controls.HoverArea = HoverArea;
Controls.HoverItem = HoverItem;/**   
ImageEdit control parameters.
@class ImageEditParams
@since 1.3.0
@see Controls.ImageEdit
@unlisted
**/
var ImageEditParams = function() {

    /**
    An id of ImageEdit control.
    @property {String} id
    @default 'imageEdit'
    **/
    this.id = undefined;

    /**
    Parent of ImageEdit control. Pass valid id or jQuery object of parent.
    If parent is not set then ImageEdit control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Image data as base64 stream.
    @property {string} image
    **/
    this.image = undefined;

    /**
    An optional image mask.
    @property {CoreLibrary.Sketch2D} mask
    @optional
    **/
    this.mask = undefined;

    /**
    Width of image edit control.
    @property {Number} width
    @required
    **/
    this.width = undefined;

    /**
    Height of image edit control.
    @property {Number} height
    @required
    **/
    this.height = undefined;

};

/**
An HTML ImageEdit control.

@class ImageEdit
@param {Controls.ImageEditParams} params ImageEdit control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.3.0
@constructor
@example
function CreateImageEdit() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var imageEdit = new controls.ImageEdit({
                id: 'imageEditControl',
                parent: 'imageEditParent',
                width: 500,
                height: 500,
                mask: {objSketch2D}
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var ImageEdit = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    this._width = params.width;
    this._height = params.height;
    this._matrix2d = new CoreLibrary.Matrix2D();

    //center of user control
    this._cX = this._width/2;
    this._cY = this._height/2;

    this._image = params.image ? params.image : undefined;
    if(params.mask) {
        this._maskSketch = params.mask;
    }
    if(params.transformMatrix) {
        this._setTransformMatrix(params.transformMatrix);
    }
    else{
        this._currentScale = 1;
        this._currentAngle = 0;
    }
    this._scaleDelta = 0.01;

    // Create a canvas that we will be used as a mask
    this._maskCanvas = document.createElement('canvas');
    // Ensure same dimensions
    this._maskCanvas.width = this._width;
    this._maskCanvas.height = this._height;
    this._maskCtx = this._maskCanvas.getContext('2d');

    /**
    Image data in base64 stream.
    @property {String} image
    @public
    **/
    Object.defineProperty(this, "image",{
        get : function () {
            this._getDrawing();
            return this._image;
        },
        set : function (image) {
            this._image = image;
            this._initializeDraw();
        },
        enumerable : true
    });

    /**
    Transformation matrix to modify an image accordingly.
    @property {CoreLibrary.Matrix2D} transformMatrix
    @public
    **/
    Object.defineProperty(this, "transformMatrix",{
        get : function () {
            return this._transformMatrix;
        },
        set : function (value) {
            this._setTransformMatrix(value);
            this._drawFromMatrix();
        },
        enumerable : true
    });

    /**
    Event will be fired when file selection get changed.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

    BaseControl.extend(this);
    
};

/** 
Set the new transform matrix.
@private
@method _setTransformMatrix
@param {Matrix2D} trans 
**/
ImageEdit.prototype._setTransformMatrix = function (trans) {
    if (trans instanceof CoreLibrary.Matrix2D) {
        trans = trans.clone();
    } else if (Array.isArray(trans) && trans.length === 9) {
        trans = new CoreLibrary.Matrix2D(trans);
    } else {
        Plugin.panic(ERROR_ARGUMENTS_MESSAGE);
    }

    this._transformMatrix = trans;

    // extract the scale and angle from matrix
    this._currentScale = Math.sqrt(trans.elements[0]*trans.elements[0] + trans.elements[3]*trans.elements[3]);
    this._currentAngle = Math.atan2(-trans.elements[3], trans.elements[0]) * 180 /  Math.PI;

    // Update UI controls
    if(this._scale){
        this._scale.value = this._currentScale;
    }
    if(this._rorate){
        this._rorate.value = this._currentAngle;
    }
};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.ImageEditParams} params ImageEdit control parameters 
@return {Object} jQuery object of ImageEdit control.
**/
ImageEdit.prototype._createControl = function (params) {
    var id = params.id || 'imageEdit';
    var css = params.css || '';
    
    var options = {
        'id': id,
        'css': css,
        'width': params.width,
        'height': params.height
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['imageedit'](options));
    return parent.find('#' + id);
};

/** 
Initialize ImageEdit
@private
@method onInitialize
**/
ImageEdit.prototype.onInitialize = function () {
    var me = this;
    this._canvas = this._element.find('#' + this.id + 'canvas');
    this._ctx = this._canvas[0].getContext("2d");
    this._imageElement = this._element.find('#' + this.id + 'image');

    this._rotateLeft = this._element.find('#' + this.id + 'rotateLeft');
    this._rotateRight = this._element.find('#' + this.id + 'rotateRight');
    this._close = this._element.find('#' + this.id + 'close');
    
    this._scale = new Slider({
        id:'zoomSlider',
        parent: this.id + 'zoomContainer',
        showText: false,
        steps: this._scaleDelta,
        min:0.5,
        max:2,
        orientation: SliderOrientationEnum.Vertical
    });
    this._scale.value = this._currentScale;
    
    this._rorate = new Slider({
        id:'rotateSlider',
        parent: this.id + 'rotateContainer',
        showText: false,
        steps: 1,
        min:-180,
        max:180
    });
    this._rorate.value = this._currentAngle;

    this._rotateLeft.click(function() {
        var newAngle=me._currentAngle;
        if(me._currentAngle == -180 || (me._currentAngle <= 180 && me._currentAngle > 90)) {
            newAngle = 90;
        } else if (me._currentAngle <= 90 && me._currentAngle > 0) {
            newAngle= 0;
        } else if (me._currentAngle <= 0 && me._currentAngle > -90) {
            newAngle = -90;
        } else if (me._currentAngle <= -90 && me._currentAngle > -180) {
            newAngle = -180;
        }
        var deta = newAngle - me._currentAngle;
        me._rorate.value = me._currentAngle = newAngle;
        me._appendRotate (deta);
    });

    this._rotateRight.click(function() {
        var newAngle=me._currentAngle;
        if(me._currentAngle == 180 || (me._currentAngle >= -180 && me._currentAngle < -90)) {
            newAngle = -90;
        } else if (me._currentAngle >= -90 && me._currentAngle < 0) {
            newAngle = 0;
        } else if (me._currentAngle >= 0 && me._currentAngle < 90) {
            newAngle = 90;
        } else if (me._currentAngle >= 90 && me._currentAngle < 180) {
            newAngle = 180;
        }
        var deta = newAngle - me._currentAngle;
        me._rorate.value = me._currentAngle = newAngle;
        me._appendRotate (deta);
    });

    this._close.click(function(){
        me.change.fire();
    });

    this._bindEvents();
    this._initializeDraw();
};

/** 
Resize image edit control.
@method resize
**/
ImageEdit.prototype.resize = function (width, height) {
    if(!width || !height) return;
    this._width = width;
    this._height = height;

    $(this._element).width(this._width);
    $(this._element).height(this._height);
    $(this._maskCanvas).attr('width', this._width);
    $(this._maskCanvas).attr('height', this._height);
    $(this._canvas).attr('width', this._width);
    $(this._canvas).attr('height', this._height);
    
    //center of user control
    this._cX = this._width/2;
    this._cY = this._height/2;

    this._initializeDraw(true);
};

/** 
Initialize and reset internal params before drawing.
@private
@method _initializeDraw
**/
ImageEdit.prototype._initializeDraw = function (onresize) {
    if(this._maskSketch) { //draw mask
        var bounds = this._maskSketch.bounds();
        if(bounds) {
            var min = bounds.min;
            var max = bounds.max;

            this._maskWidth = bounds.length();
            this._maskHeight = bounds.width();

            this._sX = min.x + (max.x - min.x) / 2; // Example position on Sketch (X)
            this._sY = min.y + (max.y - min.y) / 2; // Example position on Sketch (Y)

            this._drawMask();
        }
    }
    if(this._image) {
        var me = this;
        if(this._imageElement[0].src == this._image) { this._imageElement[0].src = ''; }
        //image loading is async so capture width & height and in loaded callback check for control size and decide need to draw image or not
        //this also filters out intermediate drawing while resizing a control
        var cW = this._width;
        var cH = this._height;
        
        this._imageElement[0].src = this._image;
        this._imageElement[0].onload = function(e) {
            if(cW !== me._width || cH !== me._height) return;

            me._imageWidth = me._imageElement[0].width;
            me._imageHeight = me._imageElement[0].height;

            var w = me._maskWidth || me._width;
            var h = me._maskHeight || me._height;

            // check for image height/width and fit in mask.
            var ratio = Math.min(w/me._imageWidth, h/me._imageHeight);
            me._imageWidth = me._imageElement[0].width = me._imageWidth * ratio;
            me._imageHeight = me._imageElement[0].height = me._imageHeight * ratio;
            
            if(!me._transformMatrix){
                me._transformMatrix = new CoreLibrary.Matrix2D();
                me._transformMatrix.translation(me._width/2, me._height/2);
            }
            me._drawFromMatrix();
            if(!onresize) me.change.fire();
        };
    }
};

ImageEdit.prototype._appendScale = function (deta) {
    // Scale at center point
    var matrixScale = new CoreLibrary.Matrix2D();
    matrixScale.scaling(deta, deta);
    var tx = this._transformMatrix.elements[6];
    var ty = this._transformMatrix.elements[7];
    this._transformMatrix.elements[6] = 0;
    this._transformMatrix.elements[7] = 0;
    this._transformMatrix.transform(matrixScale);
    this._transformMatrix.elements[6] = tx;
    this._transformMatrix.elements[7] = ty;

    this._drawFromMatrix();
};
ImageEdit.prototype._appendRotate = function (deta) {
    // Rotate around center point
    var matrixRotate = new CoreLibrary.Matrix2D();
    var radians = Math.PI * deta / 180;
    matrixRotate.rotation(radians);

    var tx = this._transformMatrix.elements[6];
    var ty = this._transformMatrix.elements[7];
    this._transformMatrix.elements[6] = 0;
    this._transformMatrix.elements[7] = 0;
    this._transformMatrix.transform(matrixRotate);
    this._transformMatrix.elements[6] = tx;
    this._transformMatrix.elements[7] = ty;

    this._drawFromMatrix();
};
ImageEdit.prototype._appendTranslate = function (detax, detay) {
    var matrixTranslate = new CoreLibrary.Matrix2D();
    matrixTranslate.translation(detax, detay);
    this._transformMatrix.transform(matrixTranslate);

    this._drawFromMatrix();
};
/** 
Bind events.
@private
@method _bindEvents
**/
ImageEdit.prototype._bindEvents = function () {
    var me = this;
    this._scale.change.bind(function() {
        me._appendScale (me._scale.value / me._currentScale);
        me._currentScale = me._scale.value;
    });
    this._rorate.change.bind(function() {
        var deta = me._rorate.value - me._currentAngle;

        me._currentAngle = me._rorate.value;
        me._appendRotate (deta);
    });
    
    this._canvas[0].onmousedown = function (e) {
        $('body').addClass('ui-image-edit-noselect');
        var pos = me._getMousePos.call(me, e);
        me._startX = pos.x;
        me._startY = pos.y;
        me._isDown = true;
    };
    this._canvas[0].onmousemove = function (e) {
        if (me._isDown === true) {
            var pos = me._getMousePos.call(me, e);
            var x = pos.x;
            var y = pos.y;
            
            var detax = (x - me._startX);
            var detay = (y - me._startY);
            me._appendTranslate(detax, detay);
            
            me._startX = x;
            me._startY = y;
        }
    };
    this._canvas[0].onmouseup = function (e) {
        $('body').removeClass('ui-image-edit-noselect');
        me._isDown = false;
    };

    this._canvas[0].onmouseout = function(e) {
        me._isDown = false;
    };
};

/** 
Draw canvas from transform matrix.
@private
@method _drawFromMatrix
**/
ImageEdit.prototype._drawFromMatrix = function () {
    this._clear();
    this._ctx.save();

    var arr = this._transformMatrix.elements;
    this._ctx.transform(arr[0], arr[1], arr[3], arr[4], arr[6], arr[7]);
    this._ctx.drawImage(this._imageElement[0], -this._imageWidth/2, -this._imageHeight/2, this._imageWidth, this._imageHeight);
    this._ctx.restore();

    if(this._maskSketch) {
        this._ctx.save();
        this._ctx.setTransform(1,0,0,1,0,0);
        
        this._ctx.drawImage(this._maskCanvas, 0, 0); //draw mask on main canvas
        this._ctx.restore();
    }

};

/** 
Get drawing data.
@private
@method _getDrawing
**/
ImageEdit.prototype._getDrawing = function () {
    var resultWidth = this._maskWidth?Math.min(this._maskWidth, this._width):this._width;
    var resultHeight = this._maskHeight?Math.min(this._maskHeight, this._height):this._height;
    
    // Create result canvas.
    if(!this._resultCanvas){
        this._resultCanvas = document.createElement('canvas');
    }
    this._resultCanvas.width = resultWidth;
    this._resultCanvas.height = resultHeight;

    var ctx = this._resultCanvas.getContext('2d');

    //clear
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,resultWidth,resultHeight);
    ctx.restore();

    var cX = resultWidth/2;
    var cY = resultHeight/2;
    var me = this;
    var sketch2DToResultView = function(sketch2DX, sketch2DY) {
        var userControlX = cX + ((sketch2DX - me._sX));
        var userControlY = cY - ((sketch2DY - me._sY));
        return new CoreLibrary.Point2D(userControlX, userControlY);
    };
    //mask
    if(this._maskSketch) {
        var pathLength = this._maskSketch.paths.length;
        
        //Draw polygons
        for (var i = 0; i < pathLength; i++) {
            var polygons = this._maskSketch.paths[i].toPolygons();
            var polygonLength = polygons.length;
            
            for (var j = 0; j < polygonLength; j++) {
                var points = polygons[j];
                var npts = points.length/2;
                
                ctx.beginPath();
                for (var k = 0; k < npts; k++) {
                    var point = sketch2DToResultView(points[k*2+0], points[k*2+1]);
                    if (k === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.closePath();
                ctx.clip(); //crop according to mask
            }
        }
    }
    
    //image 
    ctx.save();
    var t = new CoreLibrary.Matrix2D();
    t.translation((resultWidth-this._width)/2, (resultHeight-this._height)/2);
    var arr = this._transformMatrix.clone().transform(t).elements;
    ctx.transform(arr[0], arr[1], arr[3], arr[4], arr[6], arr[7]);
    ctx.drawImage(this._imageElement[0], -this._imageWidth/2, -this._imageHeight/2, this._imageWidth, this._imageHeight);
    ctx.restore();

    this._image = Utility.createObjectUrl(this._resultCanvas.toDataURL());
};

/** 
Draw mask.
@private
@method _drawMask
**/
ImageEdit.prototype._drawMask = function () {
    var pathLength = this._maskSketch.paths.length;
    //Draw polygons
    for (var i = 0; i < pathLength; i++) {
        var polygons = this._maskSketch.paths[i].toPolygons();
        var polygonLength = polygons.length;
        
        for (var j = 0; j < polygonLength; j++) {
            var points = polygons[j];
            var npts = points.length/2;
            
            this._maskCtx.beginPath();
            for (var k = 0; k < npts; k++) {
                var point = this._sketch2DToView(points[k*2+0], points[k*2+1]);
                if (k === 0) {
                    this._maskCtx.moveTo(point.x, point.y);
                } else {
                    this._maskCtx.lineTo(point.x, point.y);
                }
            }
    
            this._maskCtx.closePath();
            
            this._maskCtx.fillStyle = 'rgba(230, 230, 230, 0.6)';
            // Fill the mask
            this._maskCtx.rect(this._width, 0, -this._width, this._height);
            this._maskCtx.fill();
            
        }
    }
    
};

/** 
Convert sketch2d coordinates to view coordinates
@private
@method _sketch2DToView
@return {CoreLibrary.Point2D} view point is returned.
**/
ImageEdit.prototype._sketch2DToView = function(sketch2DX, sketch2DY) {
    var userControlX = this._cX + ((sketch2DX - this._sX));
    var userControlY = this._cY - ((sketch2DY - this._sY));
    return new CoreLibrary.Point2D(userControlX, userControlY);
};

/** 
Clear canvas.
@private
@method _clear
**/
ImageEdit.prototype._clear = function () {
    this._ctx.save();
    this._ctx.setTransform(1,0,0,1,0,0);
    this._ctx.clearRect(0,0,this._width,this._height);
    this._ctx.restore();
};

/** 
Get mouse position.
@private
@method _getMousePos
**/
ImageEdit.prototype._getMousePos = function (evt) {
    var rect = this._canvas[0].getBoundingClientRect();
    return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
    };
};

Controls.ImageEdit = ImageEdit;
/**   
ImageMap control parameters.
@class ImageMapParams
@since 1.1.0
@see Controls.ImageMap
@unlisted
**/
var ImageMapParams = function(){

    /**
    An id of ImageMap control.
    @property {String} id
    @default 'ImageMap'
    **/
    this.id = undefined;

    /**
    Parent of ImageMap control. Pass valid id or jQuery object of parent.
    If parent is not set then ImageMap control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Items to display. 
    @example
    [{
        'id': 'head',
        'value': 'FF0000',
        'imagesrc': ''
    },
    {
        'id': 'torso',
        'value': '00FF00',
        'imagesrc': ''
    },
    {
        'id': 'right-arm',
        'value': '0000FF',
        'imagesrc': ''
    }]
    @property {Array} items
    **/
    this.items = undefined;

    /**
    Image URL of the main image to be displayed as a map. This image will be shown when nothing is hovered/clicked
    @property {String} mainImage
    **/
    this.mainImage = undefined;

    /**
    Image URL of the map image which will be color coded for identification. Each area should be colored differently with the same color code provided in the value property 
    of the items in the items array.
    @property {String} mapImage
    **/
    this.mapImage = undefined;

    /**
    Control css.
    @property {String} css
    **/
    this.css = undefined;

};

/**
An ImageMap control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class ImageMap
@param {Controls.ImageMapParams} params ImageMap control parameters.
@namespace Controls
@extends Controls.BaseControl
@suppress blur, focus, keydown, keypress, keyup
@since 1.0.0
@constructor
@example
function CreateImageMap() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            
            var imageMapControl = new controls.ImageMap({
                id:'imageMapControl',
                parent: 'imageMapExample',
                items: items, //items
                mainImage: 'http://domain/mainimage.png', //items
                mapImage: 'http://domain/mapimage.png', //items
                css: 'controlcss' //external control css
            });

            imageMapControl.change.bind(function(e) {
                //imageMapControl.value
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var ImageMap = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    params.items ? this._items = params.items : [];
    this._mapimageurl = params.mapImage;

    var me = this;

    var getItemFromValue = function (value) {
        var len = me._items.length;
        for(var i=0;i<len;i++) {
            var item = me._items[i];
            if(item.value === value) {
                return item;
            }
        }
    };

    /**
    Selected value.
    @property {String} value
    @public
    **/
    Object.defineProperty(this, "value",{
        get : function () {
            return this._value;
        },
        set : function (value) {
            this._setValue(getItemFromValue(value));
        },
        enumerable : true
    });

    this._canvas = $(this._element).find('canvas')[0];

    /**
    Fires when an area is clicked on the ImageMap
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    Object.defineProperty(this, 'change', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: new CoreLibrary.EventSource('change')
    });

    /**
    Fires when an area is hovered on the ImageMap
    @event itemhover
    @since 1.3.0
    @public
    @type {CoreLibrary.EventSource}
    **/
    Object.defineProperty(this, 'itemhover', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: new CoreLibrary.EventSource('itemhover')
    });

    BaseControl.extend(this);

    var len = me._items.length;
    for(var i=0;i<len;i++) {
        var item = me._items[i];
        if(item.selected) {
            this.value = item.value;
            break;
        }
    }

};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.ImageMapParams} params ImageMap control parameters 
@return {Object} jQuery object of ImageMap control.
**/
ImageMap.prototype._createControl = function (params) {
    var id = params.id || 'ImageMap';
    var css = params.css || '';
    var items = params.items || [];
    var mainimage = params.mainImage || '';
    var mapimage = params.mapImage || '';
    var options = {
        'id': id,
        'css': css,
        mainimage: mainimage,
        mapimage: mapimage
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['imagemap'](options));
    return parent.find('#' + id);
};

/** 
Initialize ImageMap
@private
@method onInitialize
**/
ImageMap.prototype.onInitialize = function () {
    var me = this;
    var context = this._canvas.getContext('2d');
    var imageObj = new Image();
    imageObj.onload = function () {
        me._canvas.width = imageObj.width;
        me._canvas.height = imageObj.height;
        context.drawImage(imageObj,0,0);
    };
    imageObj.src = this._mapimageurl;

    var container = $(this._element).find('.ui-imagemap-container');
    $(container).bind('mousemove', function (event) {
        var x = event.offsetX;
        var y = event.offsetY;

        if(event.offsetX===undefined) {
            var offset = $(this).offset();
            x = event.pageX-offset.left;
            y = event.pageY-offset.top;
        }
        me._updateImage(x,y);

    });

    $(container).bind('mouseout', function (event) {
        me._updateImage(-1,-1);

    });

    $(container).bind('click', function () {
        if(me._hoveredValue) {
            me._setValue(me._hoveredItem, true);
        }
    });

    $(this._element).find('#' + this.id + '-main-image').css('visibility','visible');
};

/** 
Removes the current selection
@method clearSelection
**/
ImageMap.prototype.clearSelection = function () {
    var selected = $(this._element).find('.ui-imagemap-selected-item');
    selected.css('visibility','hidden').removeClass('ui-imagemap-selected-item');
    $(this._element).find('#' + this.id + '-main-image').css('visibility','visible');
    delete me._value;
    delete me._hoveredItem;
    delete me._hoveredValue;
};


/** 
Sets the correct value by setting the image corresponding to the input item value 
@private
@method _setValue
**/
ImageMap.prototype._setValue = function (item, raiseevent) {
   var activeelement = $(this._element).find('#' + this.id + '-active-image');
    if(item) {
        var oldValue = this._value;
        this._value = item.value;
        var activeurl = item.activesrc;
        activeelement.attr('src', activeurl);
        activeelement.css('visibility', 'visible');
        //$(this._element).find('#' + this.id + '-main-image').css('visibility','hidden'); 
        if(raiseevent) {
             this.change.fire({oldValue: oldValue, newValue: this._value, id: this.id});
        }
    }
};

/** 
Sets the correct image for the current cursor position
@private
@method _updateImage
**/
ImageMap.prototype._updateImage = function (x,y) {
    var hexstring = this._getColorByPoint(x,y);
    hexstring = hexstring.toLowerCase();
    var l = this._items.length;
    var match;
    var matchurl;
    var matchvalue;
    for(var i=0;i<l;i++) {
        var item = this._items[i];
        var itemcolorstring = item.value.toLowerCase();
        if(itemcolorstring === hexstring) {
            match = item;
            matchurl = item.imagesrc;
            matchvalue = item.value;
            break;
        }
    }

    var hoveredelement = $(this._element).find('#' + this.id + '-hover-image');
    if(match) {
        hoveredelement.css('visibility', 'visible');
        hoveredelement.attr('src',matchurl);
        var oldHoveredValue = this._hoveredValue;
        this._hoveredItem = match;
        this._hoveredValue = matchvalue;
        this.itemhover.fire({oldValue: oldHoveredValue, newValue: this._hoveredValue, id: this.id});
    }
    else {
        hoveredelement.css('visibility', 'hidden');
        $(this._element).removeClass('ui-imagemap-hover');
        this.itemhover.fire({oldValue: oldHoveredValue, newValue: undefined, id: this.id});
        delete this._hoveredItem;
        delete this._hoveredValue;
    }
};

/** 
Returns the colour on the colour map for a given point
@private
@method _getColorByPoint
**/
ImageMap.prototype._getColorByPoint = function (x,y) {
    var context = this._canvas.getContext('2d');
    var data = context.getImageData(x,y,1,1).data;
    var r=data[0];
    var g=data[1];
    var b=data[2];
    return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
};


Controls.ImageMap = ImageMap;

/**   
Itemslider item structure.
@class ItemsliderItem
@since 1.3.0
@see Controls.Itemslider
@unlisted
**/
var ItemsliderItem = function(){
    /**
    An id of item.
    @property {String} id
    **/
    this.id = undefined;

    /**
    Value of item.
    @property {String} value
    **/
    this.value = undefined;

    /**
    An url pointing to item image or an object containing image urls for different states.
    @property {String|CoreLibrary.ListImageItem} imagesrc
    **/
    this.imagesrc = undefined;

    /**
    An external css class to apply.
    @property {String} cssclass
    @since 1.4.0
    **/
    this.cssclass = undefined;

};

/**   
Itemslider control parameters.
@class ItemsliderParams
@since 1.0.0
@see Controls.Itemslider
@unlisted
**/
var ItemsliderParams = function() {

    /**
    An id of Itemslider control.
    @property {String} id
    @default 'Itemslider'
    **/
    this.id = undefined;

    /**
    Parent of Itemslider control. Pass valid id or jQuery object of parent.
    If parent is not set then Itemslider control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    An array of json object holding item information.
    @property {Array[Controls.ItemsliderItem]} items
    **/
    this.items = undefined;

    /**
    Items per slide. 
    @property {Number} itemsPerSlide
    @default 5
    **/
    this.itemsPerSlide = undefined;

    /**
    An extra item css. This could be a class name or a json object containing css properties.
    All the items will have this css.
    @property {String|Object} itemCss
    @example
    //css class name
    var params = {
        ...
        itemCss: 'cssClass'
    }

    //or css properties as json object
    var params = {
        ...
        itemCss: {
            'color': '#111111',
            'background-color': '#ffffff'
        }
    }
    **/
    this.itemCss = undefined;

    /**
    An extra control css.
    @property {String} css
    **/
    this.css = undefined;

};

/**
An HTML Itemslider control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Itemslider
@param {Controls.ItemsliderParams} params Itemslider control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.0.0
@constructor
@example
function CreateItemslider() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            
            var itemsliderControl = new controls.Itemslider({
                id:'itemsliderControl',
                parent: 'itemsliderExample',
                items: items, //items
                itemsPerSlide: 5,
                css: 'controlcss', //external control css
                itemCss: 'itemsliderItem' //external item css
            });

            itemsliderControl.change.bind(function(e) {
                //itemsliderControl.selectedValue
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Itemslider = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    params.items ? this._items = params.items : [];
    params.itemsPerSlide ? this._itemsPerSlide = params.itemsPerSlide : this._itemsPerSlide = 5;
    params.itemCss ? this._itemCss = params.itemCss : this._itemCss = 1;
    this._currentSlideIndex = 0;
    this._slides = [];
    this._hideNavigation = false;
    this._slideContainer = undefined;
    this._nextNavigator = undefined;
    this._previousNavigator = undefined;
    this._selectedValue = undefined;

    /**
    Selected value.
    @property {String} selectedValue
    @public
    **/
    Object.defineProperty(this, "selectedValue",{
        get : function () {
            return this._selectedValue;
        },
        set : function (value) {
            value = $.trim(value);
            this._selectItem(value);
        },
        enumerable : true
    });

    /**
    Slide index.
    @property {Number} slideIndex
    @public
    **/
    Object.defineProperty(this, "slideIndex",{
        get : function () {
            return this._currentSlideIndex;
        },
        set : function (index) {
            if(index >= this._slides.length) return;
            this._selectSlide(index);
        },
        enumerable : true
    });

    /**
    Hide navigation buttons.
    @property {Boolean} hideNavigation
    @public
    **/
    Object.defineProperty(this, "hideNavigation",{
        get : function () {
            return this._hideNavigation;
        },
        set : function (value) {
            this._hideNavigation = value;
            if(value) {
                this._nextNavigator.hide();
                this._previousNavigator.hide();
                this._slideContainer.addClass('ui-itemnavigation-hide').removeClass('ui-itemnavigation-show');
            } else {
                this._nextNavigator.show();
                this._previousNavigator.show();
                this._slideContainer.removeClass('ui-itemnavigation-hide').addClass('ui-itemnavigation-show');
            }
        },
        enumerable : true
    });

    /**
    Fires when Itemslider value changes.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

    /**
    Fires when user navigate to next or previous slide. 
    In event callback slide navigation direction will be returned. 1 represents forward navigation and 0 represents backwards navigation.
    @event slidechange
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.slidechange = new CoreLibrary.EventSource('slidechange');

    BaseControl.extend(this);

};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.ItemsliderParams} params Itemslider control parameters 
@return {Object} jQuery object of Itemslider control.
**/
Itemslider.prototype._createControl = function (params) {
    var id = params.id || 'Itemslider';
    var css = params.css || '';
    var options = {
        'id': id,
        'css': css
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['itemslider'](options));
    return parent.find('#' + id);
};

/** 
Initialize Itemslider
@private
@method onInitialize
**/
Itemslider.prototype.onInitialize = function () {
    var me = this;
    this._slideContainer = this._element.find('.ui-itemslidercontainer');

    if(this._items.length > 0) {
        var i,j,slidepages = [];
        for (i=0,j=this._items.length; i<j; i+=this._itemsPerSlide) {
            slidepages.push(this._items.slice(i,i+this._itemsPerSlide));
        }
        for (var i = 0; i < slidepages.length; i++) {
            var slide = $('<div id="'+ i +'"></div>').addClass('ui-slide');
            if(i!=0) slide.hide(); //hide other slides
            for (var j = 0; j < slidepages[i].length; j++) {
                var item = $('<div id=' + slidepages[i][j].id + '></div>').addClass('ui-slide-item').attr('value', slidepages[i][j].value);
                if(typeof this._itemCss === 'string') {
                    item.addClass(this._itemCss);
                } else if(!this._itemCss && typeof this._itemCss == 'object') {
                    item.css(this._itemCss);
                }
                if(undefined !== slidepages[i][j].cssclass && '' !== slidepages[i][j].cssclass) {
                    item.addClass(slidepages[i][j].cssclass);
                }
                if(slidepages[i][j].imagesrc) {
                    if(typeof slidepages[i][j].imagesrc === 'string') {
                        item.css({
                            'background-image': 'url(' + slidepages[i][j].imagesrc + ')',
                            'background-repeat': 'no-repeat',
                            'background-size': 'contain'
                        });
                    } else {
                        item.data('imagesrc', slidepages[i][j].imagesrc);
                        item.css({
                            'background-image': 'url(' + slidepages[i][j].imagesrc.normal + ')',
                            'background-repeat': 'no-repeat',
                            'background-size': 'contain'
                        });
                        if(slidepages[i][j].imagesrc.active && slidepages[i][j].imagesrc.hover) {
                            item.hover(function() {
                                if($(this).data('imagesrc').hover) $(this).css('background-image', 'url(' + $(this).data('imagesrc').hover + ')');
                            });
                            item.mouseout(function() {
                                if(me._selectedValue != undefined && $(this).attr('value') == me._selectedValue) {
                                    $(this).css('background-image', 'url(' + $(this).data('imagesrc').active + ')');
                                } else {
                                    $(this).css('background-image', 'url(' + $(this).data('imagesrc').normal + ')');
                                }
                            });
                        }
                    }
                }
                slide.append(item);
                item.click(function(e) {
                    me._itemClick(this);
                });
            };
            this._slideContainer.append(slide);
            this._slides.push(slide);
        };

    }
    
    this._nextNavigator = this._element.find('#nextSlide');
    this._previousNavigator = this._element.find('#previousSlide');
    this._nextNavigator.click(function() { me._navigatorClick(1); });
    this._previousNavigator.click(function() { me._navigatorClick(0); }).addClass('ui-itemnavigationdisable');

    if(this._items.length <= this._itemsPerSlide) this.hideNavigation = true;

};

/** 
Handle item click.
@method _itemClick
@param {Object} item Slide item object
@private
**/
Itemslider.prototype._itemClick = function(item) {
    //remove previous selection
    for (var i = 0; i < this._slides.length; i++) {
        var prevItem = this._slides[i].find('.ui-slide-item[value="'+ this._selectedValue +'"]');
        if(prevItem.size() === 1) {
            prevItem.removeClass('ui-slide-itemselected');
            if($(prevItem).data('imagesrc')) {
                $(prevItem).css('background-image', 'url(' + $(prevItem).data('imagesrc').normal + ')');
            }
        }
    }

    $(item).addClass('ui-slide-itemselected');
    if($(item).data('imagesrc')) {
        $(item).css('background-image', 'url(' + $(item).data('imagesrc').active + ')');
    }
    var value = $(item).attr('value');
    this._selectedValue = value;
    this.change.fire(value);
};

/** 
Select slide by value.
@method _selectItem
@param {String} value Slide value.
@private
**/
Itemslider.prototype._selectItem = function(value) {
    for (var i = 0; i < this._slides.length; i++) {
        var item = this._slides[i].find('.ui-slide-item[value="' + value + '"]');
        if(item.size() === 1) {
            item.addClass('ui-slide-itemselected');
            if($(item).data('imagesrc')) {
                $(item).css('background-image', 'url(' + $(item).data('imagesrc').active + ')');
            }
            this._selectedValue = $(item).attr('value');
            this._slides[i].find('.ui-slide-item[value!="' + value + '"]').removeClass('ui-slide-itemselected');
            this._selectSlide(i);
        }
        else {
            this._slides[i].find('.ui-slide-item').removeClass('ui-slide-itemselected');
        }
    }
    this.change.fire(value);
};

/** 
Select slide by index. Index is a zero based index.
@method _selectSlide
@param {Number} index Slide index.
@private
**/
Itemslider.prototype._selectSlide = function(index) {
    this._nextNavigator.removeClass('ui-itemnavigationdisable');
    this._previousNavigator.removeClass('ui-itemnavigationdisable');
    for (var i = 0; i < this._slides.length; i++) {
        if(i === index) {
            this._slides[i].show();
            if(index === 0) { //first slide
                this._previousNavigator.addClass('ui-itemnavigationdisable');
            } else if(index === (this._slides.length-1)) { //last slide
                this._nextNavigator.addClass('ui-itemnavigationdisable');
            }
            index = i;
        } else {
            this._slides[i].hide();
        }
    }
    if(index < this._currentSlideIndex) {
        this._currentSlideIndex = index;
        this.slidechange.fire(0);
    } else {
        this._currentSlideIndex = index;
        this.slidechange.fire(1);
    }

};

/** 
Handle navigation click event.
@method _navigatorClick
@private
@param {Boolean} navigation Slide navigation direction. 1 for right, 0 for left.
**/
Itemslider.prototype._navigatorClick = function(navigation) {
    for (var i = 0; i < this._slides.length; i++) { //hide all slides
        this._slides[i].hide();
    };
    this._nextNavigator.removeClass('ui-itemnavigationdisable');
    this._previousNavigator.removeClass('ui-itemnavigationdisable');
    if (navigation === 0) { //previous
        this._currentSlideIndex--;
        if (this._currentSlideIndex > 0) {
            this._slides[this._currentSlideIndex].show();
        }
        else {
            this._slides[0].show();
            this._currentSlideIndex = 0;
            this._previousNavigator.addClass('ui-itemnavigationdisable');
        }
        this.slidechange.fire(0);
    } else if (navigation === 1) { //next
        this._currentSlideIndex++;
        if (this._currentSlideIndex < this._slides.length) {
            this._slides[this._currentSlideIndex].show();
            if(this._currentSlideIndex === this._slides.length-1) this._nextNavigator.addClass('ui-itemnavigationdisable');
        }
        else {
            this._slides[this._slides.length-1].show();
            this._currentSlideIndex = this._slides.length-1;
            this._nextNavigator.addClass('ui-itemnavigationdisable');
        }
        this.slidechange.fire(1);
    }

};

/** 
Bind a Itemslider control to specific dom element 
@method bind
@public
@param {Object} Itemslider A DOM or jQuery object to which you want to bind this Itemslider object. 
@return {Controls.Itemslider}
**/
Itemslider.bind = function (Itemslider) {
	return new Itemslider(Itemslider);
};

Controls.Itemslider = Itemslider;


/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
This is an internal class that hold the implementation for managing Group and Control Handlers used by the Layout Manager
@private
@class _Handlers
**/
var _Handlers = function () {

    /**
    Key-Value pair of the Group Handlers attached to the instance
    @private 
    @property _groupHandlers
    **/
    this._groupHandlers = {};

    /**
    Key-Value pair of the Group Item Handlers attached to the instance
    @private 
    @property _groupItemHandlers
    **/
    this._groupItemHandlers = {};
};

_Handlers.prototype = {

    /**
    Adds a Handler of a type (group/control) to its respective collection and stores it against its id. The sealed argument determines if another handler by the same id can override this handler.
    @private       
    @method _addHandler
    @param {String} id Unique id of the handler. The handler will be used based on the id matching the corresponding type in the configuration.
    @param {Controls.IGroupHandler|Controls.IGroupItemHandler} handler The handler implementing either the IGroupHandler or IGroupItemHandler class
    @param {Boolean} sealed This argument determines if the handler can be overriden. The default value is false.
    @param {type} type Internal type of the handler (Group/Control)
    **/
    _addHandler : function (id, handler, sealed, type) {
        var handlers;
        if(type === 'group') {
            handlers = this._groupHandlers;
        } else {
            handlers = this._groupItemHandlers;
        }
        if(handlers[id] === undefined || handlers[id].sealed === undefined) {
            handlers[id] = handler;
            if(sealed) {
                handlers[id].sealed = true;
            }
        }
    },

    /**
    Adds a Group Handler
    @private       
    @method _addGroupHandler
    @param {String} id Unique id of the handler. The handler will be used based on the id matching the corresponding type in the configuration.
    @param {IGroupHandler} handler The handler implementing the IGroupHandler class
    @param {Boolean} [sealed=false] This argument determines if the handler can be overriden.
    **/
    _addGroupHandler: function (id, handlers, sealed) {
        this._addHandler(id,handlers,sealed,'group');
    },

    /**
    Adds a Group Item Handler
    @private       
    @method _addGroupItemHandler
    @param {String} id Unique id of the handler. The handler will be used based on the id matching the corresponding type in the configuration.
    @param {IGroupItemHandler} handler The handler implementing the IGroupItemHandler class
    @param {Boolean} [sealed=false] This argument determines if the handler can be overriden.
    **/
    _addGroupItemHandler: function (id, handlers, sealed) {
        this._addHandler(id,handlers,sealed,'control');
    }
};


/**   
Singleton of the LayoutHandlers class that allows adding/replacing Group Handlers and Control Handlers as well as accessing them by id.
This singleton is used by the LayoutManager to create the Group and Control elements based on the corresponding Handlers. 
Clients can define their own types and write their corresponding handlers and add them.
@class LayoutHandlers
@static
@namespace Controls
@since 1.1.0
@see Controls.LayoutManager
@example
function addNewGroupHandler() {

    // This will allow you to extend the layout configuration by using the newly defined 'new-group-type' type. 
    // This handler is sealed so it can not be changed.
    LayoutHandlers.addGroupHandler('new-group-type',object-of-Handler, true); 

}
**/
var LayoutHandlers = (function () {

    var handlerinstance = new _Handlers();

    return {
        /**
        Returns the current collection of Group Handlers
        @method group
        @static
        @return {Array[Controls.IGroupHandler]} Collection of GroupHandlers.
        @since 1.1.0
        **/
        group : function () { return $.extend({}, handlerinstance._groupHandlers); },

        /**
        Returns the current collection of Group Item Handlers
        @method groupItem
        @static
        @return {Array[Controls.IGroupItemHandler]} Collection of ControlHandlers.
        @since 1.1.0
        **/
        groupItem : function () { return $.extend( {}, handlerinstance._groupItemHandlers);},

        /**
        Adds a Group Handler
        @method addGroupHandler
        @static
        @param {String} id Unique id of the handler. The handler will be used based on the id matching the corresponding type in the configuration.
        @param {Controls.IGroupHandler} handler The handler implementing the IGroupHandler class
        @param {Boolean} [sealed=false] This argument determines if the handler can be overriden.
        **/
        addGroupHandler : function (id, handler, sealed) {
            handlerinstance._addGroupHandler(id,handler, sealed);
        },

        /**
        Adds a Group Item Handler
        @method addGroupItemHandler
        @static
        @param {String} id Unique id of the handler. The handler will be used based on the id matching the corresponding type in the configuration.
        @param {Controls.IGroupItemHandler} handler The handler implementing the IGroupItemHandler class
        @param {Boolean} [sealed=false] This argument determines if the handler can be overriden.
        **/
        addGroupItemHandler : function (id, handler, sealed) {
            handlerinstance._addGroupItemHandler(id,handler, sealed);
        }
    };
})();

/**   
LayoutManager control parameters.
@class LayoutManagerParams
@namespace Controls
@since 1.1.0
@see Controls.LayoutManager
@unlisted
**/
var LayoutManagerParams = function(){

    /**
    Id of the layout manager control.
    @property {String} id
    @default 'layoutmanager'
    @required
    **/
    this.id = undefined;

    /**
    Parent of the layout manager control. Requires valid id or jQuery object of parent.
    If parent is not set then the LayoutManager control will be
     appended to the body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;


    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

};



/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
This is an internal class that hold the implementation for the Layout Manager
@private
@class _LayoutManager
@param {LayoutManagerParams} params The LayoutManagerParams used to create the object
@param {CoreLibrary.ShapeGeneratorConfigurationJSON} layoutconfiguration 
**/
var _LayoutManager = function (params, layoutconfiguration) {

    this.id = params.id;
    this.parent = params.parent;
    var width = params.width;
    var height = params.height;
    
    var css = params.css || '';

    //TODO: I'm not sure if this panel should be placed in. Lets see.
    this.content = new Controls.Panel({id: this.id, parent: this.parent, css: 'ui-layout-manager ' + css, suppressHeader: true});
    if(width) this.content._element.css('width',width);
    if(height) this.content._element.css('height',height);

    var me=this;
    $(window).resize(function () {
        me.content.resize.fire();
    });

    this.containers = {};
};

_LayoutManager.prototype = {

    _createGroupItem: function (param) {
        var controlHandlers = LayoutHandlers.groupItem();

        var type = param.type;
        var handler;
     
        if(type !== undefined) {
            handler = controlHandlers[type];
        }
        else {
            console.log('A Control group requires a type');
        }
        return handler;
    },

    _createControlGroup: function (param) {
        var groupHandlers = LayoutHandlers.group();

        var type = param.type;
        var handler;
         if(type !== undefined) {
            handler = groupHandlers[type];
        }
        else {
            handler = groupHandlers['default'];
        }

        return handler;
    }
};



/**
Creates a LayoutManager which is responsible for creating and managing the layout of the Parameter Panel and its controls.
For an interactive demonstration please see: {Interactive Control Demos}.

@class LayoutManager
@namespace Controls
@since 1.1.0
@constructor
@example
function CreateLayoutManager() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var layoutmanager = new controls.LayoutManager({
                id:'layoutManagerControl'
            }, configuration);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
@param {Controls.LayoutManagerParams} params The LayoutManagerParams used to create the object
@param {CoreLibrary.ShapeGeneratorConfigurationJSON} layoutconfiguration The layout configuration defined by the Shape Generator
@see Controls.LayoutHandlers
@see Controls.GroupControlHandler
@see Controls.ParameterControlHandler
@see Controls.LabelControlHandler
@see Controls.RandomizerControlHandler
@see Controls.TabGroupHandler
@see Controls.MapGroupHandler
@see Controls.ChoiceGroupHandler
@see Controls.ViewGroupHandler
**/
var LayoutManager = function (params,layoutconfiguration) {

    /**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @private 
    @property {_LayoutManager} _impl
    **/
    Object.defineProperty(this, '_impl', {
        writeable: false,
        enumerable: false,
        configurable: false,
        value: new _LayoutManager(params,layoutconfiguration)
    });

    var me=this;

   
    /**
    Content area of the layout manager where the controls/layout is created.
    @property {HTMLElement} contentArea
    @public
    **/
    Object.defineProperty(this, "contentArea",{
        get : function () {
            return me._impl.content.contentArea;
        },
        enumerable : true,
        writeable: false
    });

    var info = layoutconfiguration;

    this.createControlGroup({
    id : this._impl.id +'-child',
        parent : this._impl.content,
    config : info
    });

    this.updateDockPanels();
};

LayoutManager.prototype = {
    /**
    Uses a Control Handler to perform the task defined within that Handler.
    @method createGroupItem
    @param {Object} params Parameter JSON 
        @param {String} params.id Id of the element. This needs to be unique for each element.
        @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
        @param {CoreLibrary.LayoutGroupItemJSON} params.config The underlying config part which is required to create the GroupItemHandler.
    @since 1.1.0
    **/
    createGroupItem : function (param) {
        var handler = this._impl._createGroupItem(param.config);
        handler.create(param,this);
    },
    
    /**
    Uses a Group Handler to perform the task defined within that Handler.
    @method createControlGroup
    @param {Object} params Parameter JSON 
        @param {String} params.id Id of the element. This needs to be unique for each element.
        @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
        @param {CoreLibrary.LayoutGroupJSON} params.config The underlying config part which is required to create the GroupHandler.
    @since 1.1.0
    **/
    createControlGroup : function (param) {
        var handler = this._impl._createControlGroup(param.config);
        handler.create(param,this);
    },

    /**
    Sets a control that can be accessed by its type or id using {Controls.LayoutManager#findContainers}
    @method setContainer
    @param {CoreLibrary.LayoutGroupItemJSON|CoreLibrary.LayoutGroupJSON} params The config of the item setting the container.
    @param {Object} control The control corresponding to the id.
    @since 1.1.0
    **/
    setContainer : function (params, control) {
        var property = {control: control, configuration: params};
        var type = params.type;
        if(params.id) {
            property.id = params.id;
        }
        this._impl.containers[type] = this._impl.containers[type] || [];
        this._impl.containers[type].push(property);
    },

    /**
    Removes entries from the container based on the input arguments.
    @method removeContainer
    @param {CoreLibrary.LayoutGroupItemJSON|CoreLibrary.LayoutGroupJSON} params The config of the item set in the container.
    @since 1.5.0
    **/
    removeContainer : function (params) {
        var type = params.type;
        var id = params.id;
        var collection = this._impl.containers[type];
        if(collection) {
            if(id !== undefined) {
                for(var i=0,len = collection.length;i<len;i++) {
                    if(collection[i].id === id) {
                        collection.splice(i,1);
                        break;
                    }
                }
            } else {
                delete this._impl.containers[type];
            }

        }
    },
    
    /**
    Updates the docking panels within the given panel
    @method updateDockPanels
    @param {Controls.Panel} [panel] The Panel control corresponding to the parameter. If an argument is not passed, all the dock panels will be refreshed.
    @since 1.1.0
    **/
    updateDockPanels: function (panel) {
        if(this._impl.content) {
            this._impl.content.resize.fire();
        }
    },

    /**
    Finds the container(s) for a particular item based on some information provided
    @method findContainers
    @param {Object} criteria A set of search critera to use 
      @param {String} criteria.type Constrains the results to containers where the string provided matches the {CoreLibrary.LayoutGroupItemJSON#type}.
      @param {String} [criteria.id] Constrains the results to containers where the string provided matches the {CoreLibrary.LayoutGroupItemJSON#id}.
    @return {Array[Object]} result
        @return {String} result.id Id of the layout item if defined.
        @return {Object} result.control A Control set using the {Controls.LayoutManager#setContainer} method.
        @return {CoreLibrary.ShapeGeneratorConfigurationJSON} result.configuration The configuration pertaining to the selected container.
    @since 1.2.0
    **/
    findContainers: function (criteria) {
        if(!criteria || !criteria.type) console.error('A valid critera/type is required');
        var results = [];
        var firstResults = this._impl.containers[criteria.type];
        var idfilter = criteria.id;
        if(firstResults) {
            var len = firstResults.length;
            for(var i=0;i<len;i++) {
                var item = firstResults[i];
                if(idfilter) {
                    if(item.id === idfilter) {
                        results.push({id: item.id, control: item.control, configuration: item.configuration});
                    }
                }
                else {
                    results.push({id: item.id, control: item.control, configuration: item.configuration});
                }
            }
        }
        return results;
    }
};

/**
Layout Dock Enum.
@class LayoutDockEnum
@namespace Controls
@since 1.1.0
@see Controls.LayoutManager
@unlisted
**/
var LayoutDockEnum = {

    Left: 'left',
    Right: 'right',
    Top: 'top',
    Bottom: 'bottom',
    Fill: 'fill'
};


/**
An Abstract class for creating control handlers. All Control Handlers must extend this class.
@class IGroupItemHandler
@namespace Controls
@since 1.1.0
@constructor
**/
var IGroupItemHandler = function () {};

/**
Initializes the Control Handler by passing the corresponding parameter JSON. 
@method initialize
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupItemJSON} params.config The underlying config part which is required to create the GroupItemHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
@return {Object} result
    @return {String} result.id Unique Id of the Control Handler.
    @return {Controls.Panel} result.parent Parent panel of the control.
    @return {CoreLibrary.LayoutGroupItemJSON} result.config The underlying config part which is required to create the GroupItemHandler.
    @return {Controls.Panel} result.content Panel within which the control needs to be created.
**/
IGroupItemHandler.prototype.initialize = function (params, layoutmanager) {
    var config = params.config;
    config.separated = config.separated === false ? false : true;
    var css = config.separated === false ? '' : 'ui-horizontal-separator';
    var id = params.id + '-' + (config.id || 'groupitem');
    var parentid = id + '-parent';

    var content = new Controls.Panel({id: parentid, parent: params.parent.contentArea, css: 'ui-layoutmanager-group-item ' + css, suppressHeader: true});
    params.parent.resize.bind(function(content) { return function () {
        content.resize.fire();
    }; }(content));
    
    return {
        id : id,
        parent : params.parent,
        config : config,
        content: content
    };
};

/**
Static method that extends the Class with the IGroupItemHandler Interface to allow the Class to be used as a GroupItemHandler.
@method extend
@static
@since 1.1.0
@param {Object} control New Class
**/
IGroupItemHandler.extend = function (control) {
    $.extend(control,IGroupItemHandler.prototype);
};

/**
The ParameterControlHandler class is a default Control Handler that handles Controls with type = parameter. This also sets the container with the key as the parameter id.
@class ParameterControlHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IGroupItemHandler}
**/
var ParameterControlHandler = function () {
    IGroupItemHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupItemParameterJSON} params.config The underlying config part which is required to create the ParameterControlHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
**/
ParameterControlHandler.prototype.create =function (params, layoutmanager) {
    var thisObj = this.initialize(params,layoutmanager);
    var id = thisObj.id;
    thisObj.control =  new Controls.Panel({id: id, parent: thisObj.content.contentArea, css: 'ui-parameter-group-item'});
    thisObj.content.resize.bind(function(content) { return function () {
        content.resize.fire();
    }; }(thisObj.control));
    layoutmanager.setContainer(params.config, thisObj.control);
};

/**
The GroupControlHandler class is a default Control Handler that handles Controls with type = group. 
@class GroupControlHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IGroupItemHandler}
**/
var GroupControlHandler = function () {
    IGroupItemHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupItemGroupJSON} params.config The underlying config part which is required to create the GroupControlHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
**/
GroupControlHandler.prototype.create =function (params, layoutmanager) {
    //Set separated false by default for GroupController 
    if(params.config.separated === undefined) params.config.separated = false;
    
    var config = params.config;
    config.separated = config.separated === false ? false : true;
    var css = config.separated === false ? '' : 'ui-horizontal-separator';
    var id = params.id + '-' + (config.id || 'groupitem');

    var content = new Controls.Panel({id: id, parent: params.parent.contentArea, css: 'ui-layoutmanager-group-item ' + css, suppressHeader: true});
    params.parent.resize.bind(function(content) { return function () {
        content.resize.fire();
    }; }(content));

    var group = params.config.group;
    layoutmanager.createControlGroup({
        id : id + '-child',
        parent : content,
        config : group
    });
};

/**
The LabelControlHandler class is a default Control Handler that handles Controls with type = label. 
@class LabelControlHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IGroupItemHandler}
**/
var LabelControlHandler = function () {
    IGroupItemHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupItemLabelJSON} params.config The underlying config part which is required to create the LabelControlHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
**/
LabelControlHandler.prototype.create =function (params, layoutmanager) {
     //Set separated false by default for GroupController 
    if(params.config.separated === undefined) params.config.separated = false;
    
    var config = params.config;
    config.separated = config.separated === false ? false : true;
    var css = config.separated === false ? '' : 'ui-horizontal-separator';
    var id = params.id + '-' + (config.id || 'label-groupitem');

    var content = new Controls.Panel({id: id, parent: params.parent.contentArea, css: 'ui-layoutmanager-group-item ui-label-group-item ' + css, suppressHeader: true});
    params.parent.resize.bind(function(content) { return function () {
        content.resize.fire();
    }; }(content));

    var text = config.label.text;
    var textContent;
    content.addClass('ui-label-group-item');
    if(config.label.fontSize) {
        content.addClass('ui-label-fontsize-' + config.label.fontSize);
    }
    if(config.label.styleClass && config.label.styleClass !== '') {
        content.contentArea.addClass(config.label.styleClass);
    }
    if(config.label.iconStyleClass && config.label.iconStyleClass !== '') {
        var iconContent = new Controls.Panel({id: id + '-icon', parent: content.contentArea, css: 'ui-label-icon-item ' + config.label.iconStyleClass, suppressHeader: true});
        if(text !== '') {
            textContent = new Controls.Panel({id: id + '-text', parent: content.contentArea, css: 'ui-label-text-item', suppressHeader: true});
            textContent.contentArea.text(text);
        }
    } else {
        content.contentArea.text(text);
    }

    //TODO: Think of some better way to handle text:
    content.text = function (text) {
        if(textContent) {
            textContent.contentArea.text(text);
        } else {
            content.contentArea.text(text);
        }
    };

    layoutmanager.setContainer(params.config, content);
};

/**
The RandomizerControlHandler class is a default Control Handler that handles Controls with type = label. 
@class RandomizerControlHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IGroupItemHandler}
**/
var RandomizerControlHandler = function () {
    IGroupItemHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.2.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupItemRandomizerJSON} params.config The underlying config part which is required to create the RandomizerControlHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
**/
RandomizerControlHandler.prototype.create =function (params, layoutmanager) {
    var thisObj = this.initialize(params,layoutmanager);
    thisObj.content.addClass('ui-randomizer-group-item');
    var parameters = params.config.parameters;
    var randomizeIcon = Library.imageURL('randomize-button.png');
    var icon = {url: randomizeIcon, position: 'left'};
    var button = new Controls.Button({id: thisObj.id, parent: thisObj.content.contentArea, icon: icon});
    layoutmanager.setContainer(params.config, button);
};


/**
An Abstract class for creating group handlers. All Group Handlers must extend this class.
@class IGroupHandler
@namespace Controls
@since 1.1.0
@constructor
**/
var IGroupHandler = function () {};

/**
Initializes the group Handler by passing the corresponding parameter JSON. 
@method initialize
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupJSON} params.config The underlying config part which is required to create the GroupHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
@return {Object} result
    @return {String} result.id Unique Id of the Group Handler.
    @return {Controls.Panel} result.parent Parent panel of the control.
    @return {CoreLibrary.LayoutGroupJSON} result.config The underlying config part which is required to create the GroupHandler.
    @return {Controls.Panel} result.content Panel within which the control needs to be created.
**/
IGroupHandler.prototype.initialize = function (params, layoutmanager) {
    var config = params.config;
    var id = params.id;
    if(config.id) {
        id = id + '_' + config.id || 'group-child';
    }

    var content = new Controls.Panel({id: id, parent: params.parent.contentArea, suppressHeader: true});


    if(config.background ) {
        $(content._element).css( {
            "background-image" : "url(" + config.background + ")",
            "background-size" : "cover"
        });
    }


    params.parent.resize.bind(function(content) { return function () {
        content.resize.fire();
    }; }(content));

    return {
        id : id + '-child',
        parent : params.parent,
        config : config,
        content: content
    };
};

/**
Static method that extends the Class with the IGroupHandler Interface to allow the Class to be used as a GroupHandler.
@method extend
@static
@since 1.1.0
@param {Object} control New Class
**/
IGroupHandler.extend = function (control) {
    $.extend(control,IGroupHandler.prototype);
};

/**
The DefaultGroupHandler class is a default Group Handler that handles Controls without a type (type = undefined). This Handler will simply group the children (if any) within a Panel.
@class DefaultGroupHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IGroupHandler}
**/
var DefaultGroupHandler = function () {
    IGroupHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupJSON} params.config The underlying config part which is required to create the DefaultGroupHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
**/
DefaultGroupHandler.prototype.create = function (params, layoutmanager) {
    var thisObj = this.initialize(params,layoutmanager);
    var config = thisObj.config;
    if(!config.children) return;
    var len = config.children.length;
    var dock;
    for(var i=0;i<len;i++) {
        var controlItem = config.children[i];
        if(controlItem.dock) {
            dock = dock || {};
            if(controlItem.resizable === true) {
                dock[controlItem.dock] = {resizable : true};
            } else {
                dock[controlItem.dock] = true;
            }
        }
    }

    var onResize = function(content) { return function () {
            if(content.update) {
                content.update();
            }
            content.resize.fire();
        };
    };


    if(dock) {
        thisObj.control = new Controls.DockLayout({id:'layout-' + thisObj.id, parent: thisObj.content.contentArea, dock: dock});
    } else {
        if(config.title)
            thisObj.control = new Controls.Panel({id: 'panel-' + thisObj.id, parent: thisObj.content.contentArea, title: config.title});
        else
            thisObj.control = new Controls.Panel({id: 'panel-' + thisObj.id, parent: thisObj.content.contentArea, suppressHeader: true});
    }
    params.parent.resize.bind(onResize(thisObj.control));

    for(var i=0;i<len;i++) {
        var controlItem = config.children[i];
        var parent;
        if(controlItem.dock) {
            parent = thisObj.control.content[controlItem.dock];
        } else {
            parent = thisObj.control;
        }
        layoutmanager.createGroupItem({
            id : thisObj.id + '-child' + i,
            parent : parent,
            config : controlItem
        });
    }

};

/**
The TabGroupHandler class is a default Group Handler that handles Controls with type = tab. This Handler will create a tab control and create the children within the corresponding tabs.
@class TabGroupHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IGroupHandler}
**/
var TabGroupHandler = function () {
    IGroupHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupTabsJSON} params.config The underlying config part which is required to create the TabGroupHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
**/
TabGroupHandler.prototype.create = function (params, layoutmanager) {
    var thisObj = this.initialize(params,layoutmanager);
    var config = thisObj.config;
    var len = config.children.length;
    var tabs = {};
    for(var i=0;i<len;i++) {
        var child = config.children[i];
        var id = 'tab-' + thisObj.id + '-' + i;
        tabs[id] = {'tabid' : id, 'headerText' : child.group.name, 'headerImageStyle' : child.group.headerImageClass};
    }

    thisObj.control = new Controls.Tab({id:'tabcontrol-' + thisObj.id, parent: thisObj.parent.contentArea, tabs: tabs});


    var onResize = function(content) { return function () {
        if(content.update) {
            content.update();
        }
        content.resize.fire();
        };
    };

    var tp = thisObj.control.tabPages;
    for(i=0;i<len;i++) {
        var tabpage = tp[i];
        var parent = new Controls.Panel({id: thisObj.id + '-panel' + i, parent: tabpage, suppressHeader: true});
        layoutmanager.createGroupItem({
            id : config.children[i].id || thisObj.id + '-child' + i,
            parent : parent,
            config : config.children[i]
        });
        params.parent.resize.bind(onResize(parent));
        thisObj.control.change.bind(onResize(parent));
    }
    thisObj.control.selectedTabIndex = 0;
    layoutmanager.setContainer(params.config, thisObj.control);
};


/**
The MapGroupHandler class is a default Group Handler that handles Controls with type = map. This Handler will create a map control and create the children in a popup control.
The Popup will show up when the user selects a particular area of the map.
@class MapGroupHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IGroupHandler}
**/
var MapGroupHandler = function () {
    IGroupHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupMapJSON} params.config The underlying config part which is required to create the MapGroupHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
**/
MapGroupHandler.prototype.create = function (params, layoutmanager) {
    var thisObj = this.initialize(params,layoutmanager);
    var config = thisObj.config;
       
    //var colorPopup = {};
    var len = config.map.legend.length;
    var mapitems = [];
    for(var i=0;i<len;i++) {
        var mapkey = config.map.legend[i];
        var id = 'map-' + thisObj.id + '-' + i;
        var item = {id:id, value: mapkey.color, imagesrc: mapkey.highlight, activesrc: mapkey.active};
        if(i===0) {
            item.selected = true;
        }
        mapitems.push(item);

        if(mapkey.group) {
            var popup = new Controls.Panel({id: id +'-popup', parent: layoutmanager.contentArea, css:'ui-layoutmanager-popup', suppressHeader: true});
            layoutmanager.createControlGroup({
                id : id + '-container',
                parent : popup,
                config : mapkey.group
            });
        }
        //colorPopup[id] = popup;
    }

    thisObj.control = new Controls.ImageMap({id:'mapcontrol' + thisObj.id, parent: thisObj.content.contentArea, items: mapitems, mainImage: config.map.image, mapImage: config.map.map});
    /*thisObj.control.change.bind(function () {
        var popup = colorPopup[thisObj.control.value];
        popup.show();
    });*/
    layoutmanager.setContainer(params.config, thisObj.control);
};


/**
The FlyoutGroupHandler class is a Group Handler that handles Controls with type = flyout. This Handler will create a flyout control and create the children within the corresponding flyout.
@class FlyoutGroupHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IGroupHandler}
**/
var FlyoutGroupHandler = function () {
    IGroupHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.FlyoutGroupJSON} params.config The underlying config part which is required to create the FlyoutGroupHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
**/
FlyoutGroupHandler.prototype.create = function (params, layoutmanager) {
    var thisObj = this.initialize(params,layoutmanager);
    var config = thisObj.config;
    var flyout = config.flyout;
    var content = thisObj.content;

    var text = flyout.text;
    content.addClass('ui-flyout-label-group-item');
    if(flyout.fontSize) {
        flyout.addClass('ui-flyout-label-fontsize-' + flyout.fontSize);
    }
    if(flyout.styleClass && flyout.styleClass !== '') {
        content.contentArea.addClass(flyout.styleClass);
    }
    var flyoutArrow = new Controls.Panel({id: flyout.id + '-arrow', parent: content.contentArea, css: 'ui-flyout-arrow', suppressHeader: true});
    if(flyout.iconStyleClass && flyout.iconStyleClass !== '') {
        var iconContent = new Controls.Panel({id: flyout.id + '-icon', parent: content.contentArea, css: 'ui-flyout-icon-item ' + flyout.iconStyleClass, suppressHeader: true});
        if(text !== '') {
            var textContent = new Controls.Panel({id: flyout.id + '-text', parent: content.contentArea, css: 'ui-flyout-text-item', suppressHeader: true});
            textContent.contentArea.text(text);
        }
    } else {
        content.contentArea.text(text);
    }

    var hideAllOtherFlyouts = function () {
        var allFlyouts = $('body').find('.ui-popup');
        var allButThis = allFlyouts.not('[id$=' + flyout.id + ']');
        allButThis.hide();
    };
    var hiding;

    var onEnter = function () {
        if(!thisObj.control) {
            createFlyout();
            thisObj.control.onInitialize();
            hideAllOtherFlyouts();
        }
        else {
            if(hiding) clearTimeout(hiding);
           thisObj.control.onInitialize();
           hideAllOtherFlyouts();
       }
    };

    var onExit = function () {
         hiding = setTimeout(function () {
            thisObj.control.hide();
        }, 500);
    };

    content.contentArea.hover(onEnter,onExit);

    var createFlyout = function () {
        thisObj.control = new Controls.Popup({id : 'flyoutcontrol-' + flyout.id || thisObj.id, position: flyout.position}, content.contentArea);
        thisObj.control.content.hover(onEnter,onExit);

        if(flyout.children && flyout.children.length) {
            var flyoutPanel = new Controls.Panel({id: 'flyoutcontrol-' + (flyout.id || thisObj.id) + '-child', parent: thisObj.control.content, css:'', suppressHeader: true});
            var len = flyout.children.length;
            for(var i=0;i<len;i++) {
                var controlItem = flyout.children[i];
                layoutmanager.createGroupItem({
                    id : (flyout.id || thisObj.id) + '-child' + i,
                    parent : flyoutPanel,
                    config : controlItem
                });
            }
        }
    };
    createFlyout();
    thisObj.control.hide();

    content.onHide = function () {
        thisObj.control.hide();
    };

    layoutmanager.setContainer(params.config, content);
    
};


/**
The ChoiceGroupHandler class is a default Group Handler that handles Controls with type = choice. This Handler will create an option list (depending on the choice type).
@class ChoiceGroupHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IGroupHandler}
**/
var ChoiceGroupHandler = function () {
    IGroupHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroupChoiceJSON} params.config The underlying config part which is required to create the ChoiceGroupHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
**/
ChoiceGroupHandler.prototype.create = function (params, layoutmanager) {
    var thisObj =this.initialize(params,layoutmanager);
    //TODO: Choice group handling    
};


/**
The ButtonGroupItemHandler class is a special button handler that creates and handlers buttons for layout group items with type = button.
This handler will create a Button with the configurations passed in the argument.
@class ButtonGroupHandler
@constructor
@extends {Controls.IGroupItemHandler}
@private
**/
var ButtonGroupItemHandler = function() {
    IGroupItemHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {ButtonGroupItemJSON} params.config The underlying config part which is required to create the ButtonGroupItemHandler.
@param {Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
@private
**/
ButtonGroupItemHandler.prototype.create = function(params, layoutmanager) {
    var thisObj = this.initialize(params, layoutmanager);
    var config = params.config;

    var button = new Button({id: 'button-' + thisObj.id, parent: thisObj.content.contentArea, text: config.button.text, css: config.button.css});
    layoutmanager.setContainer(params.config, button);
};

//Initializes the default group and control handlers.
var initializeLayoutHandlers = function () {
    LayoutHandlers.addGroupHandler('default', new DefaultGroupHandler(), 'true');
    LayoutHandlers.addGroupHandler('tabs', new TabGroupHandler(), 'true');
    LayoutHandlers.addGroupHandler('map', new MapGroupHandler(), 'true');
    LayoutHandlers.addGroupHandler('choice', new ChoiceGroupHandler(), 'true');
    LayoutHandlers.addGroupHandler('flyout', new FlyoutGroupHandler(), 'true');

    LayoutHandlers.addGroupItemHandler('group', new GroupControlHandler(), 'true');
    LayoutHandlers.addGroupItemHandler('parameter', new ParameterControlHandler(), 'true');
    LayoutHandlers.addGroupItemHandler('label', new LabelControlHandler(), 'true');
    LayoutHandlers.addGroupItemHandler('randomizer', new RandomizerControlHandler(), 'true');
    LayoutHandlers.addGroupItemHandler('button', new ButtonGroupItemHandler(), 'true');
};

Controls.LayoutManager = LayoutManager;
Controls.IGroupHandler = IGroupHandler;
Controls.IGroupItemHandler = IGroupItemHandler;
Controls.LayoutHandlers = LayoutHandlers;
/**   
LibraryFeedback control parameters.
@class LibraryFeedbackParams
@since 1.0.0
@see Controls.LibraryFeedback
@unlisted
**/
var LibraryFeedbackParams = function(){

    /**
    An id of LibraryFeedback control.
    @property {String} id
    @default 'feedback'
    **/
    this.id = undefined;

    /**
    Parent of feedback control. Pass valid id or jQuery object of parent.
    If parent is not set then Feedback control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    External css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    Initial libraryid.
    @property {Number} libraryid
    **/
    this.libraryid = undefined;

    /**
    Initial library version.
    @property {Number} version
    **/
    this.version = undefined;

    /**
    Logged in user id.
    @property {Number} userid
    **/
    this.userid = undefined;

};

/**
An HTML library feedback control.

@class LibraryFeedback
@param {Controls.LibraryFeedbackParams} params LibraryFeedback control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.0.0
@constructor
@example
function CreateFeedback() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var libraryFeedback = new controls.LibraryFeedback({
              id:'libraryFeedback',
              parent: 'libraryFeedbackExample',
              libraryid: '', //valid library id
              version: 0, //library version
              userid: '' //optional userid
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var LibraryFeedback = function (params) {
    
    if(params.libraryid !== undefined) this._libraryid = params.libraryid; else return;
    if(params.version !== undefined) this._version = params.version; else return;
    if(params.userid !== undefined) this._userid = params.userid;
    this._isEdit = false;
    this._utility = Utility;

    /**
    Library id.
    @property {Number} libraryId
    @public
    @readonly
    **/
    Object.defineProperty(this, "libraryId",{
        get : function () {
            return this._libraryid;
        },
        enumerable : true
    });

    /**
    Library version.
    @property {Number} version
    @readonly
    @public
    **/
    Object.defineProperty(this, "version",{
        get : function () {
            return this._version;
        },
        enumerable : true
    });

    /**
    User id.
    @property {Number} userId
    @readonly
    @public
    **/
    Object.defineProperty(this, "userId",{
        get : function () {
            return this._userid;
        },
        enumerable : true
    });

    var me = this;
    $.when(this._getFeedback()).then(function () {
        me._element = me._createControl(params);
        BaseControl.extend(me);
        me._element.attr('libraryid', me.libraryId);
        me.done.fire();
    }, function () {
        
    });

    /**
    Event will be fired when feedback control complete loading.
    For post processing client can bind to this event.
    @event done
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.done = new CoreLibrary.EventSource('done');
    
};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.LibraryFeedbackParams} params LibraryFeedback control parameters 
@return {Object} jQuery object of LibraryFeedback control.
**/
LibraryFeedback.prototype._createControl = function (params) {
    var id = params.id || 'libraryfeedback';
    var css = params.css || '';
    
    var options = {
        id: id,
        css: css,
        isUserId: this._userid ? true : false,
        isEdit: this._isEdit
    };

    //rating
    var rating = {
        id: id + 'rating',
        rating: this._ratingAll, //initial rating
        max: 5 - this._ratingAll,
        reviewCount: this._reviewCount,
        readonly: true
    };

    options.rating = rating;

    //rating
    var feedback = {
        id: id + 'feedback',
        isEdit: this._isEdit,
        rating: {
            id: id + 'feedbackrating',
            max: 5,
            readonly: false
        }, //initial rating
        comment: {
            id: id + 'feedbacktxtComment',
            text: ''
        }
    };

    options.feedback = feedback;
    console.log(options);
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['libraryfeedback'](options));
    return parent.find('#' + id);
};

/** 
Initialize LibraryFeedback control
@private
@method onInitialize
**/
LibraryFeedback.prototype.onInitialize = function () {
    var me = this;
    var showFeedback = function (e) {
        me._feedbackControlContainer.show();
        me._feedbackControlLinkContainer.hide();
        e.preventDefault();
    };
    var showLinkContainer = function () {
        me._feedbackControlContainer.hide();
        me._feedbackControlLinkContainer.show();
    };
    var updateOverallRating = function () {
        $.when(me._getFeedback()).then(function () {
            me._ratingControl.rating = me._ratingAll;
            me._ratingControl.reviewCount = me._reviewCount;
        }, function () { });
    };

    this._feedbackControlContainer = this._element.find('#feedbackControl');
    this._feedbackControlLinkContainer = this._element.find('#feedbackControlLinks');
    this._lnkGiveFeedback = this._element.find('.ui-libraryfeedback-col2 > a.ui-libraryfeedback-give').bind('click', showFeedback);
    this._lnkupdateFeedback = this._element.find('.ui-libraryfeedback-col2 > a.ui-libraryfeedback-update').bind('click', showFeedback);
    this._ratingControl = Rating.bind(this._element.find('#' + this.id + 'rating'));
    this._ratingControl.reviewclick.bind(function () {
        var popup = new LibraryFeedbackPopup({
            libraryid: me._libraryid,
            version: me._version
        }, me._ratingControl._reviewLink);
    });
    
    if(!this._isEdit) { //default rating & feedback
        this._feedbackControl = Feedback.bind(this._element.find('#' + this.id + 'feedback'), {
            rating: 5,
            comment: '',
            isEdit: false
        });
    } else { //user rating & feedback
        this._feedbackControl = Feedback.bind(this._element.find('#' + this.id + 'feedback'), {
            rating: this._ratingUser,
            comment: this._commentUser,
            isEdit: true
        });
    }
    var submitCallback = function () {
        updateOverallRating();
        showLinkContainer();
        me._lnkGiveFeedback.hide();
        me._lnkupdateFeedback.show();
        me._feedbackControl.isEdit = true;
        if(!me._isEdit) me._isEdit = true;
    };
    this._feedbackControl.submit.bind(function () {
        if(!me._isEdit) {
            $.when(me._addFeedback()).then(submitCallback, function () {});
        } else {
            $.when(me._updateFeedback()).then(submitCallback, function () {});
        }
    });
    this._feedbackControl.delete.bind(function () {
        $.when(me._deleteFeedback()).then(function () {
            updateOverallRating();
            showLinkContainer();
            me._lnkGiveFeedback.show();
            me._lnkupdateFeedback.hide();
            me._feedbackControl.isEdit = false;
            me._isEdit = false;
            me._feedbackControl.comment = '';
            me._feedbackControl.rating = 5;
        }, function () { });
    });

};

LibraryFeedback.prototype._getFeedback = function () {
    var dfd = new $.Deferred();
    var options = {
        url: '/libraries/' + this.libraryId + '/' + this.version + '/feedback',
        dataType : 'json'
    };
    
    var me = this;
    $.when(this._utility.ajax(options)).then(function (feedback) {
        var len = feedback.length;
        if(len) {
            var ratings = 0;
            for(var i=0;i<len;i++){
                var fb = feedback[i];
                ratings = ratings + Number(fb.stars || 0);
                if(fb.user === me._userid) {
                    me._ratingUser = fb.stars;
                    me._commentUser = fb.comment;
                    me._isEdit = true;
                }
            }
            ratings = Math.round(ratings/len);
            me._ratingAll = ratings;
            me._reviewCount = len;
        } else {
            me._ratingAll = 0;
            me._reviewCount = 0;
        }
        dfd.resolve();
    }, function () {
        dfd.reject();
    });
    return dfd;
};

LibraryFeedback.prototype._addFeedback = function () {
    var options = {
        url: '/libraries/' + this.libraryId + '/' + this.version + '/feedback',
        type: 'POST',
        dataType : 'json',
        data: JSON.stringify({
            comment : this._feedbackControl.comment,
            stars: this._feedbackControl.rating
        })
    };
    return this._utility.ajax(options);
};

LibraryFeedback.prototype._updateFeedback = function () {
    var options = {
        url: '/libraries/' + this.libraryId + '/' + this.version + '/feedback',
        type: 'PUT',
        dataType : 'json',
        data: JSON.stringify({
            comment : this._feedbackControl.comment,
            stars: this._feedbackControl.rating
        })
    };
    return this._utility.ajax(options);
};

LibraryFeedback.prototype._deleteFeedback = function () {
    var options = {
        url: '/libraries/' + this.libraryId + '/' + this.version + '/feedback',
        type: 'DELETE',
        dataType : 'json'
    };
    return this._utility.ajax(options);
};

Controls.LibraryFeedback = LibraryFeedback;

/**   
LibraryFeedback popup control parameters.
@class LibraryFeedbackPopupParams
@since 1.0.0
@see Controls.LibraryFeedbackPopup
@unlisted
**/
var LibraryFeedbackPopupParams = function(){

    /**
    Initial libraryid.
    @property {Number} libraryid
    **/
    this.libraryid = undefined;

    /**
    Initial library version.
    @property {Number} version
    **/
    this.version = undefined;

    /**
    Position of library feedback popup.
    @property {Controls.PopupPositionEnum} position
    **/
    this.position = undefined;

};

/**
An HTML library feedback popup control.

@class LibraryFeedbackPopup
@param {Controls.LibraryFeedbackPopupParams} params LibraryFeedback popup control parameters.
@namespace Controls
@extends Controls.BaseControl
@suppress blur, focus, keydown, keypress, keyup, enable, disable
@since 1.0.0
@constructor
@example
function CreateFeedbackPopup() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var libraryFeedback = new controls.LibraryFeedbackPopup({
              libraryid: '', //valid library id
              version: 0, //library version
              position: controls.PopupPositionEnum.TOP //default position is top
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var LibraryFeedbackPopup = function (params, target) {
    if(params.libraryid !== undefined) this._libraryid = params.libraryid; else return;
    if(params.version !== undefined) this._version = params.version; else return;
    if(params.position !== undefined) this._position = params.position; else this._position = PopupPositionEnum.TOP;
    this._popupControl = undefined;
    this._target = $(target);
    this._utility = Utility;
    this._createControl();
    BaseControl.extend(this);
};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.LibraryFeedbackPopupParams} params Feedback popup control parameters 
**/
LibraryFeedbackPopup.prototype._createControl = function (params) {
    var parent = $('<div>'), me = this;
    this._getFeedback().done(function (feedbacks) {
        parent.append(Handlebars.templates['libraryfeedbackpopup'](feedbacks));
        var popupControl = new Popup({
            id: 'feedback' + me._libraryid,
            content: parent.html(),
            position: me._position
        }, me._target);
        popupControl.onHide = function () {
            this.remove();
        };
        me._popupControl = popupControl;
        me._popupControl.content.find('#lnkshowall').click(function () {
            var url = Environment.getVariable(["urls", "api"]) + '/libraries/' + me._libraryid + '/' + me._version + '/feedback.html';
            window['open'](url, 'newwindow', 'location=yes,status=yes,menubar=yes,scrollbars=yes,resizable=yes');
        });
    });
};

/** 
Initialize Library feedback Popup
@private
@method onInitialize
**/
LibraryFeedbackPopup.prototype.onInitialize = function () {

};

/** 
Get feedback and prepare raw data to generate html.
@private
@method _getFeedback
**/
LibraryFeedbackPopup.prototype._getFeedback = function () {
    var dfd = new $.Deferred();
    var options = {
        url: '/libraries/' + this._libraryid + '/' + this._version + '/feedback',
        dataType : 'json'
    };
    
    var me = this;
    $.when(this._utility.ajax(options)).then(function (feedback) {
        var feedbacks = [];
        var len = feedback.length;
        if(len) {
            if(len > 5) len = 5; // show first 5 feedbacks
            var domain = window.location.protocol + '//' + window.location.host;
            for(var i=0;i<len;i++){
                var fb = {};
                fb.avtar = domain + '/users/' + feedback[i].user + '/avatar/t40.jpg';
                fb.rating = {
                    id: feedback[i].user + 'rating',
                    rating: feedback[i].stars,
                    max: 5 - feedback[i].stars,
                    readonly: true,
                    hideReviewCount: true
                };
                fb.username = feedback[i].userName;
                fb.userprofilelink = domain + '/users/' + feedback[i].user;
                fb.feedback = feedback[i].comment;
                fb.datetime = me._timeAgo(feedback[i].date);
                feedbacks.push(fb);
            }
        }
        dfd.resolve(feedbacks);
    }, function () {
        dfd.reject();
    });
    return dfd;
};

/** 
Convert time into word representation.
@private
@method _timeAgo
@param {String} feedbackDateStr Feedback date string. 
**/
LibraryFeedbackPopup.prototype._timeAgo = function (feedbackDateStr) {
    var delta = Math.round(Date.now() - new Date(feedbackDateStr));

    var seconds = Math.round(delta / 1000);
    var minutes = Math.round(seconds / 60);
    var hours = Math.round(minutes / 60);
    var days = Math.round(hours / 24);
    var years = Math.round(days / 365);

    if (seconds < 45) {
        return "less than a minute ago";
    } else if (seconds < 120) {
        return "about a minute ago";
    } else if (minutes < 45) {
        return minutes + " minutes ago";
    } else if (minutes < 120) {
        return "about an hour ago";
    } else if (hours < 24) {
        return "about "+ hours + " hours ago";
    } else if (hours < 48) {
        return "a day ago";
    } else if (days < 30) {
        return days + " days ago";
    } else if (days < 60) {
        return "about a month ago";
    } else if (days < 365) {
        return Math.round(days/30) + " months ago";
    } else if (years < 2) {
        return "about a year ago";
    }
    return years + " years ago";
};

Controls.LibraryFeedbackPopup = LibraryFeedbackPopup;




/**   
Panel control parameters.
@class PanelParams
@since 1.0.0
@see Controls.Panel
@unlisted
**/
var PanelParams = function(){

    /**
    Id of the panel control.
    @property {String} id
    @default 'panel'
    **/
    this.id = undefined;

    /**
    Parent of the panel control. Requires valid id or jQuery object of parent.
    If parent is not set then the Panel control will be appended to the body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Panel Title text.
    @property {String} title
    **/
    this.title = undefined;

    /**
    Specifies whether the panel is collapsible or not.
    @property {Boolean} collapsible
    @default false
    **/
    this.collapsible = undefined;

    /**
    Specifies whether the panel needs to create a header or not.
    @property {Boolean} suppressHeader
    @default false
    **/
    this.suppressHeader = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;


};

/**
Creates a Panel to hold controls. The Panel can be collapsed to hide/show the content.  
For an interactive demonstration please see: {Interactive Control Demos}.

@class Panel
@param {Controls.PanelParams} params Panel control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.0.0
@constructor
@example
function CreatePanel() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var panel = new controls.Panel({
                id:'panelControl'
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Panel = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    BaseControl.extend(this);

    var _contentArea = this._element.find('.ui-panel-content');
    if(!_contentArea.size()) {
        _contentArea = this._element;
    }

    var _header = this._element.find('.ui-panel-header');
    var _title = _header.find('.ui-panel-header-title');
    var _icon = this._element.find('.ui-panel-icon');
    var _collapsebutton = _header.find('.ui-panel-header-collapse-button');
    var _children = [];

    _collapsebutton.click(function () {
        if(_collapsebutton.hasClass('ui-panel-header-collapse-button-collapsed')) {
            _collapsebutton.removeClass('ui-panel-header-collapse-button-collapsed');
        }
        else
            _collapsebutton.addClass('ui-panel-header-collapse-button-collapsed');
        _contentArea.toggle();
    });

    /**
    Returns the content area within which the content needs to be created.
    @property {Object} contentArea
    @public
    @readonly
    **/
    Object.defineProperty(this, "contentArea",{
        get : function () {
            return _contentArea;
        },
        enumerable : true
    });

    /**
    Get/Set the title.
    @property {String} title
    @public
    **/
    Object.defineProperty(this, "title",{
        get : function () {
            return _title.text();
        },
        set : function (title) {
            _title.text(title);
            title ? _header.css('display','block') : _header.css('display','none');
        },
        enumerable : true
    });

    /**
    Set the Icon of the container.
    @property {Object} args
        @property {Object} args.icon URL of the image to be displayed
        @property {Object} [args.text] Tooltip to be displayed on the icon
    @public
    **/
    Object.defineProperty(this, "icon",{
        set : function (args) {
            _icon[0].src = args.icon;
            if(args.text) {
                _icon[0].title = args.text;
            }
            _icon.addClass('ui-panel-icon-visible');
        },
        enumerable : true
    });

    /**
    Fires when the panel is resized
    @event resize
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.resize = new CoreLibrary.EventSource('resize');
    
};

/** 
Create control from handlebar template.
@private
@method _createControl
@return {Object} jQuery object of Panel control.
**/
Panel.prototype._createControl = function (params) {
    var id = params.id || 'panel';
    var css = params.css || '';
   
    var options = {
        id: id,
        css: css,
        title: params.title,
        collapsible: params.collapsible,
        suppressheader: params.suppressHeader
    };

    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else
        parent = $(params.parent);

    parent.append(Handlebars.templates['panel'](options));
    return parent.find('#' + id);
};

Controls.Panel = Panel;

/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
This is an internal class that hold the implementation for managing Parameter Handlers used by the ParameterManager
@private
@class _parameterHandlers
**/
var _parameterHandlers = function () {

    /**
    Key-Value pair of the Parameter Handlers attached to the instance
    @private 
    @property _parameterHandlers
    **/
    this._parameterHandlers = {};
};

_parameterHandlers.prototype = {

    /**
    Adds a Parameter Handler to the collection and stores it against its id. The sealed argument determines if another handler by the same id can override this handler.
    @private
    @method _addParameterHandler
    @param {String} id Unique id of the handler. The handler will be used based on the id matching the corresponding type in the parameter definition.
    @param {Controls.IParameterHandler} handler The handler implementing the IParameterHandler class
    @param {Boolean} sealed This argument determines if the handler can be overriden. The default value is false.
    **/
    _addParameterHandler : function (id, handler, sealed) {
        var handlers = this._parameterHandlers;
        if(handlers[id] === undefined || handlers[id].sealed === undefined) {
            handlers[id] = handler;
            if(sealed) {
                handlers[id].sealed = true;
            }
        }
    }
};


/**   
Singleton of the ParameterHandlers class that allows adding/replacing Parameter Handlers as well as accessing them by id.
This singleton is used by the ParameterManager to create the Parameter Controls based on the corresponding Handlers. 
Clients can define their own types and write their corresponding handlers and add them.
@class ParameterHandlers
@static
@namespace Controls
@since 1.1.0
@see Controls.ParameterManager
@example
function addNewParameterHandler() {

    // This will allow you to extend the parameter definition by using the newly defined 'new-parameter-type' type. 
    // This handler is sealed so it can not be changed.
    ParameterHandlers.addParameterHandler('new-parameter-type',object-of-Handler, true); 

}
**/
var ParameterHandlers = (function () {

    var handlerinstance = new _parameterHandlers();

    return {

        /**
        Returns the current collection of Parameter Handlers
        @method parameterHandlers
        @static
        @return {Array[Controls.IParameterHandler]} Collection of ParameterHandlers.
        **/
        parameterHandlers : function () { return $.extend( {}, handlerinstance._parameterHandlers);},

        /**
        Adds a Parameter Handler
        @method addParameterHandler
        @static
        @param {String} id Unique id of the handler. The handler will be used based on the id matching the corresponding type in the parameter definition.
        @param {Controls.IParameterHandler} handler The handler implementing the IParameterHandler class
        @param {Boolean} [sealed=false] This argument determines if the handler can be overriden.
        **/
        addParameterHandler : function (id, handler, sealed) {
            handlerinstance._addParameterHandler(id,handler, sealed);
        }
    };
})();


/**   
ParameterManager control parameters.
@class ParameterPanelParams
@since 1.0.0
@see Controls.ParameterManager
@unlisted
**/
var ParameterPanelParams = function(){

    /**
    Id of the parametermanager control.
    @property {String} id
    @default 'parametermanager'
    **/
    this.id = undefined;

    /**
    Parent of the parametermanager control. Requires valid id or jQuery object of parent.
    If parent is not set then the ParameterManager control will be appended to the body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    ParameterManager Title text.
    @property {String} title
    **/
    this.title = undefined;

    /**
    Specifies whether the parametermanager is collapsible or not.
    @property {Boolean} collapsible
    @default false
    **/
    this.collapsible = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;
};

/**
Creates a ParameterManager which is responsible for creating and managing Parameter controls based on the Shape Generator parameters.
The ParameterManager can be collapsed to hide/show the content.  
For an interactive demonstration please see: {Interactive Control Demos}.

@class ParameterManager
@param {Controls.ParameterPanelParams} params ParameterManager control parameters.
@namespace Controls
@since 1.0.0
@constructor
@example
function CreateParameterPanel() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var panel = new controls.ParameterManager({
                id:'parameterPanelControl'
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var ParameterManager = function () {
    /*params.css = 'ui-parameter-panel ' + params.css;
    $.extend(this,Controls.Panel.prototype);
    Controls.Panel.call(this, params);*/

    var _parameterHandlers = [];

    this._parameters = {};

    var me=this;

    /**
    Gets the collection of the ParameterHandlers.
    @property {Array} parameterHandlers Array of types implementing IParameterHandler
    @public
    **/
    Object.defineProperty(this, "parameterHandlers",{
        get : function () {
           return _parameterHandlers;
        },
        enumerable : true
    });

    /** 
    Returns the value of the parameter panel.
    @property {Array} value Array of the control values
    @public
    **/
    Object.defineProperty(this, "value",{
        get : function () {
            if(me._parameters) {
                var result = {};
                for(var id in me._parameters) {
                    result[id] = me._parameters[id].control.param();
                }
                return result;
            }
        },
        enumerable : true
    });

    /**
    Sets the layout manager.
    @property {Controls.LayoutManager} layoutManager Layout configuration
    @public
    **/
    Object.defineProperty(this, "layoutManager",{
        set : function (layoutmanager) {
            if(me._layoutmanager === undefined) {
               me._layoutmanager = layoutmanager;
            }
            else
            {
                console.log('The layout can not be modified');
            }
        },
        enumerable : true
    });


    /**
    Fires when a parameter value is changed.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

    /**
    Fires when a parameter value is begin to change.
    @event beginchange
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.beginchange = new CoreLibrary.EventSource('beginchange');

    /**
    Fires when a parameter value is complete changing.
    @event endchange
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.endchange = new CoreLibrary.EventSource('endchange');
};

ParameterManager.prototype.isEmpty = function () {
    if (this._parameters) {
        return $.isEmptyObject(this._parameters);
    }
    return true;
};

ParameterManager.prototype.clear = function () {
    for (var key in this._parameters) {
        var control = this._parameters[key].control;
        control.remove();
    }
    this._parameters = {};
};

ParameterManager.prototype.setControl = function (param, control) {
    var me = this;
    var onchange = function(id) { return function (e) {
        var info = me._parameters[id];
        var newValue = info.control.param();
        var data = {oldValue: info.definition.default, newValue: newValue, id: id};
        if(info.definition.validate) {
            data.validate = true;
        }
        info.definition.default = newValue;
        me.change.fire(data, e);
    }; };
    this._parameters[param.id] = {control: control, definition: param};
    control.change.bind(onchange(param.id));

    if(control.beginchange) {
        var onbeginchange = function(id) { return function (e) {
            var info = me._parameters[id];
            var data = {oldValue: info.definition.default, newValue: info.control.param(), id: id};
            if(info.validate) {
                data.validate = true;
            }
            me.beginchange.fire(data, e);
        }; };
        control.beginchange.bind(onbeginchange(param.id));
    }

    if(control.endchange) {
        var onendchange = function(id) { return function (e) {
            var info = me._parameters[id];
            var data = {oldValue: info.definition.default, newValue: info.control.param(), id: id};
            if(info.validate) {
                data.validate = true;
            }
            me.endchange.fire(data, e);
        }; };
        control.endchange.bind(onendchange(param.id));
    }

};

ParameterManager.prototype.updateParams = function (shapeGeneratorParams) {
 
    var handlers = ParameterHandlers.parameterHandlers();
    var me = this;

    var compareParameters = function (param1, param2) {
        if(param1 && param2) {
            var keys1 = Object.keys(param1);
            var keys2 = Object.keys(param2);
            if(keys1.length !== keys2.length) {
                return false;
            }

            //If the number of keys in both the parameters are equal then we'd find a mismatch in the following code anyway.
            for(var key1 in param1) {
                if(typeof param1[key1] == 'object') {
                    if(!compareParameters(param1[key1],param2[key1])) {
                        return false;
                    }
                }
                else if(param2[key1] != param1[key1]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    
    var createControl = function (param) {
        var container = me._layoutmanager.findContainers({type: 'parameter', id: param.id})[0].control;
        var type = param.type;
        var handler;
     
        if(type !== undefined && handlers[type] !== undefined) {
            handler = handlers[type];
        } else {
            console.error('A Parameter definition requires a valid type');
            return;
        }

        if(param.libraryId && undefined !== param.version) container.addClass('l' + param.libraryId + param.version);
        var params = {parent: container, definition: param};
        handler.create(params, me);
        if(param.visible !== undefined) {
            if(param.visible) {
                me._parameters[param.id].control.show();
                container.show();
            }
            else {
                me._parameters[param.id].control.hide();
                container.hide();
            }
        }
    };

    var updateControl = function (param) {
        var currentValue = me._parameters[param.id].control.param();
        var definition = me._parameters[param.id].definition;
        var existingdefinition = $.extend({},definition);
        existingdefinition.default = currentValue;
        var newdefinition = $.extend({}, existingdefinition, param);

        if(!compareParameters(newdefinition,existingdefinition)) {
            me._parameters[param.id].control.remove();
            delete me._parameters[param.id];
            createControl(newdefinition);
        }
    };

    var invalidMessage = function (param) {
        //TODO: Validations messages need to be displayed on the corresponding controls.
    };
   
    var len = shapeGeneratorParams.length;
    for(var i=0;i<len;i++) {
        var param = shapeGeneratorParams[i];

        if(param.invalid !== undefined) {
            invalidMessage(param);
        }
        else if(this._parameters[param.id] === undefined) {
            createControl(param);
        } else {
            updateControl(param);
        }
        
    }
};


/**
An Abstract class for creating Parameter Control Handlers. All Parameter Control Handlers must extend this class.
@class IParameterHandler
@namespace Controls
@since 1.1.0
@constructor
**/
var IParameterHandler = function () {};

/**
Initializes the Parameter Control Handler by passing the corresponding parameter JSON. 
@method initialize
@param {Object} params Parameter JSON 
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.ParameterJSON} params.definition The definition which is required to create the Parameter control.
@param {Controls.ParameterManager} parametermanager The instance of the ParameterManager which is using these handlers.
@return {Object} control Instance of the Control created.
**/
IParameterHandler.prototype.initialize = function (params, parametermanager) {
    var container = params.parent;
    var param = params.definition;
    if(!container) { console.log('Container not set for Parameter - ' + param.id);}
    if(param.displayIcon) {
        var icon = { icon: param.displayIcon };
        if(param.displayName) {
            icon.text = param.displayName;
        }
        container.icon = icon;
    } else if(param.displayName) {
        container.title = param.displayName;
    }
};

/**
Static method that extends the Class with the IParameterHandler Class to allow the Class to be used as a ParameterHandler.
@method extend
@static
@param {Object} control New Class
**/
IParameterHandler.extend = function (control) {
    $.extend(control,IParameterHandler.prototype);
};

/**
The ListParameterHandler class is a default List Parameter Handler that handles Parameters with type = list. 
This handler creates an {Controls.ItemSlider} if listImages are defined or a {Controls.Dropdown} otherwise.
@class ListParameterHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IParameterHandler}
**/
var ListParameterHandler = function () {
    IParameterHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary controls.
@method create
@param {Object} params Parameter JSON 
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.ListParameterJSON} params.definition The list definition which is required to create the ListParameter control.
@param {Controls.ParameterManager} parametermanager The instance of the ParameterManager which is using these handlers.
**/
ListParameterHandler.prototype.create =function (params, parametermanager) {
    this.initialize(params, parametermanager);
    var param = params.definition;
    var parent = params.parent.contentArea;
    var items = [];
    var labels = param.listLabels;
    var values = param.listValues;
    var listitemlen = labels.length;
    if(param.listImages || param.listClasses) {
        var images = param.listImages;
        var classes = param.listClasses;
        for(var j=0;j<listitemlen;j++) {
            items.push({
                id: param.id + j,
                value: values[j],
                imagesrc: images ? images[j] : undefined,
                cssclass: classes ? classes[j] : undefined
            });
        }
        var itemCss = 'ui-item-40';
        //if(items.length === 3 || items.length === 6) { itemCss = 'ui-item-60'; }
        //if(items.length === 4 || items.length === 8) { itemCss = 'ui-item-40'; }
        // if(items.length > 4) {
        //     itemCss = 'ui-item-40';
        // }
        var itemsPerSlide = param.pageSize || items.length;

        var itemslider = new Controls.Itemslider({
            id: param.id,
            parent: parent,
            items: items,
            itemCss: 'ui-parameter-panel-item-slider-item ' + itemCss,
            itemsPerSlide: itemsPerSlide
        });
        if(param.default !== undefined) itemslider.selectedValue = param.default;
        itemslider.param = function (control) {
            return function () {
                return control.selectedValue;
            };
        }(itemslider);
        parametermanager.setControl(param, itemslider);
    } else {
        for(var j=0;j<listitemlen;j++) {
            items.push({
                value: values[j],
                text: labels[j]
            });
        }
        var dropdown = new Controls.Dropdown({
            id: param.id,
            parent: parent,
            items: items
        });
        if(param.default !== undefined) dropdown.selectedValue = param.default;
        dropdown.param = function (control) {
            return function () {
                return control.selectedValue;
            };
        }(dropdown);
        parametermanager.setControl(param, dropdown);
    }
   
};

/**
The RangeParameterHandler class is a default List Parameter Handler that handles Parameters with type = int|float|angle|length. 
This handler creates an {Controls.Slider} with the corresponding settings based on the type and properties of the parameters.
@class RangeParameterHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IParameterHandler}
**/
var RangeParameterHandler = function () {
    IParameterHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary controls.
@method create
@param {Object} params Parameter JSON 
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.IntegerParameterJSON|CoreLibrary.FloatParameterJSON|CoreLibrary.AngleParameterJSON|CoreLibrary.LengthParameterJSON} params.definition The definition which is required to create the Range Parameter control.
@param {Controls.ParameterManager} parametermanager The instance of the ParameterManager which is using these handlers.
**/
RangeParameterHandler.prototype.create =function (params, parametermanager) {
    this.initialize(params, parametermanager);
    var param = params.definition;
    var parent = params.parent.contentArea;

    if(param.rangeMin !==undefined && param.rangeMax !== undefined){
        var steps;
        var displayUnit = param.displayUnit;
        var displayValue = param.displayValue === undefined ? true : param.displayValue;
        if(param.type == 'int' || param.type == 'angle') {
            steps = 1;
        }
        if(param.type == 'angle') {
            displayUnit = displayUnit || '°';
        } else if(param.type == 'length') {
            displayUnit = displayUnit || 'mm';
        }
        var slider = new Controls.Slider({
            id: param.id,
            parent: parent,
            min: param.rangeMin,
            max: param.rangeMax,
            steps: param.steps || steps,
            ticks: param.ticks,
            showText: displayValue,
            showInput: true,
            displayUnit: displayUnit
        });
        if(param.default !== undefined) slider.value = param.default;
        slider.param = function (control) {
            return function () {
                return control.value;
            };
        }(slider);
        parametermanager.setControl(param, slider);
    }
    else {
        //TODO: I'm not sure what needs to be done in case the rangeMin/rangeMax are not provided. I'm guessing we could assume some value. 
        console.error('RangeParameterHandler: rangeMin and rangeMax needs to be defined');
    }

};

/**
The BooleanParameterHandler class is a default Boolean Parameter Handler that handles Parameters with type = bool. 
This handler creates an {Controls.Checkbox}.
@class BooleanParameterHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IParameterHandler}
**/
var BooleanParameterHandler = function () {
    IParameterHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary controls.
@method create
@param {Object} params Parameter JSON 
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.BooleanParameterJSON} params.definition The definition which is required to create the Boolean Parameter control.
@param {Controls.ParameterManager} parametermanager The instance of the ParameterManager which is using these handlers.
**/
BooleanParameterHandler.prototype.create =function (params, parametermanager) {
    this.initialize(params, parametermanager);
    params.parent.title = '';
    var param = params.definition;
    var parent = params.parent.contentArea;

    var checkbox = new Controls.Checkbox({
        id: param.id,
        parent: parent,
        checked: param.default,
        text: param.displayName,
        labelPosition: Controls.CheckboxLabelPosition.Right
    });
    if(param.default !== undefined) checkbox.checked = param.default;
    checkbox.param = function (control) {
        return function () {
            return control.checked;
        };
    }(checkbox);
    parametermanager.setControl(param, checkbox);
};

/**
The StringParameterHandler class is a default String Parameter Handler that handles Parameters with type = string. 
This handler creates a {Controls.Textarea} if the singleLine property is set to false (default) or {Controls.Textbox} if it is true.
@class StringParameterHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IParameterHandler}
**/
var StringParameterHandler = function () {
    IParameterHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary controls.
@method create
@param {Object} params Parameter JSON 
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.StringParameterJSON} params.definition The definition which is required to create the String Parameter control.
@param {Controls.ParameterManager} parametermanager The instance of the ParameterManager which is using these handlers.
**/
StringParameterHandler.prototype.create =function (params, parametermanager) {
    this.initialize(params, parametermanager);
    var param = params.definition;
    var parent = params.parent.contentArea;

    var multiline = true;

    if(param.singleLine === true) {
        multiline = false;
    }

    var control;
    var options = {
        id: param.id,
        parent: parent,
        text: param.default
    };

    if (param.maxLength) {
        options.maxLength = param.maxLength;
    }

    if(multiline) {
        control = new Controls.Textarea(options);
    } else {
        control = new Controls.Textbox(options);
    }

    control.param = function (control) {
        return function () {
            return control.text;
        };
    }(control);

    parametermanager.setControl(param, control);
};


/**
The LabelParameterHandler class is a default Label Parameter Handler that handles Parameters with type = label. 
This handler sets the description in the layout for that particular parameter
@class LabelParameterHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IParameterHandler}
**/
var LabelParameterHandler = function () {
    IParameterHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary controls.
@method create
@param {Object} params Parameter JSON 
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LabelParameterJSON} params.definition The definition which is required to create the Label Parameter control.
@param {Controls.ParameterManager} parametermanager The instance of the ParameterManager which is using these handlers.
**/
LabelParameterHandler.prototype.create =function (params, parametermanager) {
    this.initialize(params, parametermanager);
    var param = params.definition;
    var parent = params.parent.contentArea;
    parent.text(param.description);
};

/**
The SketchParameterHandler class is a default Sketch Parameter Handler that handles Parameters with type = sketch. 
This handler creates an {Controls.Sketch2D}.
@class SketchParameterHandler
@namespace Controls
@since 1.1.0
@constructor
@extends {Controls.IParameterHandler}
**/
var SketchParameterHandler = function () {
    IParameterHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary controls.
@method create
@param {Object} params Parameter JSON 
    @param {Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.SketchParameterJSON} params.definition The definition which is required to create the Sketch Parameter control.
@param {Controls.ParameterManager} parametermanager The instance of the ParameterManager which is using these handlers.
**/
SketchParameterHandler.prototype.create =function (params, parametermanager) {
    this.initialize(params, parametermanager);
    var param = params.definition;
    var parent = params.parent.contentArea;

    var width = parent.outerWidth() * 0.9;
    var sketch = new Controls.Sketch2D({
        id: param.id,
        parent: parent,
        width: width,
        height: width,
        css: 'sketchControl'
    });
    if(param.default) {
       sketch.value = new CoreLibrary.Sketch2D(param.default);
    }
    sketch.param = function (control) {
        return function () {
            return control.value.clone();
        };
    }(sketch);

    params.parent.resize.bind((function(parent, sketch) {
        return function() {
            var width = parent.outerWidth() * 0.9;
            sketch.resize(width);
        };
    })(parent, sketch));

    parametermanager.setControl(param, sketch);
};


var initializeParameterHandlers = function () {
    var rangeHandler = new RangeParameterHandler();

    ParameterHandlers.addParameterHandler('angle', rangeHandler);
    ParameterHandlers.addParameterHandler('float', rangeHandler);
    ParameterHandlers.addParameterHandler('int', rangeHandler);
    ParameterHandlers.addParameterHandler('length', rangeHandler);

    ParameterHandlers.addParameterHandler('list', new ListParameterHandler());
    ParameterHandlers.addParameterHandler('bool', new BooleanParameterHandler());
    ParameterHandlers.addParameterHandler('sketch', new SketchParameterHandler());
    ParameterHandlers.addParameterHandler('string', new StringParameterHandler());
    ParameterHandlers.addParameterHandler('label', new LabelParameterHandler());
};


Controls.ParameterManager = ParameterManager;
Controls.IParameterHandler = IParameterHandler;
Controls.ParameterHandlers = ParameterHandlers;
/**   
Popup position Enum.
@enum PopupPositionEnum
@since 1.0.0
@see Controls.Popup
@static
@unlisted
**/
var PopupPositionEnum = {
    /**
    @property Top
    @readonly
    **/
    TOP:0,

    /**
    @property Right
    @readonly
    **/
    RIGHT:1,

    /**
    @property Bottom
    @readonly
    **/
    BOTTOM:2,

    /**
    @property Left
    @readonly
    **/
    LEFT:3
};


/**   
Popup parameters.
@class PopupParams
@since 1.0.0
@see Controls.Popup
@unlisted
**/
var PopupParams = function() {

    /**
    An id of the Popup Control.
    @property {String} id
    @default 'popupcontrol'
    **/
    this.id = undefined;

    /**
    Contents of the Popup Control.
    @property {HTMLELement} content
    **/
    this.content = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    Position of the Popup Control with respect to the target.
    @property {Controls.PopupPositionEnum} position
    **/
    this.position = undefined;

};

/**
A generic Popup control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Popup
@param {Controls.PopupParams} params Popup control parameters.
@param {HTMLElement} target The target control element on which the Popup will be displayed.
@namespace Controls
@extends Controls.BaseControl
@suppress blur, focus, keydown, keypress, keyup, enable, disable
@since 1.0.0
@constructor
@example
function CreatePopup() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    'id':'ctrlFeedback',
                    'parent': 'controlParent', // or $('#controlParent'),
                    'css': 'popupControl'
                };
            var popupControl = new controls.Popup(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Popup = function (params, target) {
    this._element = this._createControl(params);
    this._position = (params.position || PopupPositionEnum.TOP);
    this._target = $(target);
    BaseControl.extend(this);

    /**
    Popup content. A jQuery object of content element.
    @property {Object} content
    @public
    @readonly
    **/
    Object.defineProperty(this, "content",{
        get : function () {
            return this._element;
        },
        enumerable : true
    });
};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.PopupParams} params Popup control parameters 
@return {Object} jQuery object of Button control.
**/
Popup.prototype._createControl = function (params) {
    var id = params.id || 'popupControl';
    var content = params.content || '';
    var css = params.css || '';
    css = css + ' ui-popup-shadow-' + (params.position || PopupPositionEnum.TOP);
    var cornercss = 'ui-popup-corner-' + (params.position || PopupPositionEnum.TOP);

    var options = {
        'id': id,
        'content' : content,
        'css': css,
        'cornercss': cornercss
    };

    var parent = $('body');

    parent.append(Handlebars.templates['popup'](options));
    return parent.find('#' + id);
};

/** 
Initialize Popup
@private
@method onInitialize
**/
Popup.prototype.onInitialize = function () {
    var position = $(this._target).offset(), css = {};
    switch(this._position) {
        case PopupPositionEnum.TOP:
            css = {
                'top': position.top - this._element.height() - 10,
                'left': (position.left + this._target.width()/2) - this._element.width()/2
            };
            break;
        case PopupPositionEnum.BOTTOM:
            css = {
                'top': position.top + this._target.height() + 10,
                'left': (position.left + this._target.width()/2) - this._element.width()/2
            };
            break;
        case PopupPositionEnum.LEFT:
            css = {
                'top': position.top - (this._element.height()/2),
                'left': position.left - this._element.width() - 10
            };
            break;
        case PopupPositionEnum.RIGHT:
            css = {
                'top': position.top - (this._element.height()/2),
                'left': position.left + this._target.width() + 10
            };
            break;
    }
    this._element.css(css);
    this.show();
};

/** 
OnShow callback of show method of control
@private
@method onShow
**/
Popup.prototype.onShow = function () {
    var me = this;
    $(document).bind('mouseup.popupclick', function (e) {
        if (!me._element.is(e.target) && me._element.has(e.target).length === 0) {
            me.hide();
        }
    });
};

/** 
OnHide callback of hide method of control
@private
@method onHide
**/
Popup.prototype.onHide = function () {
    $(document).unbind('mouseup.popupclick');
};

Controls.Popup = Popup;
Controls.PopupPositionEnum = PopupPositionEnum;

/**   
Progressbar type enum.
@enum ProgressbarType
@since 1.5.0
@see Controls.Progressbar
@static
@unlisted
**/
var ProgressbarType = {
    Infinite: 0,
    Finite: 1
};

/**
An HTML Progressbar control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Progressbar
@param {Controls.DialogParams} params Progressbar control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.5.0
@constructor
@example
function CreateProgressbar() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var Controls = library.Controls;
            
            //Infinite progressbar
            Controls.Progressbar.instance().show({
                'title': 'Please wait',
                'description': 'Saving..',
                'blockUI': true
            });

            //Or set progress of control by passing progress in percentage, this will create finite progressbar
            //client need to set progress periodically
            Controls.Progressbar.instance().show({
                'percent': 20,
                'title': 'Please wait',
                'description': 'Saving..',
                'blockUI': true
            });

            Controls.Progressbar.instance().percent = 33;

        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var _Progressbar = function () {

    this._element = null;
    this._description = null;
    this._title = null;
    this._bar = null;
    this._infinitedialog = null;
    this._finitedialog = null;

    this._refCount = 0;
    this._isFiniteProgress = false;

    /**
    Set progress in percentage
    @property {Number} percent
    @public
    **/
    Object.defineProperty(this, "percent",{
        set : function (percent) {
            this._bar.css('width', percent + '%');
        },
        enumerable : true
    });

    /**
    Progressbar title
    @property {String} title
    @public
    **/
    Object.defineProperty(this, "title",{
        get : function () {
            return this._title.text();
        },
        set : function (text) {
            this._title.text(text);
        },
        enumerable : true
    });

    /**
    Progressbar description
    @property {String} description
    @public
    **/
    Object.defineProperty(this, "description",{
        get : function () {
            return this._descripton.text();
        },
        set : function (text) {
            this._descripton.text(text);
        },
        enumerable : true
    });

    BaseControl.call(this);
    this.initialize();
};

_Progressbar.prototype = Object.create(BaseControl.prototype, {
    constructor:{
        value:Progressbar
    }
});

/** 
Initialize progressbar
@private
@method onInitialize
**/
_Progressbar.prototype.onInitialize = function () {

    var args = {};
    args.id = 'progressdlg';
    args.progressTitle = '';
    args.progressDesc = '';

    var dialogStr = Handlebars.templates['progressbar'](args);

    this._parent = $('body');
    var dialog = $(dialogStr).prependTo(this._parent);
    this._element = $('#progressdlg');

    this._infinitedialog = $(this._element).find('#infinite');
    this._finitedialog = $(this._element).find('#finite');

    this._title = $(this._element).find('.ui-progressdialog-title');
    this._descripton = $(this._element).find('.ui-progressdialog-desc');
    this._bar = $(this._element).find('.ui-progressbar-fill');
    this.hide();
};

/** 
Change dialog type
@private
@method _changeDialogType
**/
_Progressbar.prototype._changeDialogType = function (type) {
    if (type == ProgressbarType.Finite) {
        this._element.addClass('ui-progressdialog-finite').removeClass('ui-progressdialog-infinite');
        this._infinitedialog.hide();
        this._finitedialog.show();
    } else {
        this._element.addClass('ui-progressdialog-infinite').removeClass('ui-progressdialog-finite');
        this._infinitedialog.show();
        this._finitedialog.hide();
    }
};

/** 
Show progressbar
@method showDialog
@param {Object} params Progressbar's initial parameters.
@examples
//Infinite progressbar
Progressbar.instance().showDialog(
{
    'title': 'Please wait',
    'description': 'Saving file..',
    'blockUI': true,
    'priority': 1
});

//Finite progressbar
Progressbar.instance().showDialog(
{
    'percent': 20,
    'title': 'Please wait',
    'description': 'Saving file..',
    'blockUI': true,
    'priority': 1
});

//And update UI based on progress
Progressbar.getInstance().percent = 33;

**/
_Progressbar.prototype.show = function (params) {
    if (++this._refCount == 1) {
        if (params.blockUI) {
            if (!this._blockid) {
                this._blockid = BlockUI.create(this._element, params.priority);
            }
            this._blockid.blockDialog();
            $(this._element).show();
        }
        else {
            $(this._element).show();
        }
        if(params.title) this.title = params.title; else this.title = 'Please wait';
        if(params.description) this.description = params.description; else this.description = '';
        if(params.percent) {
            this.percent = params.percent;
            this._changeDialogType(ProgressbarType.Finite);
        } else {
            this._changeDialogType(ProgressbarType.Infinite);
        }
    }
    this.onShow();
};

/** 
Hide progressbar.
@method hideDialog
**/
_Progressbar.prototype.hide = function () {
    if (--this._refCount <= 0) {
        $(this._element).hide();
        this._refCount = 0;
        if (this._blockid) {
            this._blockid.unblock();
            delete this._blockid;
        }
    }
    this.onHide();
};

/** 
Set progressbar parent.
@method setParent
@param {Object} parent jQuery or HTMLElement object.
@default body
**/
_Progressbar.prototype.setParent = function (parent) {
    parent = $(parent);
    if (this._parent != parent) {
        var dlg = $(this._element).detach();
        dlg.appendTo(parent);
        this._parent = parent;
    }
};

var Progressbar = (function () {
    var instance;
    return {
        instance: function () {

            if ( !instance ) {
                instance = new _Progressbar();
            }
            return instance;
        }
    };
 
})();

Controls.Progressbar = Progressbar;
/**   
Rating control parameters.
@class RatingParams
@since 1.0.0
@see Controls.Rating
@unlisted
**/
var RatingParams = function(){

    /**
    An id of rating control.
    @property {String} id
    @default 'rating'
    **/
    this.id = undefined;

    /**
    Parent of rating control. Pass valid id or jQuery object of parent.
    If parent is not set then Rating control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    External css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    Enable star count. It must be less than or equal to max.
    @property {Number} rating
    @default 0
    **/
    this.rating = undefined;

    /**
    Maximum rating count. Max rating must be greater than or equal to rating.
    @property {Number} max
    @default 5
    **/
    this.max = undefined;

    /**
    Total number of ratings. Only applicable if control is readonly.
    @property {Number} reviewCount
    @default 0
    **/
    this.reviewCount = undefined;

    /**
    Rating control mode.
    @property {Boolean} readonly
    @default true
    **/
    this.readonly = undefined;

};

/**
An HTML rating control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Rating
@param {Controls.RatingParams} params Rating control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.0.0
@constructor
@example
function CreateRating() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            //Readonly
            var readonlyRatingCtrl = new controls.Rating({
                id: 'ratingCtrl',
                parent: 'ratingExample',
                rating: 3, //initial rating
                max: 5,
                reviewCount: 7, //total reviews
                readonly: true
            });
            //Editable
            var editableRatingCtrl = new controls.Rating({
                id: 'ratingCtrl',
                parent: 'ratingExample',
                rating: 5, //initial rating
                max: 5,
                readonly: false
            });
            editableRatingCtrl.change.bind(function () {
                $('#ratingMessage').text('Your rating:' + editableRatingCtrl.rating);        
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Rating = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    this._rating = 0;
    if(params.rating) this._rating = params.rating;

    this._reviewCount = 0;
    if(params.reviewCount) this._reviewCount = params.reviewCount;

    this._readonly = true;
    if(params.readonly !== undefined) this._readonly = params.readonly;
    BaseControl.extend(this);

    /**
    Enable star count.
    @property {Number} rating
    @public
    **/
    Object.defineProperty(this, "rating",{
        get : function () {
            return parseInt(this._rating);
        },
        set : function (rating) {
            this._rating = rating;
            this._updateRatingUI();
        },
        enumerable : true
    });

    /**
    Total number of ratings.
    @property {Number} reviewCount
    @public
    **/
    Object.defineProperty(this, "reviewCount",{
        get : function () {
            return this._reviewCount;
        },
        set : function (count) {
            this._reviewCount = count;
            this._updateReviewUI();
        },
        enumerable : true
    });

    /**
    Rating control mode.
    @property {Boolean} readonly
    @readonly
    @public
    **/
    Object.defineProperty(this, "readonly",{
        get : function () {
            return this._readonly;
        },
        enumerable : true
    });

    /**
    Fires when rating changes.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');
    this._bindEvent('change');

    /**
    Fires when review count link is clicked.
    @event reviewclick
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.reviewclick = new CoreLibrary.EventSource('reviewclick');
    
};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.RatingParams} params Rating control parameters 
@return {Object} jQuery object of Rating control.
**/
Rating.prototype._createControl = function (params) {
    var id = params.id || 'rating';
    var css = params.css || '';
    var readonly = params.readonly || false;
    var rating, max, reviewCount;
    if(readonly) {
        rating = params.rating || 0;
        max = (params.max || 5) - rating;
        reviewCount = params.reviewCount || 0;
    } else {
        max = params.max || 5;
        rating = params.rating || 5;
    }
    
    var options = {
        id: id,
        css: css,
        rating: rating,
        max: max,
        reviewCount: reviewCount,
        readonly: readonly
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['rating'](options));
    return parent.find('#' + id);
};

/** 
Initialize rating
@private
@method onInitialize
**/
Rating.prototype.onInitialize = function () {
    this._reviewLink = this._element.find('.rating-count > a');
    this._bindRadioEvents();
};

/** 
Bind radio events
@private
@method _bindRadioEvents
**/
Rating.prototype._bindRadioEvents = function () {
    var me = this;
    if(!this._readonly) {
        this._element.find(':radio[value=' + this._rating + ']').attr('checked', 'checked');
        this._element.find('input[type="radio"]').bind('change', function () {
           me._rating = $(this).val();
           me.change.fire();
        });
    }
    this._reviewLink.bind('click', function (e) {
       me.reviewclick.fire();
       e.preventDefault();
       e.stopPropagation();
    });

};

/** 
Update rating ui.
@private
@method _updateRatingUI
**/
Rating.prototype._updateRatingUI = function () {
    if(!this._readonly) {
        this._element.find(':radio[value=' + this._rating + ']').attr('checked', 'checked');
    } else {
        var me = this;
        var stars = this._element.find('.rating-stars-marked, .rating-stars-unmarked');
        stars.removeClass('rating-stars-marked').removeClass('rating-stars-unmarked').each(function (index, div) {
            if(index < me._rating) {
                $(div).addClass('rating-stars-marked');
            } else {
                $(div).addClass('rating-stars-unmarked');
            }
        });
    }
};

/** 
Update review ui.
@private
@method _updateReviewUI 
**/
Rating.prototype._updateReviewUI = function () {
    this._reviewLink.text('(' + this._reviewCount + (this._reviewCount <= 1 ? ' Review)' : ' Reviews)'));
};

/** 
Virtual function implementation.
@private
@method onEnable
**/
Rating.prototype.onEnable = function () {
    this._element.find(':radio').removeAttr('disabled');
};

/** 
Virtual function implementation.
@private
@method onDisable
**/
Rating.prototype.onDisable = function () {
    this._element.find(':radio').attr('disabled', 'disabled');
};

/** 
Bind a Rating control to specific dom element 
@method bind
@public
@param {Object} rating A DOM or jQuery object to which you want to bind this Rating object. 
@param {Controls.RatingParams} params Control's initial params.
    @param {Number} params.rating Initial rating.
    @param {Number} params.reviewCount Initial review count.
    @param {Boolean} params.readonly Rating control mode.
@return {Controls.Rating}
**/
Rating.bind = function (rating, params) {
	var ctrl = new Rating(rating);
    if(params && params.rating !== undefined) {
        ctrl._rating = params.rating;
        ctrl._updateRatingUI();
    }
    if(params && params.readonly !== undefined) {
        ctrl._readonly = params.readonly;
        ctrl._bindRadioEvents();
    }
    if(params && params.reviewCount !== undefined) ctrl._reviewCount = params.ratingCount;
    return ctrl;
};

Controls.Rating = Rating;

/**
The Resize grip direction enum
@enum ResizeGripEnum
@static
@unlisted
**/
var ResizeGripEnum = {
    
    /**
    @property North
    @readonly
    **/
    North : 'n',
    
    /**
    @default 's'
    @property South
    @readonly
    **/
    South : 's',

    /**
    @default 'e'
    @property East
    @readonly
    **/
    East : 'e',
    
    /**
    @property West
    @readonly
    **/
    West : 'w',

    /**
    @property NorthWest
    @readonly
    **/
    NorthWest : 'nw',

    /**
    @property NorthEast
    @readonly
    **/
    NorthEast : 'ne',

    /**
    @default 'se'
    @property SouthEast
    @readonly
    **/
    SouthEast : 'se',

    /**
    @property SouthWest
    @readonly
    **/
    SouthWest : 'sw'

};

/**   
Resizable control parameters.
@class ResizableParams
@since 1.0.0
@see Controls.Resizable
@unlisted
**/
var ResizableParams = function(){

    /**
    Risable control.
    @property {String|Object} control An id of control or jQuery object of dom element.
    **/
    this.control = undefined;

    /**
    Resizable grips.
    @property {Array[Controls.ResizeGripEnum]} grips
    **/
    this.grips = undefined;

    /**
    The maximum width the resizable should be allowed to resize to.
    @property {Number} maxWidth
    **/
    this.maxWidth = undefined;

    /**
    The maximum height the resizable should be allowed to resize to.
    @property {Number} maxHeight
    **/
    this.maxHeight = undefined;

    /**
    The minimum width the resizable should be allowed to resize to.
    @property {Number} minWidth
    @default 10
    **/
    this.minWidth = undefined;

    /**
    The minimum height the resizable should be allowed to resize to.
    @property {Boolean} minHeight
    @default 10
    **/
    this.minHeight = undefined;

};

/**
An HTML control that provides resizable behavior with size constraints. For an interactive demonstration please see: {Interactive Control Demos}.

@class Resizable
@param {Controls.ResizableParams} params Resizable parameters.
@namespace Controls
@since 1.0.0
@extends Controls.BaseControl
@suppress blur, focus, enable, disable
@constructor
@example
function BindResizable() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    control: 'controlid', // $('#control')
                    grips: [
                        controls.ResizeGripEnum.South,
                        controls.ResizeGripEnum.East,
                        controls.ResizeGripEnum.SouthEast], 
                    minHeight: 50, 
                    minWidth: 50, 
                    maxHeight:300, 
                    maxWidth: 300    
                };
            controls.Resizable.bind(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Resizable = function (params) {
    if(typeof params.control === 'string') {
        this._element = $('#' + params.control);
    } else {
        this._element = $(params.control);
    }
    BaseControl.extend(this);

    this._animate = false;
    if(params.animate != undefined)
        this._animate = params.animate;

    this._grips = [
        ResizeGripEnum.South,
        ResizeGripEnum.East,
        ResizeGripEnum.SouthEast
    ];
    if(params.grips)
        this._grips = params.grips;

    this._maxHeight = null;
    if(params.maxHeight)
        this._maxHeight = params.maxHeight;

    /**
    Gets or sets the max height of resizable control. 
    @property {Number} maxHeight
    **/
    Object.defineProperty(this, "maxHeight",{
        get : function () {
            return this._maxHeight;
        },
        set : function (height) {
            this._maxHeight = height;
        },
        enumerable : true
    });

    this._minHeight = 10;
    if(params.minHeight)
        this._minHeight = params.minHeight;

    /**
    Gets or sets the min height of resizable control. 
    @property {Number} minHeight
    @default 10
    **/
    Object.defineProperty(this, "minHeight",{
        get : function () {
            return this._minHeight;
        },
        set : function (height) {
            this._minHeight = height;
        },
        enumerable : true
    });
    
    this._maxWidth = null;
    if(params.maxWidth)
        this._maxWidth = params.maxWidth;

    /**
    Gets or sets the max width of resizable control. 
    @property {Number} maxWidth
    **/
    Object.defineProperty(this, "maxWidth",{
        get : function () {
            return this._maxWidth;
        },
        set : function (width) {
            this._maxWidth = width;
        },
        enumerable : true
    });
    
    this._minWidth = 10;
    if(params.minWidth)
        this._minWidth = params.minWidth;

    /**
    Gets or sets the min width of resizable control. 
    @property {Number} minWidth
    @default 10
    **/
    Object.defineProperty(this, "minWidth",{
        get : function () {
            return this._minWidth;
        },
        set : function (width) {
            this._minWidth = width;
        },
        enumerable : true
    });

    this._zIndex = 10;
    if(params.zIndex)
        this._zIndex = params.zIndex;
    /**
    Gets or sets the z-index of resizable control. 
    @property {Number} zIndex
    @default 10
    **/
    Object.defineProperty(this, "zIndex",{
        get : function () {
            return this._zIndex;
        },
        set : function (zindex) {
            this._zIndex = zindex;
        },
        enumerable : true
    });

    this._resizing = false;
    this._activeGrip = null;

    this._change = {
        e: function(event, dx) {
            return { width: this._dragStartSize.width + dx};
        },
        w: function(event, dx) {
            var ss = this._dragStartSize, sp = this._dragStartPosition;
            return { left: sp.left + dx, width: ss.width - dx };
        },
        n: function(event, dx, dy) {
            var ss = this._dragStartSize, sp = this._dragStartPosition;
            return { top: sp.top + dy, height: ss.height - dy };
        },
        s: function(event, dx, dy) {
            return { height: this._dragStartSize.height + dy };
        },
        se: function(event, dx, dy) {
            return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
        },
        sw: function(event, dx, dy) {
            return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
        },
        ne: function(event, dx, dy) {
            return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
        },
        nw: function(event, dx, dy) {
            return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
        }
    };

    /**
    Fires during resize.
    @event resize
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.resize = new CoreLibrary.EventSource('resize');

    /**
    Fires when resize starts.
    @event beginresize
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.beginresize = new CoreLibrary.EventSource('beginresize');

    /**
    Fires when resize ends.
    @event endresize
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.endresize = new CoreLibrary.EventSource('endresize');
    
    this._initialize();
};

/** 
Initialize control
@private
@method _initialize
**/
Resizable.prototype._initialize = function () {
    this._element.addClass("ui-resizable");
    this._addGrips();
    this._bindEvents();
};

/** 
Add resize grips
@private
@method _addGrips
**/
Resizable.prototype._addGrips = function () {
    for (var i = this._grips.length - 1; i >= 0; i--) {
        this._element.append($('<div style="z-index:' + this._zIndex + '" />').addClass('ui-resizable-' + this._grips[i] + ' grip').data('grip', this._grips[i]));
    }
};

/** 
Bind mouse events
@private
@method _bindEvents
**/
Resizable.prototype._bindEvents = function () {
    var me = this;
    this.mouseup.bind(function(e) {
        me._stop();
    });

    var num = function (value) {
        return parseInt(value, 10) || 0;
    };

    this.mousedown.bind(function(event) {
        var e = event._originalEvent;
        if($(e.target).hasClass('grip')) {
            $(document).bind('mousemove.resizableEvent', function(e) {
                if(me._resizing) {
                    me._resize(e);
                    me.resize.fire();
                    e.preventDefault();
                }
            }).bind('keyup.resizableEvent', function(e) {
                if (e.keyCode === 27) {
                    me._stop();
                }
            }).bind('mouseup.resizableEvent', function(e) {
                me._stop();
            });

            me._resizing = true;
            me._activeGrip = $(e.target).data('grip');
            
            me._dragStartSize = { width: me._element.width(), height: me._element.height() };
            
            var top =  (/relative/).test(me._element.css('position')) ? num(me._element.css('top')) : me._element.offset().top;
            var left = (/relative/).test(me._element.css('position')) ? num(me._element.css('left')) : me._element.offset().left;

            me._dragStartPosition = { left: left, top: top };
            me._dragStartMousePosition = { x: e.pageX, y: e.pageY };

            me._resize(e);
            e.preventDefault();
            me.beginresize.fire();
        }
    });
};

/** 
Release grip and stop resizing
@private
@method _stop
**/
Resizable.prototype._stop = function() {
    if(this._resizing) {
        this._resizing = false;
        this._activeGrip = null;
        $(document).unbind('keyup.resizableEvent').unbind('mousemove.resizableEvent').unbind('mouseup.resizableEvent');
        this.endresize.fire();
    }
};

/** 
Correct sizes according to min-max height & width if supplied.
@private
@method _correctSize
**/
Resizable.prototype._correctSize = function(css) {
    var utility = Utility;
    if(utility.isNumber(this._minWidth) || utility.isNumber(this._maxWidth)) {
        var ismaxw = utility.isNumber(css.width) && this._maxWidth && (css.width >= this._maxWidth),
            isminw = utility.isNumber(css.width) && this._minWidth && (css.width <= this._minWidth),
            dragWidth = this._dragStartPosition.left + this._dragStartSize.width,
            gripWidth = /sw|nw|w/.test(this._activeGrip);
        if (isminw) {
            css.width = this._minWidth;
        }
        if (ismaxw) {
            css.width = this._maxWidth;
        }
        if (isminw && gripWidth) {
            css.left = dragWidth - this._minWidth;
        }
        if (ismaxw && gripWidth) {
            css.left = dragWidth - this._maxWidth;
        }
    }
    if(utility.isNumber(this._minHeight) || utility.isNumber(this._maxHeight)) {
        var ismaxh = utility.isNumber(css.height) && this._maxHeight && (css.height >= this._maxHeight),
            isminh = utility.isNumber(css.height) && this._minHeight && (css.height <= this._minHeight),
            dragHeight = this._dragStartPosition.top + this._dragStartSize.height,
            gripHeight = /nw|ne|n/.test(this._activeGrip);
        if (isminh) {
            css.height = this._minHeight;
        }
        if (ismaxh) {
            css.height = this._maxHeight;
        }
        if (isminh && gripHeight) {
            css.top = dragHeight - this._minHeight;
        }
        if (ismaxh && gripHeight) {
            css.top = dragHeight - this._maxHeight;
        }
    }

    return css;
};

/** 
Resize control on mouse move
@private
@method _resize
**/
Resizable.prototype._resize = function(e) {
    var dp = this._dragStartMousePosition;
    var dx = (e.pageX-dp.x)||0;
    var dy = (e.pageY-dp.y)||0;
    this._element.css(this._correctSize(this._change[this._activeGrip].apply(this, [e, dx, dy])));
};

/** 
Bind a Resizable control to specific dom element
@method bind
@public
@param {Controls.ResizableParams} params Resizable control parameters.
@return {Controls.Resizable}
**/
Resizable.bind = function (params) {
	return new Resizable(params);
};

Controls.Resizable = Resizable;
Controls.ResizeGripEnum = ResizeGripEnum;



 /**   
Slider control parameters.
@class SliderParams
@since 1.1.0
@see Controls.Slider
@unlisted
**/
var SliderParams = function(){

    /**
    Id of the slider control.
    @property {String} id
    @default 'slider'
    **/
    this.id = undefined;

    /**
    Parent of the slider control. Requires valid id or jQuery object of parent.
    If parent is not set then the Slider control will be appended to the body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Specifies whether the value of the slider should be displayed.
    @property {Boolean} showText
    **/
    this.showText = undefined;

    /**
    Specifies the unit in which the value needs to be displayed. 
    Setting this requires showText to be set true.
    @property {String} displayUnit
    @default 'mm'
    **/
    this.displayUnit = undefined;

    /**
    Specifies the minimum value of the slider.
    @property {Number} min
    @default 0
    **/
    this.min = undefined;

    /**
    Specifies the maximum value of the slider.
    @property {Number} max
    @default 100
    **/
    this.max = undefined;

    /**
    Sets the allowable values for the input. If an array is provided, all the values within the array are the only valid values (excluding the min and max values).
    When a number is set, the valid range is the multiple of the number with the min until the max. 
    If this is set to undefined (default), all possible values are valid.
    @property {Number|Array[Number]} steps
    @default undefined
    **/
    this.steps = undefined;

    /**
    Sets the visual ticks for the input. The ticks are shown for the values provided within the array. The values should like within the min and max range.
    @property {Array[Number]} ticks
    @default undefined
    **/
    this.ticks = undefined;

    /**
    Specifies if an input box needs to be displayed along with the display Label. Setting this to true will allow the users to click on the display label to key
    in the value. Setting this to true will not have any effect if the showText property is set to false.
    @property {Boolean} showInput
    @default undefined
    @since 1.2.0
    **/
    this.showInput = undefined;

    /**
    Specifies the orientation of the Slider. A horizontal slider is created by default if no value is passed in.
    @property {Controls.SliderOrientationEnum} orientation
    @default {Controls.SliderOrientationEnum.Horizontal}
    @since 1.3.0
    **/
    this.orientation = undefined;
};

/**
Creates a Slider control to provide range based input.  
For an interactive demonstration please see: {Interactive Control Demos}.

@class Slider
@param {Controls.SliderParams} params Slider control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.1.0
@constructor
@example
function CreateSlider() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var panel = new controls.Slider({
                id:'sliderControl'
            });
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Slider = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    BaseControl.extend(this);

    /**
    Fires when the slider value change is initiated.
    @event beginchange
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.beginchange = new CoreLibrary.EventSource('beginchange');

    /**
    Fires when slider value is being changed
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

    /**
    Fires when the slider value change is completed.
    @event endchange
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.endchange = new CoreLibrary.EventSource('endchange');

    var sliderhandle = $(this._element).find('.ui-slider-handle');
    var sliderhandleicon = $(this._element).find('.ui-slider-icon');

    var sliderarea = $(this._element).find('.ui-slider-area');
    var sliderbackground = $(this._element).find('.ui-slider-background');

    var slidertextlabel = $(this._element).find('.ui-slider-text');
    var slidertextinput = $(this._element).find('.ui-slider-input');

    var min = params.min || 0;
    var max = params.max || 1;

    var upperlimit = max-min;

    var steps = params.steps;
    var steparray;
    var ticks = params.ticks;

    var showtext = params.showText;
    var displayUnit = params.displayUnit ? true : false;
    var unit = params.displayUnit || 'mm';

    this.isVertical = params.orientation === 'vertical' ? true : false;

    var me=this;

    this._value = min;

    var _onInputFocusOut = function () {
        me._inputTextbox.hide();
        slidertextlabel.show();
    };

    var _onInputTextKeyDown = function (e) {
        if(e.originalEvent.keyCode === 13 || e.originalEvent.keyCode === 27) {
            var value = displayUnittoInternalUnit(me._inputTextbox.text);
            setSliderPosition(valueToAbsPosition(value));
            _onInputFocusOut();
        }
    };


    if(slidertextinput.size()) {
        this._inputTextbox = Controls.Textbox.bind(slidertextinput);
        me._inputTextbox.keydown.bind(_onInputTextKeyDown);
        me._inputTextbox.focusout.bind(_onInputFocusOut);
    }

    slidertextlabel.bind('click', function () {
        if(me._inputTextbox) {
            displayText(me._value);
            slidertextlabel.hide();
            me._inputTextbox.show();
            me._inputTextbox.select();
            me._inputTextbox.focus();
        }
    });

    /**
    Get or set the value of the slider.
    @property {String} value
    @public
    **/
    Object.defineProperty(this, "value",{
        get : function () {
            return Number(me._value.toFixed(12));
        },
        set : function (value) {
            removeTransitionEffect();
            setSliderPosition(valueToAbsPosition(value));
            setTimeout(function () {
                addTransitionEffect();
            }, 500);
            
        },
        enumerable : true
    });

    var left, startPosition, dragging;

    if(steps !== undefined) {
        if(steps instanceof Array) {
            steparray = steps;
            if(steparray.indexOf(min) < 0 ){
                steparray.unshift(min);
            }
            if(steparray.indexOf(max) < 0) {
                steparray.push(max);
            }
        } else {
            steparray = [min];
            var step = min;
            do {
                step = step + steps;
                steparray.push(step);
            } while(step < max);
        }
    }

    var displayUnittoInternalUnit = function (value) {
            switch(unit) {
                case 'ft':
                    value = value * 304.8;
                break;
                case 'in':
                    value = value * 25.4;
                break;
                case 'm':
                    value = value * 1000;
                break;
                case 'cm':
                    value = value * 10;
                break;
            }
        return value;
    };

    var addTransitionEffect = function () {
        removeTransitionEffect();
        var handleCSSString = "left 0.5s ease-in-out";
        var backgroundCSSString = "width 0.5s ease-in-out";
        if(me.isVertical) {
            handleCSSString = "top 0.5s ease-in-out";
            backgroundCSSString = "height 0.5s ease-in-out";
        }
         sliderhandle.css({
            "transition": handleCSSString,
            "-webkit-transition": handleCSSString,
            "-moz-transition": handleCSSString,
            "-o-transition": handleCSSString,
        });
        sliderbackground.css({
            "transition": backgroundCSSString,
            "-webkit-transition": backgroundCSSString,
            "-moz-transition": backgroundCSSString,
            "-o-transition": backgroundCSSString,
       });
    };

    var removeTransitionEffect = function () {
        sliderhandle.css({
            "transition": "",
            "-webkit-transition": "",
            "-moz-transition": "",
            "-o-transition": "",
        });
        sliderbackground.css({
            "transition": "",
            "-webkit-transition": "",
            "-moz-transition": "",
            "-o-transition": "",
        });
    };

    var valueToAbsPosition = function (value) {
        var maximum = sliderarea.width();
        if(me.isVertical) {
            maximum = sliderarea.height();
            maximum = maximum > 0 ? maximum : 10;
            return (((((max + min) - value) - min) * maximum) / upperlimit);
        }
        else
        {
            maximum = maximum > 0 ? maximum : 10;
            return ((value - min) * maximum) / upperlimit;
        }
    };

    var absPositionToPercentage = function (absposition) {
        var maximum = sliderarea.width();
        if(me.isVertical) {
            maximum = sliderarea.height();
        }
        maximum = maximum > 0 ? maximum : 10;
        return (absposition / maximum) * 100;
    };

    var nearestStepValue = function (value) {
        if(!steparray || steparray.length === 0) return value;
        var stepcount = steparray.length;
        var closest;
        var smallestdiff;
        for(var i=0;i<stepcount;i++) {
            var step = steparray[i];
            var diff = Math.abs(step-value);
            if(smallestdiff === undefined || diff <= smallestdiff) {
                smallestdiff = diff;
                closest = step;
            }
        }
        return closest;
    };

    var displayText = function (value) {
        if(showtext) {
            switch(unit) {
                case 'ft':
                    value = value / 304.8;
                break;
                case 'in':
                    value = value / 25.4;
                break;
                case 'm':
                    value = value / 1000;
                break;
                case 'cm':
                    value = value / 10;
                break;
            }
            var val = Number(value.toFixed(2));
            var text;
            if(displayUnit) {
                text = val + ' ' + unit;
            } 
            else {
                text = val;
            }
            slidertextlabel.text(text);
            
            if(me._inputTextbox) {
                me._inputTextbox.text = val;
            }
        }
    };

    var addTicks = function () {
        var tickcount = ticks.length;

        var prev = 0;
        for (var i = 0; i < tickcount; i++) {
            var current = absPositionToPercentage(valueToAbsPosition(ticks[i]));
            var difference = current - prev;
            var stepdiv;
            if(me.isVertical) {
                stepdiv = $('<div class="ui-slider-step" />').css({
                    'top':current + '%'
                });
            } else {
                stepdiv = $('<div class="ui-slider-step" />').css({
                    'width': difference + '%',
                    'left': prev + '%'
                });
            }

            sliderarea.append(stepdiv);
            prev = prev + difference;
        }
    };
    if(ticks) addTicks();
    
    var setSliderPosition = function (position) {
        var maximum = sliderarea.width();
        if(me.isVertical) {
            maximum = sliderarea.height();
        }
        maximum = maximum > 0 ? maximum : 10;
        if(position < 0) position = 0;
        if(position > maximum) position = maximum;


        var val, percentageVal, nearestval;

        if(me.isVertical) {
            val = (max + min) - (min + (position/maximum) * upperlimit);
            nearestval = nearestStepValue(val);
            me._value = nearestval;
            
           // val = min + (position/maximum) * upperlimit;
            

            percentageVal = absPositionToPercentage(valueToAbsPosition(nearestval));
            sliderhandle.css('top', percentageVal + '%');
            sliderbackground.css("height" , (100 - percentageVal) + '%');
        } else {
            val = min + (position/maximum) * upperlimit;
            nearestval = nearestStepValue(val);
            me._value = nearestval;
            percentageVal = absPositionToPercentage(valueToAbsPosition(nearestval));
            sliderhandle.css('left', percentageVal + '%');
            sliderbackground.css("width" , percentageVal + '%');
        }
       
        displayText(nearestval);
    };

    var mouseMove = function (event) {
        if(dragging !== true) { return; }
        
        removeTransitionEffect();
        event.preventDefault();
        var delta;
        if(me.isVertical) {
            delta = event.clientY - startPosition;
        } else {
            delta = event.clientX - startPosition;
        }
        
        setSliderPosition(delta);
      
        me.change.fire();

    };

    var mouseUp = function (event) {
        if(dragging === true) {
            dragging = false;
            event.preventDefault();
            document.removeEventListener('mousemove', mouseMove);
            document.removeEventListener('mouseup', mouseUp);

            me.endchange.fire();
            addTransitionEffect();
        }
    };

    sliderhandle[0].addEventListener("mousedown", function(ev) {
        ev = ev || window.event;

        var startMargin;
        if(me.isVertical) {
            startMargin = sliderhandle.outerHeight(true) - sliderhandle.outerHeight(false);
            startPosition = ev.clientY - this.offsetTop + startMargin;
        } else {
            startMargin = sliderhandle.outerWidth(true) - sliderhandle.outerWidth(false);
            startPosition = ev.clientX - this.offsetLeft + startMargin;
        }

        dragging = true;

        document.addEventListener('mousemove', mouseMove);
        document.addEventListener('mouseup', mouseUp);

        me.beginchange.fire();

    });
    
    sliderarea[0].addEventListener("click", function (event) {
        var delta;
        if(me.isVertical) {
            delta = event.offsetY===undefined?event.layerY:event.offsetY;
            if($(event.target).hasClass('ui-slider-step') || $(event.target).hasClass('ui-slider-background')) {
                delta = delta + $(event.target).position().top;
            }
        }
        else {
            delta = event.offsetX===undefined?event.layerX:event.offsetX;
            if($(event.target).hasClass('ui-slider-step')) {
                delta = delta + $(event.target).position().left;
            }
        }

        if(event.target === sliderhandle[0] || event.target === sliderhandleicon[0]) {
            return;
        }

        me.beginchange.fire();
        setSliderPosition(delta);
    });

    addTransitionEffect();
    
    sliderhandle.bind('transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd', function() {
         me.change.fire();
         me.endchange.fire();
    });
};

/** 
Create control from handlebar template.
@private
@method _createControl
@return {Object} jQuery object of Slider control.
**/
Slider.prototype._createControl = function (params) {
    var orientation = params.orientation || 'horizontal';
    var id = params.id || 'slider';
    var css = params.css || '';
    var showtext = params.showText;
    var showinput = params.showInput;
   
    var options = {
        id: id,
        showtext: showtext,
        css: css + ' ' +  'ui-' + orientation + '-slider'
    };

    if(showinput) {
        options.input = {
            id: id +'-input',
            css: 'ui-slider-input'
        };
    }

    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else
        parent = $(params.parent);

    parent.append(Handlebars.templates['slider'](options));
    return parent.find('#' + id);
};

/**
Slider Orientation Enum
@enum SliderOrientationEnum
@static
@type String
@since 1.3.0
@see Controls.Slider
@unlisted
**/
var SliderOrientationEnum = {
    /**
    @default 'horizontal'
    @property Horizontal
    @readonly
    **/
    Horizontal: 'horizontal',

    /**
    @default 'vertical'
    @property Vertical
    @readonly
    **/
    Vertical: 'vertical'
};


Controls.Slider = Slider;
Controls.SliderOrientationEnum = SliderOrientationEnum;
/**   
Tab control parameters.
@class TabParams
@since 1.0.0
@see Controls.Tab
@unlisted
**/
var TabParams = function(){

    /**
    An id of tab control.
    @property {String} id
    @default 'tab'
    **/
    this.id = undefined;

    /**
    Parent of tab control. Pass valid id or jQuery object of parent.
    If parent is not set then Tab control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Tab control header text.
    @property {String} tabHeader
    **/
    this.tabHeader = undefined;

    /**
    Pass tab class as string or json object containing classes for sub elements.
    @property {String|Object} css
    @example 
    //Class name as string or json structure as below,
    {
        'tabCss': 'tabClass',
        'headerCss': 'headerClass',
        'contentCss': 'contentClass',
    }
    **/
    this.css = undefined;

    /**
    Json array of tabs.
    @property {Object} tabs
    @example
    {'tab1': {
        'tabid': 'tab1',
        'headerText': 'Tab1',
        'headerImageStyle' : 'tab1imageclass', //headerImageStyle is an optional property
        'tabContent': 'Tab1 content' //tabContent is an optional property
    },
    'tab2': {
        'tabid': 'tab2',
        'headerText': 'Tab2',
        'headerImageStyle' : 'tab2imageclass', //headerImageStyle is an optional property
        'tabContent': 'Tab2 content' //tabContent is an optional property
    },
    'tab3': {
        'tabid': 'tab3',
        'headerText': 'Tab3',
        'headerImageStyle' : 'tab3imageclass', //headerImageStyle is an optional property
        'tabContent': 'Tab3 content' //tabContent is an optional property
    }}
    **/
    this.tabs = undefined;

};

/**
An HTML tab control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Tab
@param {Controls.TabParams} params Tab control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.0.0
@constructor
@example
function CreateTab() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {};
            params.id = 'tabControl';
            params.parent = 'tabExample';
            params.css = {};
            params.css.headerCss = "headerCss";
            params.css.contentCss = "tabExampleContent";

            params.tabs = {'tab1': {
                'tabid': 'tab1',
                'headerText': 'Tab1',
                'headerImageStyle' : 'tab1imageclass', //headerImageStyle is an optional property
                'tabContent': 'Tab1 content' //tabContent is an optional property
            },
            'tab2': {
                'tabid': 'tab2',
                'headerText': 'Tab2',
                'headerImageStyle' : 'tab2imageclass', //headerImageStyle is an optional property
                'tabContent': 'Tab2 content' //tabContent is an optional property
            },
            'tab3': {
                'tabid': 'tab3',
                'headerText': 'Tab3',
                'headerImageStyle' : 'tab3imageclass', //headerImageStyle is an optional property
                'tabContent': 'Tab3 content' //tabContent is an optional property
            }};

            var tabControl = new controls.Tab(params);

        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Tab = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    this._selectedTab = undefined;
    this._tabHeaders = [];
    this._tabPages = [];

    /**
    Selected tab index.
    @property {Number} selectedTabIndex
    @public
    **/
    Object.defineProperty(this, "selectedTabIndex",{
        get : function () {
            return $(this._selectedTab).index();
        },
        set : function (index) {
            if(index >= 0) {
                this._selectTab(index);
            }
        },
        enumerable : true
    });

    /**
    Selected tab id.
    @property {String} selectedTabId
    @public
    **/
    Object.defineProperty(this, "selectedTabId",{
        get : function () {
            return $(this._selectedTab).attr('Tab');
        },
        set : function (id) {
            id = $.trim(id);
            if(id != '') {
                var rawTabHeaderCount = this._tabHeaders.length;
                for (var i = 0; i < rawTabHeaderCount; i++) {
                    if($(this._tabHeaders[i]).attr('Tab') === id) {
                        this._selectTab($(this._tabHeaders[i]).index());
                        break;
                    }
                }
            }
        },
        enumerable : true
    });

    /**
    Selected tab content element. Return an html element of tab content.
    @property {Object} selectedTabContent
    @readonly
    @public
    **/
    Object.defineProperty(this, "selectedTabContent",{
        get : function () {
            return this._element.find('#' + $(this._selectedTab).attr('id'))[0];
        },
        enumerable : true
    });

    /**
    Tab pages. An array containing all the tab page elements.
    @property {Array[HTMLElement]} tabPages
    @public
    @readonly
    **/
    Object.defineProperty(this, "tabPages",{
        get : function () {
            return this._tabPages;
        },
        enumerable : true
    });

    /**
    Tab headers. An array containing all the tab header elements.
    @property {Array[HTMLElement]} tabHeaders
    @public
    @readonly
    **/
    Object.defineProperty(this, "tabHeaders",{
        get : function () {
            return this._tabHeaders;
        },
        enumerable : true
    });

    /**
    Fires when tab changes.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change');

    BaseControl.extend(this);

};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.TabParams} params Tab control parameters 
@return {Object} jQuery object of Tab control.
**/
Tab.prototype._createControl = function (params) {
    var id = params.id || 'tab';
    var tabHeader = params.tabHeader || '';
    var css = '', headerCss = '', contentCss = '';
    if(params.css) {
        if(typeof params.css === 'string') css = params.css;
        else {
            css = params.css.tabCss ? params.css.tabCss : '';
            headerCss = params.css.headerCss ? params.css.headerCss : '';
            contentCss = params.css.contentCss ? params.css.contentCss : '';
        }
    }
    var tabs = params.tabs || [];
    $.each(tabs, function() {
        this.headerCss = headerCss;
        this.contentCss = contentCss;
    });
    
    var options = {
        'id': id,
        'tabs': tabs,
        'css': css
    };
    if(tabHeader !== '') options.tabHeader = tabHeader;

    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['tab'](options));
    return parent.find('#' + id);
};

/** 
Initialize tab
@private
@method onInitialize
**/
Tab.prototype.onInitialize = function () {
    var me = this;
    this._tabHeaderArea = $(this._element).find('> .ui-tabheadercontainer');
    this._tabContentArea = $(this._element).find('> .ui-tabcontainer');

    //Handle Tab Selection
    this._tabHeaders = $(this._tabHeaderArea).find('.ui-tabbutton');
    var rawTabHeaderCount = this._tabHeaders.length;
    for (var i = 0; i < rawTabHeaderCount; i++) {
        var rawTabHeader = this._tabHeaders[i];
        $(rawTabHeader).css('width', (100/rawTabHeaderCount) + '%');
        var tabid = $(rawTabHeader).attr('Tab');
        if ($(rawTabHeader).attr('Selected')) {
            this._selectedTab = $(rawTabHeader);
        }
        this._tabPages.push($(this._element).find('#' + tabid)[0]);
        $(rawTabHeader).bind('click', function() {
            me._selectTab($(this).index());
        });
    }

};

/** 
Tab header click
@private
@method _selectTab
**/
Tab.prototype._selectTab =  function(tabIndex) {
    var pages = this._tabPages.length;
    for (var i = 0; i < pages; i++) {
        if(i === tabIndex) {
            $(this._tabPages[i]).show().addClass('ui-tabcontentborder');
            if($.trim($(this._tabPages[i]).html()) !== '') $(this._tabPages[i]).addClass('ui-tabcontentborder');
            else $(this._tabPages[i]).removeClass('ui-tabcontentborder');
            this._selectedTab = $(this._tabHeaders[i]).addClass('ui-tabbuttonselected');
            this.change.fire();
        } else {
            $(this._tabPages[i]).removeClass('ui-tabcontentborder').hide();
            $(this._tabHeaders[i]).removeClass('ui-tabbuttonselected');
        }
    }
};

/** 
Bind a Tab control to specific dom element 
@method bind
@public
@param {Object} tab A DOM or jQuery object to which you want to bind this Tab object. 
@return {Controls.Tab}
**/
Tab.bind = function (tab) {
	return new Tab(tab);
};

Controls.Tab = Tab;

/**   
TagList control parameters.
@class TagListParams
@since 1.4.0
@see Controls.TagList
@unlisted
**/
var TagListParams = function(){

    /**
    An id of TagList control.
    @property {String} id
    @default 'taglist'
    **/
    this.id = undefined;

    /**
    Parent of TagList control. Pass valid id or jQuery object of parent.
    If parent is not set then TagList control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    List of tags.
    @property {Array[Object]|Array[String]} tags
    @example 
    var taglistParams = {
        'id': 'tagList'
        ...
        ...
        'tags': ['one', 'two', 'three']
    }
    
    //or

    var taglistParams = {
        'id': 'tagList'
        ...
        ...
        'tags': [ {'text':'one', 'value': 1}, {'text':'two', 'value': 2} ]
    }
    **/
    this.tags = undefined;

    /**
    This is a list of tags that gets added when a user adds their first user-defined tag.
    @property {Array[Object]|Array[String]} initialTags
    @default undefined
    **/
    this.initialTags = undefined;

};

/**
An HTML taglist control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class TagList
@param {Controls.TagListParams} params TagList control parameters.
@namespace Controls
@extends Controls.BaseControl
@since 1.4.0
@constructor
@example
function CreateTagList() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    'id':'tagList',
                    'parent': 'taglistParent', // or $('#taglistParent')
                    'css': 'taglistControl',
                    'tags': ['tag1', 'tag1']
                };
            var taglist = new controls.TagList(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var TagList = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    if(params.tags) this._tags = params.tags;
    if(params.initialTags) this._initialTags = params.initialTags;
    this._backspaceCount = 0;

    /**
    Gets all the tag values.
    @property {Array[String]} tags
    @public
    @readonly
    **/
    Object.defineProperty(this, "tags",{
        get : function () {
            return this._element.find('li.ui-tagitem').map(function () {
                return $(this).attr('val') + ''; //convert to string
            }).get();
        },
        enumerable : true
    });

    /**
    Tag length.
    @property {Number} length
    @public
    @readonly
    **/
    Object.defineProperty(this, "length",{
        get : function () {
            return this._element.find('li.ui-tagitem').size();
        },
        enumerable : true
    });

    BaseControl.extend(this);
    //add taglist specific events here

    /**
    Fires when tag get added or deleted from tag list.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    **/
    this.change = new CoreLibrary.EventSource('change', this);

};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.TagListParams} params TagList control parameters
@return {Object} jQuery object of TagList control.
**/
TagList.prototype._createControl = function (params) {
    var id = params.id || 'taglist';
    var css = params.css || '';
    var tags = params.tags || null;

    var options = {
        'id': id,
        'css': css,
        'tags': tags
    };
    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['taglist'](options));
    return parent.find('#' + id);
};

/** 
Add tags in list.
@method addTags
@param {Array[Object]|Array[String]|String} tags Pass tags in various forms described in below example.
@example
tagList.addTags([
{'text': 'one', 'value': 1},
{'text': 'two', 'value': 2}
]);

//or

tagList.addTags([
'one',
'two'
]);

//or

tagList.addTags('Tag1');
**/
TagList.prototype.addTags = function (tags) {
    if(tags) {
        if(tags instanceof Array) {
            var tagLength = tags.length;
            for (var i = 0; i < tagLength; i++) {
                var tag;
                if(tags[i].text && tags[i].value) {
                    tag = this._getItem(tags[i].text, tags[i].value);
                } else {
                    tag = this._getItem(tags[i]);
                }
                this._lastLi.before(tag);
            }
        } else {
            this._lastLi.before(this._getItem(tags));
        }
        this._bindEvents();
    }
};

/** 
Get tag text by index
@method tagText
@param {Number} index An index of tag. In case of invalid index empty string will be returned.
**/
TagList.prototype.tagText = function (index) {
    var text = '';
    this._element.find('li.ui-tagitem').each(function (i, li) {
         if(index === $(li).index()) {
            var txt = $.trim($(li).text());
            text = txt.substr(0, txt.length-1); //remove trailing x
            return;
        }
    });
    return text;
};

/** 
Get tag value by index
@method tagValue
@param {Number} index An index of tag. In case of invalid index empty string will be returned.
**/
TagList.prototype.tagValue = function (index) {
    var val = '';
    this._element.find('li.ui-tagitem').each(function (i, li) {
         if(index === $(li).index()) val = $.trim($(li).attr('val'));
    });
    return val;
};

/** 
Get tag index by value.
@method tagIndex
@param {String} value A tag value. In case of invalid value -1 will be returned.
**/
TagList.prototype.tagIndex = function (value) {
    var index = -1;
    this._element.find('li.ui-tagitem').each(function (i, li) {
         if($.trim(value) === $(li).attr('val')) index = $(li).index();
    });
    return index;
};

/** 
Remove tag by index.
@method removeByIndex
@param {Number} index Pass an index of tag which need to be removed.
**/
TagList.prototype.removeByIndex = function (index) {
    this._element.find('li.ui-tagitem').each(function (i, li) {
         if(index === i) $(li).remove();
    });
};

/** 
Remove tag by value.
@method removeByValue
@param {String} value Pass value of tag which need to be removed.
**/
TagList.prototype.removeByValue = function (value) {
    this._element.find('li.ui-tagitem').each(function (i, li) {
         if(value === $(li).attr('val')) $(li).remove();
    });
};

/** 
Get new item 
@private
@method _getItem
**/
TagList.prototype._getItem = function (text, value) {
    text = $.trim(text);
    if(!value) value = text; else value = $.trim(value);
    return $('<li val="' + value + '" class="ui-tagitem">' + text + '<a class="ui-tagitem-close">x</a></li>');
};

/** 
Bind events 
@private
@method _bindEvents
**/
TagList.prototype._bindEvents = function () {
    var me = this;
    this._deleteCtrls = this._element.find('.ui-tagitem-close');
    this._deleteCtrls.click(function (e) {
       var o = $(this).parent();
       if (o.parent().length) { // This event is firing twice for some reason?
           o.remove();
           me.change.fire({'removed':[o.attr('val')]});
       }
    });
};

/** 
Initialize taglist
@private
@method onInitialize
**/
TagList.prototype.onInitialize = function () {
    this._txtNewTag = this._element.find('.ui-tag-input');
    this._lastLi = this._element.find('.ui-tag-new');
    var me = this;

    this._element.click(function (e) {
       me._txtNewTag.focus();
    });
    
    this._txtNewTag.keyup(function(e) {
        if (e.which == 13 ) {
            var val = $.trim(me._txtNewTag.val());
            if (0 == me.length && me._initialTags) {
                me.addTags(me._initialTags);
            }
            // If the user entered a default tag don't add it again
            if (-1 == me.tagIndex(val)) {
                me.addTags(val);
            }
            me._txtNewTag.val('');
            me.change.fire({'added': [val]});
        } else if (e.which == 8 ) {
            if(me._txtNewTag.val() === '' && me.length > 0) {
                me._backspaceCount++;
                if(me._backspaceCount === 1) {
                    me._element.find('li.ui-tagitem').removeClass('selected');
                    me._lastLi.prev().addClass('selected');
                } else if(me._backspaceCount === 2) {
                    var val = me._lastLi.prev().attr('val');
                    me._lastLi.prev().remove();
                    me.change.fire({'removed':[val]});
                    me._backspaceCount = 0;
                }
            }
        } else {
            me._element.find('li.ui-tagitem').removeClass('selected');
            me._backspaceCount = 0;
        }
    }).keydown(function(e) {
        if (e.which == 13 ) {
            e.preventDefault();
        }
    });
    this._bindEvents();
};

/** 
Bind a TagList control to specific dom element 
@method bind
@public
@param {Object} taglist A DOM or jQuery object to which you want to bind this TagList object. 
@return {Controls.TagList}
**/
TagList.bind = function (taglist) {
    return new TagList(taglist);
};

Controls.TagList = TagList;

/**   
Textarea control parameters.
@class TextareaParams
@since 1.0.0
@see Controls.Textarea
@unlisted
**/
var TextareaParams = function() {

    /**
    An id of textarea control.
    @property {String} id
    @default 'textarea'
    **/
    this.id = undefined;

    /**
    Parent of textarea control. Pass valid id or jQuery object of parent.
    If parent is not set then Textarea control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Textarea text.
    @property {String} text
    **/
    this.text = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    Placeholder tip text.
    @property {String} placeholderText
    **/
    this.placeholderText = undefined;

    /**
    Upper cap on number of input characters.
    @property {Number} maxLength
    @since 1.3.0
    **/
    this.maxLength = undefined;

};

/**
An HTML Textarea control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Textarea
@param {Controls.TextareaParams} params Textarea parameters.
@namespace Controls
@since 1.0.0
@extends Controls.BaseControl
@constructor
@example
function CreateTextarea() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    'id':'txtHello',
                    'parent': 'textareaParent', // or $('#textareaParent')
                    'css': 'textareaControl'
                };
            var textarea = new controls.Textarea(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Textarea = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    BaseControl.extend(this);
    this._isValid = true;
    this._changeTimeoutDelay = 300;

    /**
    Get or set validity of textarea.
    User can validate or invalidate textarea when there is any error in input.
    @property {Boolean} isValid
    @public
    **/
    Object.defineProperty(this, "isValid",{
        get : function () {
            return this._isValid;
        },
        set : function (valid) {
            valid ? $(this._element).removeClass('ui-textarea-inputerror') : $(this._element).addClass('ui-textarea-inputerror');
            this._isValid = valid;
        },
        enumerable : true
    });

    /**
    Get or set text property of textarea.
    @property {String} text
    @public
    **/
    Object.defineProperty(this, "text",{
        get : function () {
            return $(this._element).val();
        },
        set : function (text) {
            $(this._element).val(text);
        },
        enumerable : true
    });

    /**
    Maximum allowed characters.
    @property {Number} maxLength
    @since 1.3.0
    @public
    **/
    Object.defineProperty(this, "maxLength",{
        get : function () {
            var len = parseInt($(this._element).attr('maxlength'));
            return len !== NaN ? len : undefined;
        },
        set : function (length) {
            if(!length) return;
            $(this._element).attr('maxlength', length);
        },
        enumerable : true
    });

    /**
    Event will be fired when value begin to change.
    @event beginchange
    @public
    @type {CoreLibrary.EventSource}
    @since 1.4.0
    **/
    this.beginchange = new CoreLibrary.EventSource('beginchange');

    /**
    Fires when text property is changed.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    @since 1.1.0
    **/
    this.change = new CoreLibrary.EventSource('change');

    /**
    Event will be fired when value change ends.
    @event endchange
    @public
    @type {CoreLibrary.EventSource}
    @since 1.4.0
    **/
    this.endchange = new CoreLibrary.EventSource('endchange');
    
};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.TextareaParams} params Textarea control parameters 
@return {Object} jQuery object of Textarea control.
**/
Textarea.prototype._createControl = function (params) {
    var id = params.id || 'textarea';
    var text = params.text || '';
    var css = params.css || '';
    var placeholder = params.placeholderText || '';
    var maxLength = params.maxLength || 0;

    var options = {
        'id': id,
        'text': text,
        'css': css,
        'placeholder': placeholder
    };
    if(maxLength) options.maxlength = maxLength;

    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['textarea'](options));
    return parent.find('#' + id);
};

/** 
Initialize textarea
@private
@method onInitialize
**/
Textarea.prototype.onInitialize = function () {
    var me = this;
    me._lastValue = '';
    //bind text change event for text edit.
    $(this._element).bind('input', function (e) {
        if (me._changeTimeoutID) {
            clearTimeout(me._changeTimeoutID);
        }
        me._changeTimeoutFunc = function () {
            me._lastValue = me.text;
            me._changeTimeoutID = null;
            me.change.fire(null, e);
        };
        me._changeTimeoutID = setTimeout(me._changeTimeoutFunc, me._changeTimeoutDelay);
    }).focus(function(e){
        me.beginchange.fire(null, e);
    }).blur(function(e){
        if (me._changeTimeoutID) {
            clearTimeout(me._changeTimeoutID);
        }
        me.endchange.fire(null, e);
    }).change(function(e){
        if(me._lastValue !== me.text)
            me.change.fire(null, e);
    });
};

/** 
Bind a Textarea control to specific dom element 
@method bind
@public
@param {Object} textarea A DOM or jQuery object to which you want to bind this Textarea object. 
@return {Controls.Textarea}
**/
Textarea.bind = function(textarea) {
    return new Textarea(textarea);
};

Controls.Textarea = Textarea;
/**   
Textbox control parameters.
@class TextboxParams
@since 1.0.0
@see Controls.Textbox
@unlisted
**/
var TextboxParams = function() {

    /**
    An id of textbox control.
    @property {String} id
    @default 'textbox'
    **/
    this.id = undefined;

    /**
    Parent of textbox control. Pass valid id or jQuery object of parent.
    If parent is not set then Textbox control will be appended to body.
    @property {String|Object} parent
    @default 'body'
    **/
    this.parent = undefined;

    /**
    Textbox text.
    @property {String} text
    **/
    this.text = undefined;

    /**
    An external css class.
    @property {String} css
    **/
    this.css = undefined;

    /**
    Placeholder tip text.
    @property {String} placeholderText
    **/
    this.placeholderText = undefined;

    /**
    Upper cap on number of input characters.
    @property {Number} maxLength
    @since 1.3.0
    **/
    this.maxLength = undefined;

};

/**
An HTML Textbox control.  For an interactive demonstration please see: {Interactive Control Demos}.

@class Textbox
@since 1.0.0
@param {Controls.TextboxParams} params Textarea parameters.
@namespace Controls
@extends Controls.BaseControl
@constructor
@example
function CreateTextbox() {
    //Downloads the Creative Platform UI Toolkit using the runtime
    creativePlatformRuntime.require(
        //List of libraries that we're interested in
        [{id: "aZS9YbvfqUX", version: 0}],

        //Callback when successful
        function(library) {
            var controls = library.Controls;
            var params = {
                    'id':'txtHello',
                    'parent': 'textboxParent', // or $('#textboxParent')
                    'css': 'textboxControl'
                };
            var textbox = new controls.Textbox(params);
        },

        //Callback when failed
        function() {
            alert('Failed to load uitoolkit');
        }
    );
}
**/
var Textbox = function (params) {
    if(params instanceof HTMLElement || params.jquery) { //bind control
        this._element = $(params);
    } else { //create control
        this._element = this._createControl(params);
    }
    BaseControl.extend(this);
    this._isValid = true;
    this._changeTimeoutDelay = 300;

    /**
    Get or set validity of textbox.
    User can validate or invalidate textbox when there is any error in input.
    @property {Boolean} isValid
    @public
    **/
    Object.defineProperty(this, "isValid",{
        get : function () {
            return this._isValid;
        },
        set : function (valid) {
            valid ? $(this._element).removeClass('ui-textbox-inputerror') : $(this._element).addClass('ui-textbox-inputerror');
            this._isValid = valid;
        },
        enumerable : true
    });

    /**
    Text property of textbox.
    @property {String} text
    @public
    **/
    Object.defineProperty(this, "text",{
        get : function () {
            return $(this._element).val();
        },
        set : function (text) {
            $(this._element).val(text);
        },
        enumerable : true
    });

    /**
    Maximum allowed characters.
    @property {Number} maxLength
    @since 1.3.0
    @public
    **/
    Object.defineProperty(this, "maxLength",{
        get : function () {
            var len = parseInt($(this._element).attr('maxlength'));
            return len !== NaN ? len : undefined;
        },
        set : function (length) {
            if(!length) return;
            $(this._element).attr('maxlength', length);
        },
        enumerable : true
    });

    /**
    Event will be fired when value begin to change.
    @event beginchange
    @public
    @type {CoreLibrary.EventSource}
    @since 1.4.0
    **/
    this.beginchange = new CoreLibrary.EventSource('beginchange');

    /**
    Fires when text property is changed.
    @event change
    @public
    @type {CoreLibrary.EventSource}
    @since 1.1.0
    **/
    this.change = new CoreLibrary.EventSource('change');

    /**
    Event will be fired when value change ends.
    @event endchange
    @public
    @type {CoreLibrary.EventSource}
    @since 1.4.0
    **/
    this.endchange = new CoreLibrary.EventSource('endchange');
    
};

/** 
Create control from handlebar template.
@private
@method _createControl
@param {Controls.TextboxParams} params Textbox control parameters 
@return {Object} jQuery object of Textbox control.
**/
Textbox.prototype._createControl = function (params) {
    var id = params.id || 'textbox';
    var text = params.text || '';
    var css = params.css || '';
    var placeholder = params.placeholderText || '';
    var maxLength = params.maxLength || 0;

    var options = {
        'id': id,
        'text': text,
        'css': css,
        'placeholder': placeholder
    };
    if(maxLength) options.maxlength = maxLength;

    var parent = $('body');
    if(typeof params.parent === 'string')
        parent = $('#' + params.parent);
    else 
        parent = $(params.parent);

    parent.append(Handlebars.templates['textbox'](options));
    return parent.find('#' + id);
};

/** 
Initialize textbox
@private
@method onInitialize
**/
Textbox.prototype.onInitialize = function () {
    var me = this;
    me._lastValue = '';
    //bind text change event for text edit.
    $(this._element).bind('input', function (e) {
        if (me._changeTimeoutID) {
            clearTimeout(me._changeTimeoutID);
        }
        me._changeTimeoutFunc = function () {
            me._lastValue = me.text;
            me._changeTimeoutID = null;
            me.change.fire(null, e);
        };
        me._changeTimeoutID = setTimeout(me._changeTimeoutFunc, me._changeTimeoutDelay);
    }).focus(function(e){
        me.beginchange.fire(null, e);
    }).blur(function(e){
        if (me._changeTimeoutID) {
            clearTimeout(me._changeTimeoutID);
        }
        me.endchange.fire(null, e);
    }).change(function(e){
        if(me._lastValue !== me.text)
            me.change.fire(null, e);
    });
};

/** 
Selects all the text in the textbox
@method select
**/
Textbox.prototype.select = function () {
    $(this._element).select();
};

/** 
Bind a Textbox control to specific dom element 
@method bind
@public
@param {Object} textbox A DOM or jQuery object to which you want to bind this Textbox object. 
@return {Controls.Textbox}
**/
Textbox.bind = function(textbox) {
    return new Textbox(textbox);
};

Controls.Textbox = Textbox;

//topic-uitoolkit.js
/**
<p>The Autodesk Creative Platform Runtime is used to download various libraries and their dependencies.  
Below is example code that explains how to include the Autodesk Creative Platform Runtime in an HTML page and use it to download the Autodesk Creative Platform UI Toolkit Library.</p>
<pre class="prettyprint lang-html">
&lt;!-- Includes the Creative Platform Runtime --&gt;
&lt;script type="text/javascript" src="https://api.tinkercad.com/libraries/1jiw9epElcK/0/library.min.js"&gt;&lt;/script&gt;

&lt;!-- Downloads the Creative Platform UI Toolkit Using The Runtime --&gt;
&lt;script type="text/javascript"&gt;
creativePlatformRuntime.require(
	[{
		id: "aZS9YbvfqUX", 
		version: 0
	}],	// The ID of the UI Toolkit

	function(uiToolkit) { // The callback when it downloads

		// TODO: Your control code will go here

	},
	function() { // Called on failure

	}
);
&lt;/script&gt;
</pre>

We have some awesome themes designed for these controls. Switch between the themes:<div id='themelist'></div> 
<br/><br/>
<style>
#themelist{ width:200px; }
.exampleTable {}
.exampleTable td {
	vertical-align: top;
}
.exampleTable .prettyprinted {
	margin-top: 0px;
	margin-bottom: 0px;
}
.andes-controllink { color: white; }
.andes-vanilla-controllink { color: #CC6600; }
.resizeLi { position: relative; }
.resizeExample { position:relative; top:0px; left:0px; border: 1px solid black; width:50px; height:50px; }
.ratingExample { height: 70px; }
#dropdownControlExample{ width: 200px; }
#itemsliderExample { width:320px; height:150px; }
.itemsliderItem-Tinkercad { height: 58px; width: 58px; background-color:#00a5c9; }
.itemsliderItem-AndesVanilla { height: 58px; width: 58px; background-color:#E0E0E0; }
#itemsliderExample .itemsliderItem-Andes { height: 40px; width: 40px; margin-bottom:5px; background-color:#656363 }
.itemslider-Andes {width:256px;}
.tabExampleContent {text-align: center; line-height: 70px;}
#tabExample2{width:102px;}
.ui-horizontal-slider .ui-slider-area { width:200px; }
.ui-vertical-slider .ui-slider-area {height: 200px};
.ui-imagemap-item {	background-color: darkgrey; }
.ui-layout-manager {width: 100%!important}
.hoverAreaParent { position:relative; width:100%; height: 200px;}
.hoverAreaItem1 { position: absolute; width: 75px; height: 25px; left: 20px; top: 100px; border: 1px solid;}
.hoverAreaItem2 { position: absolute; width: 30px; height: 80px; left: 40px; border: 1px solid;}
</style>

<table class="exampleTable">
	<tr><td colspan="2"><h2>{Controls.Accordion}</h2></td></tr>
	<tr>
		<td>
			<div id="accordionExample"></div><br />
			<div id="accordionMessage"></div><br />
			<div id="item1" style="height:50px;">item 1 -content</div>
			<div id="item2" style="height:50px;">item 3 -content</div>
			<div id="item3" style="height:50px;">sub item 2 -content</div>
		</td>
		<td>
<pre class="prettyprint">
var accordion = new controls.Accordion({
	id: 'accordion',
	parent: 'accordionExample'
});
accordion.change.bind(function() {
	var item = accordion.selectedItem
	$('#accordionMessage').text(item.header.text());
});
</pre>
		</td>
	</tr>

	<tr><td colspan="2"><h2>{Controls.Button}</h2></td></tr>
	<tr>
		<td>
			<div id="buttonExample"></div><br />
			<div id="buttonMessage"></div><br /><br />
			<div id="buttonExample1"></div><br />
			<div id="buttonMessage1"></div>
		</td>
		<td>
<pre class="prettyprint">
var btnHello = new controls.Button({
	id: 'btnHelloWorld',
	parent: 'buttonExample',
	text: 'Hello World'
});
btnHello.click.bind(function () {
  document.getElementById('buttonMessage').innerText = 'Hello World!';		
});

//button with icon
var iconButton = new controls.Button({
	id: 'btnIcon',
	text: 'Hello Tinkercad',
	parent: 'buttonExample',
	icon: &#123;
		url: 'http://tinkercad.com/logo.png',
		position: 'left',
		width: 20,
		height: 20
	&#125;
});
iconButton.click.bind(function () {
  document.getElementById('buttonMessage').innerText = 'Hey there!';		
});
</pre>
		</td>
	</tr>

	<tr><td colspan="2"><h2>{Controls.Checkbox}</h2></td></tr>
	<tr>
		<td>
			<div id="checkboxExample"></div><br/>
			<div id="checkboxMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
var chkHello = new controls.Checkbox({
	id:'chkHelloWorld',
	parent: 'checkboxExample',
	text: 'Click Me!'
});
chkHello.change.bind(function () {
  console.log(chkHello.checked);
});
</pre>
		</td>
	</tr>

<tr><td colspan="2"><h2>{Controls.Dropdown}</h2></td></tr>
	<tr>
		<td>
			<div id="dropdownControlExample"></div><br/>
			<div id="dropdownControlMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
var dropdownControl = new controls.Dropdown({
	id:'dropdownControl',
	parent: 'dropdownControlExample',
	items: [
		&#123;"value": "1", "text": "Red"&#125;,
		&#123;"value": "2", "text": "Green"&#125;,
		&#123;"value": "3", "text": "Blue"&#125;
	]
});
</pre>
		</td>
	</tr>

<tr><td colspan="2"><h2>{Controls.Feedback}</h2></td></tr>
	<tr>
		<td>
			<div id="feedbackExample"></div><br/>
			<div id="feedbackMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
//Add feedback
var feedback = new controls.Feedback({
	id:'feedbackControl',
	parent: 'feedbackExample'
});
feedback.submit.bind(function () {
  document.getElementById('feedbackMessage').innerText = feedback.comment;
});

//Edit feedback
var feedback = new controls.Feedback({
	id:'feedbackControl',
	parent: 'feedbackExample',
	rating: 5, //initial value
	comment: 'This is awesome!' //initial value
});
</pre>
		</td>
	</tr>

	<tr><td colspan="2"><h2>{Controls.HoverArea}</h2></td></tr>
	<tr>
		<td>
			<div id="hoverAreaExample">
				<div id="hoverAreaParent" class="hoverAreaParent">
					<div id="hoverAreaItem1" class="hoverAreaItem1"></div>
					<div id="hoverAreaItem2" class="hoverAreaItem2"></div>
				</div>
			</div><br/>
			<div id="feedbackMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
//Add feedback
var hoverArea = new controls.HoverArea();
hoverArea.bind([{
	id :'item1',
	parent: document.getElementById('hoverAreaParent'),
	target: document.getElementById('hoverAreaItem1'),
	direction : 'top'
},{
	id :'item2',
	parent: document.getElementById('hoverAreaParent'),
	target: document.getElementById('hoverAreaItem2'),
	direction : 'right'
}]);

</pre>
		</td>
	</tr>

	<tr><td colspan="2"><h2>{Controls.ImageMap}</h2></td></tr>
	<tr>
		<td>
			<div id="imageMapControlExample"></div><br/>
			<div id="imageMapControlMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
var items = [];
for (i=0; i<7; i++) {
	var item = {};
	item.id = 'robot-part-' + i;
	item.imagesrc = Library.resourceURL('robot-part-' + i +'.png');
	items.push(item);
}

//Assign a colour for each item accoring to the colour image mapping

<img src="{@ResourceUrl:robot-map-image.png}"/>

items[0].value = '#FDB139'; //Head
items[1].value = '#416C3D'; //Right Arm
items[2].value = '#C38853'; //Right Leg
items[3].value = '#6FA474'; //Left Arm
items[4].value = '#FF7B7B'; //Left Leg
items[5].value = '#47827F'; //Torso
items[6].value = '#491E1E'; //Pelvi Area

var imageMapControl = new controls.ImageMap({
	id:'imageMap',
	parent: 'imageMapControlExample',
	items: items,
	mainImage: Library.resourceURL('robot-main-image.png'),
	mapImage: Library.resourceURL('robot-map-image.png')
});

imageMapControl.change.bind(function(e) {
  var message = 'Selected Item: ' + imageMapControl.value;
  document.getElementById('imgMapMessage').innerText = message;
});
</pre>
		</td>
</tr>

	<tr><td colspan="2"><h2>{Controls.Itemslider}</h2></td></tr>
	<tr>
		<td>
			<div id="itemsliderExample">
			</div><br/>
			<div id="itemsliderMessage1"></div><br />
			<div id="itemsliderMessage2">
		</td>
		<td>
<pre class="prettyprint">
var items = [];
for (i=0; i<16; i++) {
    var itm = {};
    itm.id = i;
    itm.value = i+1;
    //itm.imagesrc = '', //item image url
    items.push(itm);
}

var itemsliderControl = new controls.Itemslider({
	id:'itemsliderControl',
	parent: 'itemsliderExample',
	items: items,
	itemsPerSlide: 8,
	itemCss: 'itemsliderItem' //external item css
});

itemsliderControl.change.bind(function(e) {
  var message = 'Selected value: ' +
	itemsliderControl.selectedValue;
  document.getElementById('itemsliderMessage').innerText = message;
});
itemsliderControl.slidechange.bind(function(e) {
  var message = 'Current slide index: ' +
	itemsliderControl.slideIndex;
  document.getElementById('itemsliderMessage').innerText = message;
});
</pre>
		</td>
	</tr>

<tr><td colspan="2"><h2>{Controls.Panel}</h2></td></tr>
	<tr>
		<td>
			<div id="panelControlExample">
				<span id="panelParent"></span>
			</div><br/>
			<div id="panelControlMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
var panel = new controls.Panel({
	id:'panel1',
	title : 'Panel',
	collapsible: true
}, document.getElementById('panelTargetElement'));

var textbox = new controls.Textbox({
	id: 'txt1',
	parent: panelControl.contentArea
});

var textbox = new controls.Button({
	id: 'btn1',
	text: 'Button',
	parent: panelControl.contentArea
});
</pre>
		</td>
	</tr>

<tr><td colspan="2"><h2>{Controls.Popup}</h2></td></tr>
	<tr>
		<td>
			<div id="popupControlExample">
				<span id="popupParent" style="cursor:pointer;">Click to see all popup positions.</span>
			</div><br/>
			<div id="popupControlMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
var popupControl = new controls.PopupControl({
	id:'popupControl',
	content: 'Hello world!'
}, document.getElementById('popupTargetElement'));
</pre>
		</td>
	</tr>

	<tr><td colspan="2"><h2>{Controls.Rating}</h2></td></tr>
	<tr>
		<td>
			<div id="ratingExample" class="ratingExample">
				Readonly rating control:<div id="readonlyRating"></div><br/><br/>
				Editable rating control:<div id="editableRating"></div>
			</div>
			<br /><br />
			<div id="ratingMessage">Your rating: 5</div>
		</td>
		<td>
<pre class="prettyprint">
//Readonly
var readonlyRatingCtrl = new controls.Rating({
	id: 'ratingCtrl',
	parent: 'ratingExample',
	rating: 3, //initial rating
	max: 5,
	reviewCount: 7, //total reviews
	readonly: true
});
//Editable
var editableRatingCtrl = new controls.Rating({
	id: 'ratingCtrl',
	parent: 'ratingExample',
	rating: 5, //initial rating
	max: 5,
	readonly: false
});
editableRatingCtrl.change.bind(function () {
  document.getElementById('ratingMessage').innerText = 'Your rating:'+
	editableRatingCtrl.rating;
});
</pre>
		</td>
	</tr>


	<tr><td colspan="2"><h2>{Controls.Resizable}</h2></td></tr>
	<tr>
		<td>
			<div id="resizeExample" class="resizeExample"></div>
		</td>
		<td>
<pre class="prettyprint">
controls.Resizable.bind({control: document.getElementById('resizeExample'),
	grips: [
		controls.ResizeGripEnum.South,
		controls.ResizeGripEnum.East,
		controls.ResizeGripEnum.SouthEast], 
    minHeight: 50, 
    minWidth: 50, 
    maxHeight: 300, 
    maxWidth: 300
});
</pre>
		</td>
	</tr>

	<tr><td colspan="2"><h2>{Controls.Slider}</h2></td></tr>
	<tr>
		<td>
			<div id="sliderControlExample"></div><br/>
			<div id="sliderControlMessage"></div><br/>
			<div id="sliderControlExample2"></div><br/>
			<div id="sliderControlMessage2"></div><br />
			<div id="sliderControlExample3"></div><br/>
			<div id="sliderControlMessage3"></div>
		</td>
		<td>
<pre class="prettyprint">
var sliderControl = new controls.Slider({
	id:'sliderControl',
	parent: 'sliderControlExample'
	showText: true,
	showInput: true,
	displayUnit: 'in'
});
<br/>
var sliderControl = new controls.Slider({
	id:'sliderControl',
	parent: 'sliderControlExample',
	min: 50,
	max: 500,
	steps:50,
	ticks: [100,121,150,180,200,300,400]
});
<br/>
var sliderControl = new controls.Slider({
	id:'sliderControl',
	parent: 'sliderControlExample',
	min: 50,
	max: 500,
	steps:[100,150,400],
	ticks: [100,150,400],
	orientation: controls.SliderOrientationEnum.Vertical,
	showText: true,
	showInput: true
});
</pre>
		</td>
	</tr>

	<tr><td colspan="2"><h2>{Controls.Sketch2D}</h2></td></tr>
	<tr>
		<td>
			<div id="sketchExample"></div>
		</td>
		<td>
<pre class="prettyprint">
var sketch2d = new controls.Sketch2D({
	id: '2dsketch',
	parent: 'sketchExample'
	width: 250, 
	height: 250, 
	css: 'sketchControl'
});
var svgString = '&lt;?xml version="1.0" encoding="ISO-8859-1" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;
&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt;
&lt;circle cx="0" cy="0" r="10" stroke="black" stroke-width="2" fill="red" /&gt;
&lt;/svg&gt;';
var conversions = library.CoreLibrary.Conversions; 
sketch2d.value = conversions.toSketch2DFromSVG(svgString);
</pre>
		</td>
	</tr>

<tr><td colspan="2"><h2>{Controls.Tab}</h2></td></tr>
	<tr>
		<td>
			<div id="tabExample1"></div><br/>
			<div id="tabMessage1"></div>
			<br/>
			<div id="tabExample2"></div><br/>
			<div id="tabMessage2"></div>
		</td>
		<td>
<pre class="prettyprint">
//Tab Control
var params = {};
params.id = 'tabControl';
params.parent = 'tabExample';
params.css = {};
params.css.tabCss = "tabCss";
params.css.headerCss = "headerCss";
params.css.contentCss = "tabExampleContent";

params.tabs = &#123;'tab1': &#123;
    'tabid': 'tab1',
    'headerText': 'Tab1',
    'tabContent': 'Tab1 content'
&#125;,
'tab2': &#123;
    'tabid': 'tab2',
    'headerText': 'Tab2',
    'tabContent': 'Tab2 content'
&#125;,
'tab3': &#123;
    'tabid': 'tab3',
    'headerText': 'Tab3',
    'tabContent': 'Tab3 content'
&#125;&#125;;

var tabControl = new controls.Tab(params);

//Option Tab Control
var params = {};
params.id = 'taboptionControl';
params.parent = 'tabExample';
params.tabHeader = 'Switch';

params.tabs = &#123;'tab1': &#123;
    'tabid': 'on',
    'headerText': 'On'
&#125;,
'tab2': &#123;
    'tabid': 'off',
    'headerText': 'Off'
&#125;&#125;;

var tabControl = new controls.Tab(params);

</pre>
		</td>
	</tr>

<tr><td colspan="2"><h2>{Controls.TagList}</h2></td></tr>
	<tr>
		<td>
			<div id="tagListExample"></div><br/>
			<div id="tagListMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
var tagList = new controls.TagList({
	id:'tagList'
	parent: 'tagListExample'
});
tagList.change.bind(function () {
  document.getElementById('textboxMessage').innerText = tagList.text;
});
</pre>
		</td>
	</tr>

<tr><td colspan="2"><h2>{Controls.Textbox}</h2></td></tr>
	<tr>
		<td>
			<div id="textboxExample"></div><br/>
			<div id="textboxMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
var txtHello = new controls.Textbox({
	id:'txtHelloWorld'
	parent: 'textboxExample'
});
txtHello.change.bind(function () {
  document.getElementById('textboxMessage').innerText = txtHello.text;
});
</pre>
		</td>
	</tr>

<tr><td colspan="2"><h2>{Controls.Textarea}</h2></td></tr>
	<tr>
		<td>
			<div id="textareaExample"></div><br/>
			<div id="textareaMessage"></div>
		</td>
		<td>
<pre class="prettyprint">
var txtareaHello = new controls.Textarea({
	id:'txtareaHelloWorld',
	parent: 'textareaExample'
});
txtareaHello.change.bind(function () {
  document.getElementById('textareaMessage').innerText = txtareaHello.text;
});
</pre>
		</td>
	</tr>

</table>

<script src="/libraries/1jiw9epElcK/0/library.js"></script>
<script>
	$(document).ready(function () {
		var rt = window.creativePlatformRuntime;
		var environment = rt.environment;
		environment.setVariable(['urls', 'api'], window.location.protocol + '//' + window.location.host);
		environment.setVariable(['resources', 'minified'], false);
		var uiToolkitLibrary = {
			"id": 'aZS9YbvfqUX',
			"version": 0
		};
		rt.require(
			[uiToolkitLibrary], 
			function(library) {
				var controls = library.Controls;
				var handlebars = library.Handlebars;
				var $ = library.jQuery;
				var Library = environment.library(uiToolkitLibrary.id,uiToolkitLibrary.version);
				
				//accordion
				var accordion = new controls.Accordion({
					id: 'accordion',
					parent: 'accordionExample'
				});
				accordion.change.bind(function() {
					var item = accordion.selectedItem
					$('#accordionMessage').text('Selected item: ' + item.header.text());
				});

				var item1 = {};
				item1.content = $('#item1');
				item1.header = 'Item 1';

				var item3 = {};
				item3.content = $('#item2');
				item3.header = 'Item 3';

				accordion.add([
					item1,
					'Item2',
					item3
				]);

				accordion.items[1].add([
					'Item2 > sub item 1',
					'Item2 > sub item 2',
					'Item2 > sub item 3'
				]);

				accordion.items[1].items[1].content = $('#item3');

				accordion.items[1].items[2].add([
					'Item2 > sub item 3 > item 1',
					'Item2 > sub item 3 > item 2'
				]);

				accordion.items[1].items[2].items[1].add([
					'Item2 > sub item 3 > item 2 > child 1',
					'Item2 > sub item 3 > item 2 > child 2',
					'Item2 > sub item 3 > item 2 > child 3',
					'Item2 > sub item 3 > item 2 > child 4'
				]);

				//button
				var btnHello = new controls.Button({
					id: 'btnHelloWorld',
					text: 'Hello World',
					parent: 'buttonExample'
				});
				btnHello.click.bind(function () {
					$('#buttonMessage').text('Hello World!');		
				});
				
				var icon = {};
				icon.url = Library.resourceURL('example-logo.png');
				icon.position = 'left';
				icon.width = 20;
				icon.height = 20;

				//button
				var btnHello1= new controls.Button({
					id: 'btnHelloWorld',
					text: 'Hello Tinkercad',
					parent: 'buttonExample1',
					icon: icon
				});
				btnHello1.click.bind(function () {
					$('#buttonMessage1').text('Hey there!');		
				});

				//feedback
				var feedback = new controls.Feedback({
					id:'feedbackControl',
					parent: 'feedbackExample',
					rating: 5,
					comment: 'Awesome!'
				});
				feedback.submit.bind(function () {
					$('#feedbackMessage').html('Rating: ' + feedback.rating + '<br/>Feedback: ' + feedback.comment);		
				});

				//library feedback
				//var libraryFeedback = new controls.LibraryFeedback({
				//	id:'libraryFeedback',
				//	parent: 'libraryFeedbackExample',
				//	libraryid: '1vxKXGNaLtr',
				//	version: 0,
				//	userid: '7dKiMeSD4zG'
				//});
				
				//rating
				var ratingControl1 = new controls.Rating({
					id: 'ratingCtrl1',
					parent: 'readonlyRating',
					rating: 3,
					max: 5,
					reviewCount: 7,
					readonly: true
				});
				$('#ratingExample').append('<br/>');
				var ratingControl2 = new controls.Rating({
					id: 'ratingCtrl2',
					parent: 'editableRating',
					rating: 5,
					max: 5,
					readonly: false
				});
				ratingControl2.change.bind(function () {
					$('#ratingMessage').text('Your rating: ' + ratingControl2.rating);		
				});

				//textbox
				var txtHello = new controls.Textbox({
					id: 'txtHelloWorld',
					parent: 'textboxExample'
				});
				txtHello.change.bind(function () {
					$('#textboxMessage').text(txtHello.text);
				});

				//textarea
				var txtareaHello = new controls.Textarea({
					id: 'txtareaHelloWorld',
					parent: 'textareaExample'
				});
				txtareaHello.change.bind(function () {
					$('#textareaMessage').text(txtareaHello.text);		
				});

				//checkbox
				var chkHello = new controls.Checkbox({
					id: 'chkHelloWorld',
					parent: 'checkboxExample',
					text: 'Click Me!'
				});
				chkHello.change.bind(function () {
					if(chkHello.checked) $('#checkboxMessage').text('Hello world!');
					else $('#checkboxMessage').text('');
				});
				
				//resize
				controls.Resizable.bind({
					control: $('#resizeExample'),
					grips: [
						controls.ResizeGripEnum.South,
						controls.ResizeGripEnum.East,
						controls.ResizeGripEnum.SouthEast
					],
					minWidth: 50,
					maxWidth: 200,
					minHeight: 50,
					maxHeight: 200
				});
				
				//sketch
				var sketch2d = new controls.Sketch2D({
					id: '2dsketch',
					parent: 'sketchExample',
					width: 250,
					height: 250,
					css: 'sketchControl'
				});
				var svgString = '<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" version="1.1"><circle cx="0" cy="0" r="20" stroke="black" stroke-width="2" fill="red" /></svg>';

				sketch2d.value = library.CoreLibrary.Conversions.toSketch2DFromSVG(svgString);

				//popup
				var positions = [
					controls.PopupPositionEnum.TOP,
					controls.PopupPositionEnum.BOTTOM,
					controls.PopupPositionEnum.LEFT,
					controls.PopupPositionEnum.RIGHT
				];
				var counter = 0, popupControl;
				$('#popupParent').bind('click', function() {
					if(popupControl) popupControl.remove();
					popupControl = new controls.Popup({
						id: 'hellotooltip',
						content: '<div style="width:300px;height:100px;text-align:center;line-height:100px;">Hello world!</div>',
						position: positions[counter]
					}, $('#popupParent'));
					if(counter<positions.length - 1) counter++; else counter = 0;
				});
				var item1 = {};
				item1.value = 1;
				item1.text = 'Red';

				var item2 = {};
				item2.value = 2;
				item2.text = 'Green';

				var item3 = {};
				item3.value = 3;
				item3.text = 'Blue';

				//Dropdown
				var dropdownControl = new controls.Dropdown({
					id:'dropdownControl',
					parent: 'dropdownControlExample',
					items: [
						item1,
						item2,
						item3
					]
				});

				dropdownControl.change.bind(function() {
					$('#dropdownControlMessage').html('Selected value: <b>' + dropdownControl.selectedValue + '</b><br/>Selected text: <b>' + dropdownControl.selectedText + '</b><br/>Selected index: <b>' + dropdownControl.selectedIndex + '</b>');
				});
				dropdownControl.selectedText = 'Green';
				
				var theme1 = {};
				theme1.value = library.Themes.Tinkercad;
				theme1.text = 'Tinkercad';

				var theme2 = {};
				theme2.value = library.Themes.Andes;
				theme2.text = 'Andes';

				var themeList = new controls.Dropdown({
					id:'themelist',
					parent: 'themelist',
					items: [
						theme1,
						theme2
					]
				});
				themeList.selectedValue = library.Themes.Tinkercad;
				themeList.change.bind(function() {
					switch(themeList.selectedValue)
					{
						case library.Themes.Tinkercad:
						  $('.exampleTable').parent().css('background-color', '#FFFFFF');
						  $('.ui-slide-item').removeClass('itemsliderItem-Andes itemsliderItem-AndesVanilla').addClass('itemsliderItem-Tinkercad');
						  $('.ui-itemslider').removeClass('itemslider-Andes');
						  $('h2 > a').removeClass('andes-controllink andes-vanilla-controllink');
						  break;
					  case library.Themes.AndesVanilla:
						  $('.exampleTable').parent().css('background-color', '#FFFFFF');
						  $('.ui-slide-item').removeClass('itemsliderItem-Andes').addClass('itemsliderItem-AndesVanilla');
						  $('.ui-itemslider').removeClass('itemslider-Andes');
						  $('h2 > a').addClass('andes-vanilla-controllink');
						  $('h2 > a').removeClass('andes-controllink');
						  break;
						case library.Themes.Andes:
							$('.exampleTable').parent().css('background-color', 'rgba(1,1,1,0.3)');
							$('.ui-slide-item').addClass('itemsliderItem-Andes').removeClass('itemsliderItem-Tinkercad itemsliderItem-AndesVanilla');
							$('.ui-itemslider').addClass('itemslider-Andes');
							$('h2 > a').addClass('andes-controllink');
							$('h2 > a').removeClass('andes-vanilla-controllink');
						  break;
					}
					library.Utility.loadTheme(themeList.selectedValue);
				});
				
				var sliderControl = new controls.Slider({
					id:'sliderControl',
					parent: 'sliderControlExample',
					showText: true,
					showInput: true,
					displayUnit: 'in'
				});

				sliderControl.change.bind(function() {
					$('#sliderControlMessage').html('Current value: <b>' + sliderControl.value + '</b><br/>');
				});

				var sliderControl2 = new controls.Slider({
					id:'sliderControl2',
					parent: 'sliderControlExample2',
					min: 50,
					max: 500,
					steps:50,
					ticks: [100,121,150,180,200,300,400]
				});

				sliderControl2.change.bind(function() {
					$('#sliderControlMessage2').html('Current value: <b>' + sliderControl2.value + '</b><br/>');
				});

				var sliderControl3 = new controls.Slider({
					id:'sliderControl3',
					parent: 'sliderControlExample3',
					min: 50,
					max: 500,
					steps:[100,150,400],
					ticks: [100,150,400],
					orientation: controls.SliderOrientationEnum.Vertical,
					showText: true,
					showInput: true
				});

				sliderControl3.change.bind(function() {
					$('#sliderControlMessage3').html('Current value: <b>' + sliderControl3.value + '</b><br/>');
				});

				sliderControl3.value = 100;
				

				//panel
				var panelControl;
				panelControl = new controls.Panel({
					id: 'panel1',
					parent: 'panelParent',
					title : 'Panel',
					collapsible: true
				}, $('#panelParent'));

				var textbox = new controls.Textbox({
					id: 'txt1',
					parent: panelControl.contentArea
				});

				var button = new controls.Button({
					id: 'btn1',
					text: 'Button',
					parent: panelControl.contentArea
				});
				
				//itemslider
				var itms = [];
				for (i=0; i<24; i++) {
					var itm = {};
					itm.id = i;
					itm.value = i+1;
					//itm.imagesrc = Library.resourceURL('pattern0' + i + '.png');
					itms.push(itm);
				}
				var itemsliderControl = new controls.Itemslider({
					id:'itemsliderControl',
					parent: 'itemsliderExample',
					items: itms,
					itemsPerSlide: 6,
					itemCss: 'itemsliderItem-Tinkercad'
				});

				itemsliderControl.change.bind(function(e) {
					$('#itemsliderMessage1').html('Selected value: <b>' + itemsliderControl.selectedValue + '</b><br/>');
				});

				itemsliderControl.slidechange.bind(function(e) {
					$('#itemsliderMessage2').html('Current slide index: <b>' + itemsliderControl.slideIndex + '</b>');
				});

				var Library = environment.library(uiToolkitLibrary.id,uiToolkitLibrary.version);

				//ImageMap
				var itms = [];
				for (i=0; i<7; i++) {
					var itm = {};
					itm.id = 'robot-part-' + i;
					itm.imagesrc = Library.imageURL('robot-part-' + i +'.png');
					itms.push(itm);
				}

				itms[0].value = 'FDB139'; //Head
				itms[1].value = '416C3D'; //Right Arm
				itms[2].value = 'C38853'; //Right Leg
				itms[3].value = '6FA474'; //Left Arm
				itms[4].value = 'FF7B7B'; //Left Leg
				itms[5].value = '47827F'; //Torso
				itms[6].value = '491E1E'; //Pelvi Area

				var imageMapControl = new controls.ImageMap({
					id:'imageMap',
					parent: 'imageMapControlExample',
					items: itms,
					mainImage: Library.imageURL('robot-main-image.png'),
					mapImage: Library.imageURL('robot-map-image.png')
				});

				imageMapControl.change.bind(function(e) {
					$('#imageMapControlMessage').html('Selected Item: <b>' + imageMapControl.value + '</b>');
				});


				//tab
				var tab1 = {};
				tab1.tabid = "tab1"
			    tab1.isSelected =  true;
			    tab1.headerText =  "Tab1";
			    tab1.tabContent =  "Tab1 Content";
			    
			    var tab2 = {};
				tab2.tabid = "tab2";
			    tab2.headerText =  "Tab2";
			    tab2.tabContent =  "Tab2 Content";
			    
			    var tab3 = {};
				tab3.tabid = "tab3";
			    tab3.headerText =  "Tab3";
			    tab3.tabContent =  "Tab3 Content";

			    var tab4 = {};
				tab4.tabid = "tab4";
			    tab4.headerText =  "Tab4";
			    tab4.tabContent =  "Tab4 Content";

			    var tab5 = {};
				tab5.tabid = "tab5";
			    tab5.headerText =  "Tab5";
			    tab5.tabContent =  "Tab5 Content";

			    var params = {};
			    params.id = 'tabControl';
			    params.parent = 'tabExample1';
			    params.css = {};
			    params.css.tabCss = "tabCss";
			    params.css.headerCss = "headerCss";
			    params.css.contentCss = "tabExampleContent";

			    params.tabs = {};
			    params.tabs.tab1 = tab1;
			    params.tabs.tab2 = tab2;
			    params.tabs.tab3 = tab3;
			    params.tabs.tab4 = tab4;
			    params.tabs.tab5 = tab5;
			    
				var tabControl = new controls.Tab(params);
				tabControl.change.bind(function() {
					$('#tabMessage').html('Selected tab index: <b>' + tabControl.selectedTabIndex + '</b><br/>Selected tab id: <b>' + tabControl.selectedTabId + '</b>');
				});

				var option1 = {};
				option1.tabid = "on"
			    option1.isSelected =  true;
			    option1.headerText =  "On";
			    
			    var option2 = {};
				option2.tabid = "off";
			    option2.headerText =  "Off";

			    var params1 = {};
			    params1.id = 'tabControl1';
			    params1.parent = 'tabExample2';
			    params1.tabHeader = "Switch";
			    
			    params1.tabs = {};
			    params1.tabs.option1 = option1;
			    params1.tabs.option2 = option2;
			    
				var tabControl1 = new controls.Tab(params1);
				tabControl1.change.bind(function() {
					$('#tabMessage2').html('Selected state: <b>' + tabControl1.selectedTabId + '</b>');
				});
				
				var tags = ['one', 'two'];
				var tagList = new controls.TagList({
					id:'tagList',
					parent: 'tagListExample',
					tags: tags
				});
				tagList.change.bind(function() {
					if(tagList.tags.length > 0) {
						$('#tagListMessage').text('Tags: ' + tagList.tags.join(','));
					} else {
						$('#tagListMessage').text('There are no tags');
					}
				});
				$('#tagListMessage').text('Tags: one,two');

				var hoverArea = new controls.HoverArea();
				hoverArea.bind([{
					id :'item1',
					parent: document.getElementById('hoverAreaParent'),
					target: document.getElementById('hoverAreaItem1'),
					direction : 'top'
				},{
					id :'item2',
					parent: document.getElementById('hoverAreaParent'),
					target: document.getElementById('hoverAreaItem2'),
					direction : 'right'
				}]);


			},
			
			function() {
				alert('Failed to load uitoolkit');
			}
		);
	});

</script>
@topic Interactive Control Demos
**/

//documentation.js
/**
This version represents the initial debut of Autodesk's UI Toolkit.
@version 1.0.0
@released 2013-12-17T00:00:00Z
@markdown
**/

/**
- Added theme support for all the ui controls. See {Controls.Themes} for more information.
- Added `change` event support to {Controls.Textbox#change}.
- Added `change` event support to {Controls.Textarea#change}.
- Added `currentTheme` function to {Controls.Utility#currentTheme}.
- Added `loadTheme` function to {Controls.Utility#loadTheme}.
- Added {Controls.LayoutManager} which is used to create the UI layout. 
- Added {Controls.ParameterManager} which is used to create and manage Parameter (see {CoreLibrary.ParameterJSON}) within the Layout.
- Added {Controls.DockLayout} which creates a dockable UI layout.
- Modified {Controls.Slider} to align to the Parameter changes (see {CoreLibrary.LengthParameterJSON}, {CoreLibrary.IntegerParameterJSON} etc.)
- Exported the {Controls.LayoutHandlers} which can be used to add/update existing Layout Handlers
- Exported the {Controls.IGroupHandler} and {Controls.IGroupItemHandler} which are required for creating new Group and GroupItem LayoutHandlers.
- Added some default Group and GroupItem Handlers.
- Added some default ParameterHandlers
@version 1.1.0
@released 2014-05-16T00:00:00Z
@markdown
**/

/**
- Added support of positioning checkbox label on left or right side. See {Controls.CheckboxParams#labelPosition} for more information.
- Added support of applying css on checkbox label. See {Controls.CheckboxParams#labelCss} for more information.
- Added support for an inputbox on the {Controls.Slider} control. see {Controls.SliderParams} for more information.
- Changed the {Controls.LayoutManager#findContainers} method so that it returns the partial layout definition as well.
- Implemented the {Controls.RandomizerControlHandler} Handler to create the Randomization button. See {CoreLibrary.RandomizerConfigurationJSON} and {CoreLibrary.IShapeGenerator#randomize}
- Modified the {Controls.SketchParameterHandler} Handler so that it does not perform serialization/deserialization anymore. The actual Sketch2D object is accepted and returned now.
@version 1.2.0
@released 2014-06-25T00:00:00Z
@markdown
**/

/**
- Fixed a bug in the {Controls.Sketch2D} control that was causing errors in ParameterManager.
- Added the orientation property on the SliderParams which allows creation of a vertical Slider. This works for all existing themes.
- Fixed the id generation for the ids defined on Groups without a type (see {CoreLibrary.LayoutGroupJSON}) in {Controls.LayoutManager}.
- Fixed a {Controls.Slider} bug that was causing incorrect default values in IE for some cases.
- Added the itemhover Event on the {Controls.ImageMap} Control. This even fires when an item is hovered on. This also fires when the hover state changes so that nothing is being hovered.
- Added background image support in {Controls.IGroupHandler}.
- Added the displayIcon support in {Controls.ParameterManager}.
- Changed the {Controls.Itemslider} so that it doesn't use HTML tables any more. 
- Changed the {Controls.Itemslider} so that it can have item images for different UI states(hover,active & normal).
- Added ItemsliderItem to define item structure {Controls.ItemsliderItem}.
- Added support for pageSize in the {Controls.ListParameterHandler}.
@version 1.3.0
@released 2014-08-07T00:00:00Z
@markdown
**/

/**
- Added the beginchange & endchange Event on the {Controls.Textbox} Control.
- Added the beginchange & endchange Event on the {Controls.Textarea} Control.
- Modified {Controls.FileUpload} control, it raises 'uichange' (see {Controls.FileUpload#uichange}) event upon file selection.
- Added cssclass to have item specific extra css in ItemsliderItem. See {Controls.ItemsliderItem}.
- Modified loadCss & loadTheme utility methods so that it always load compiled css. See {Controls.Utility}.
- Modified {Controls.BaseControl} & {Controls.ParameterManager}. Both of these controls now generates html having scoped css.
- Added {Controls.TagList} control.
@version 1.4.0
@released 2014-08-29T00:00:00Z
@markdown
**/

//footer.js
		
		var $ = jQuery.noConflict(true);
		
		initializeLayoutHandlers();		
		initializeParameterHandlers();	
		initializeDefaultFileHandlers();
		Utility.loadTheme(Library.exports.Themes.Tinkercad);

		Handlebars.partials = Handlebars.templates;
		Library.exports.jQuery = $;
		Library.exports.Handlebars = Handlebars;
		Library.exports.Controls = Controls;
		Library.exports.Utility = Utility;
		Library.exports.CoreLibrary = CoreLibrary;
	};

	Host.creativePlatformLibraryaZS9YbvfqUXrev0 = creativePlatformLibraryaZS9YbvfqUXrev0;

})(typeof exports === 'undefined' ? window : exports);

//# sourceMappingURL=library.map
//header.js
/**
Autodesk Creative Platform Viewer
@module c0HjtqUm7Wz
@main
**/
(function(Host){

	"use strict";

	// This list of methods is taken from the following URL
	// https://developer.mozilla.org/en-US/docs/Web/API/console
	var console = {
		dir: function() { },
		error: function() { },
		group: function() { },
		groupCollapsed: function() { },
		groupEnd: function() { },
		info: function() { },
		log: function() { },
		time: function() { },
		timeEnd: function() { },
		trace: function() { },
		warn: function() { }
	};

	var creativePlatformLibraryc0HjtqUm7Wzrev0 = function(Environment, Library){
		
	    var CoreLibrary = Environment.libraryExports("1vxKXGNaLtr", 0);
	    var UIToolkit = Environment.libraryExports("aZS9YbvfqUX", 0);

	    // Three.js directly use 'self' as a global variable (equivalent of window object). 
	    // This becomes a problem when Three.js is wrapped inside the library source code, 
	    // and minified again. Our minification process treats the 'self' variable in Three.js
	    // as a normal local variable and would rename it to something else. As a result,
	    // Three.js cannot access properties on the window object, like requestAnimationFrame, 
	    // devicePixelRatio etc.
	    // 
	    // Defining 'self' variable here would allows Three.js to access window object.
	    var self = Host;
//manifest.js
if (Library) {
	Library.name = "Autodesk Creative Platform Viewer";
	Library.description = "A Viewer for Visualizing 3D Content";
	Library.resources = [
		{ "id": "1kcFpptGphV", "name": "background.jpg" }
		,{ "id": "a6wt4yygZGy", "name": "environment.jpg" }
		,{ "id": "3b2rDlidSNr", "name": "divbackground.jpg" }
		,{ "id": "9Yq6GFiFqDo", "name": "pandent.stl" }
		,{ "id": "jvjXnFCV1jW", "name": "belt.stl" }
		,{ "id": "8CIOqdg99g0", "name": "cufflink.stl" }
		,{ "id": "7wid7QMe4BO", "name": "text.stl" }
		,{ "id": "bTaw4yr787B", "name": "ring.stl" }
		,{ "id": "6qnFEOBoljo", "name": "helix.stl" }
		,{ "id": "hkQ4b5ywGF4", "name": "voronoi.stl" }
		,{ "id": "f5GHsL9kmnI", "name": "torus.stl" }
		,{ "id": "kDR5ymFic8k", "name": "idviz_irr.logluv.dds" }
		,{ "id": "fidHcnHCMJr", "name": "idviz_mipdrop.logluv.dds" }
		,{ "id": "aVuGWY2mWWa", "name": "riverbank_irr.logluv.dds" }
		,{ "id": "gQNf0WWozpF", "name": "riverbank_mipdrop.logluv.dds" }
		,{ "id": "kjAdCcV87Kk", "name": "infinitypool_irr.logluv.dds" }
		,{ "id": "80M5uUPaNLt", "name": "infinitypool_mipdrop.logluv.dds" }
		,{ "id": "lX8VhtGkz8p", "name": "scgeneric_irr.logluv.dds" }
		,{ "id": "ewrQeLK1FK0", "name": "scgeneric_mipdrop.logluv.dds" }
	];
}
//3rd.js
/**
Three.js is a lightweight 3D library with a very low level of complexity — in other words, for dummies.
@opensource Three.js r63
@websiteurl http://threejs.org/
@downloadurl https://github.com/mrdoob/three.js/archive/r63.zip
@licenseurl https://github.com/mrdoob/three.js/blob/master/LICENSE
@licensetext The MIT License

Copyright (c) 2010-2014 three.js authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
@source three.min.js
@symbols THREE
**/

/**
Super simple, fast and easy to use tweening engine which incorporates optimised Robert Penner's equations.
@opensource Tween.js r12
@websiteurl https://github.com/sole/tween.js/
@downloadurl https://github.com/sole/tween.js/archive/r12.zip
@licenseurl https://github.com/sole/tween.js/blob/master/LICENSE
@licensetext The MIT License

Copyright (c) 2010-2012 Tween.js authors.

Easing equations Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
@source tween.js
@symbols TWEEN
**/
//viewcontrols.js
// Customized controls is a set of controls operating orbit, zoom, and pan. It maintains
// the "up" direction as +Y.
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse / touch: three finter swipe
//

THREE.ViewControls = function ( object, domElement ) {
    this.object = object;
    this.domElement = ( domElement !== undefined ) ? domElement : document;

    // Set to false to disable the control
    this.enabled = true;

    // "target" sets the location of focus.
    this.target = new THREE.Vector3();

    // pivot of orbit, generally the center of the model.
    this.pivot = new THREE.Vector3();

    // Set to true to disable zoom.
    this.noZoom = false;
    this.zoomSpeed = 1.0;
    this.scale = 1.0;

    // Limits to how far you can zoom in and out
    this.minDistance = 0;
    this.maxDistance = Infinity;

    // Set to true to disable rotate.
    this.noRotate = false;
    this.rotateSpeed = 3.0;
    this.rotateLeftDelta = 0.0;
    this.rotateUpDelta = 0.0;

    // Set to true to disable pan.
    this.noPan = false;
    this.panDelta = new THREE.Vector3();



    // Set to true to automatically rotate around the target.
    this._autoRotate = false;
    this.autoRotateSpeed = -3.5; // 17 seconds per round when fps is 60

    Object.defineProperty(this, 'autoRotate', {
        enumerable: true,
        get: function(){
            return this._autoRotate;
        },
        set: function(value){
            if (value !== this._autoRotate) {
                this._autoRotate = value;
                if(typeof this.autoRotateChangedCallback === 'function'){
                    this.autoRotateChangedCallback(this._autoRotate);
                }
            }
        }
    });
    // This callback is called when the value of this._autoRotate is changed.
    this.autoRotateChangedCallback=undefined;

    // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.
    this.minPolarAngle = 0.0; // radians
    this.maxPolarAngle = Math.PI; // radians

    this.orbitMode = THREE.ViewControls.OrbitMode.XY;

    this.lastPosition = new THREE.Vector3(); // Record last camera position.

    // Internal event callback functions.
    var rotateStart = new THREE.Vector2();
    var rotateEnd = new THREE.Vector2();
    var panStart = new THREE.Vector2();
    var panEnd = new THREE.Vector2();
    var zoomStart = new THREE.Vector2();
    var zoomyEnd = new THREE.Vector2();

    var state = THREE.ViewControls.STATE.NONE;
    var self = this;
    function onMouseEnter( event ) {
        if (event.which === 1 && state === THREE.ViewControls.STATE.ROTATE) {
            rotateStart.set( event.clientX, event.clientY );
        }
        else if (event.which === 3 && state === THREE.ViewControls.STATE.PAN) {
            panStart.set( event.clientX, event.clientY );
        }
        else {
            state = THREE.ViewControls.STATE.NONE;
        }
    }

    function onMouseDown( event ) {
        self.autoRotate = false;

        if ( self.enabled === false ) { return; }
        
        event.preventDefault();
        event.stopPropagation();

        if ( event.button === 0 ) {
            if ( self.noRotate === true ) { return; }

            state = THREE.ViewControls.STATE.ROTATE;
            rotateStart.set( event.clientX, event.clientY );

        } else if ( event.button === 1 ) {
            if ( self.noZoom === true ) { return; }

            state = THREE.ViewControls.STATE.DOLLY;
            zoomStart.set( event.clientX, event.clientY );

        } else if ( event.button === 2 ) {
            if ( self.noPan === true ) { return; }

            state = THREE.ViewControls.STATE.PAN;
            panStart.set( event.clientX, event.clientY );
        }

        self.domElement.addEventListener( 'mousemove', onMouseMove, false );
        self.domElement.addEventListener( 'mouseup', onMouseUp, false );
    }

    function onMouseMove( event ) {
        self.autoRotate = false;

        if ( self.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        var element = self.domElement === document ? self.domElement.body : self.domElement;
        var delta = new THREE.Vector2();

        if ( state === THREE.ViewControls.STATE.ROTATE ) {

            if ( self.noRotate === true ) return;

            rotateEnd.set( event.clientX, event.clientY );
            delta.subVectors( rotateEnd, rotateStart );

            // rotating across whole screen goes 360 degrees around
            self.rotateLeft( 2 * Math.PI * delta.x / element.clientWidth * self.rotateSpeed );
            // rotating up and down along whole screen attempts to go 360, but limited to 180
            self.rotateUp( 2 * Math.PI * delta.y / element.clientHeight * self.rotateSpeed );

            rotateStart.copy( rotateEnd );
        } else if ( state === THREE.ViewControls.STATE.DOLLY ) {

            if ( self.noZoom === true ) return;

            zoomEnd.set( event.clientX, event.clientY );
            delta.subVectors( zoomEnd, zoomStart );

            if ( delta.y > 0 ) {
                self.zoomIn();
            } else {
                self.zoomOut();
            }

            zoomStart.copy( zoomEnd );
        } else if ( state === THREE.ViewControls.STATE.PAN ) {
            if ( self.noPan === true ) return;

            panEnd.set( event.clientX, event.clientY );
            delta.subVectors( panEnd, panStart );
            
            self.pan( delta );

            panStart.copy( panEnd );
        }
        self.update();
    }

    function onMouseUp(  event  ) {
        self.autoRotate = false;

        if ( self.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        self.domElement.removeEventListener( 'mousemove', onMouseMove, false );
        self.domElement.removeEventListener( 'mouseup', onMouseUp, false );

        state = THREE.ViewControls.STATE.NONE;
    }

    function onMouseWheel( event ) {
        self.autoRotate = false;

        if ( self.enabled === false || self.noZoom === true ) return;

        event.preventDefault();
        event.stopPropagation();

        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9
            delta = event.wheelDelta;

        } else if ( event.detail ) { // Firefox
            delta = - event.detail;
        }

        if ( delta > 0 ) {
            self.zoomOut();
        } else {
            self.zoomIn();
        }
    }
    
    function touchstart( event ) {
        if ( self.enabled === false ) { return; }

        switch ( event.touches.length ) {

            case 1: // one-fingered touch: rotate
                if ( self.noRotate === true ) { return; }

                state = THREE.ViewControls.STATE.TOUCH_ROTATE;
                rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                break;

            case 2: // two-fingered touch: dolly
                if ( self.noZoom === true ) { return; }

                state = THREE.ViewControls.STATE.TOUCH_DOLLY;

                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                var distance = Math.sqrt( dx * dx + dy * dy );
                zoomStart.set( 0, distance );
                break;

            case 3: // three-fingered touch: pan
                if ( self.noPan === true ) { return; }

                state = THREE.ViewControls.STATE.TOUCH_PAN;
                panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                break;

            default:
                state = THREE.ViewControls.STATE.NONE;

        }
    }

    function touchmove( event ) {
        if ( self.enabled === false ) { return; }

        event.preventDefault();
        event.stopPropagation();

        var element = self.domElement === document ? self.domElement.body : self.domElement;
        var delta = new THREE.Vector2();

        switch ( event.touches.length ) {

            case 1: // one-fingered touch: rotate
                if ( self.noRotate === true ) { return; }
                if ( state !== THREE.ViewControls.STATE.TOUCH_ROTATE ) { return; }

                rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                delta.subVectors( rotateEnd, rotateStart );

                // rotating across whole screen goes 360 degrees around
                self.rotateLeft( 2 * Math.PI * delta.x / element.clientWidth * self.rotateSpeed );
                // rotating up and down along whole screen attempts to go 360, but limited to 180
                self.rotateUp( 2 * Math.PI * delta.y / element.clientHeight * self.rotateSpeed );

                rotateStart.copy( rotateEnd );
                break;

            case 2: // two-fingered touch: dolly
                if ( self.noZoom === true ) { return; }
                if ( state !== THREE.ViewControls.STATE.TOUCH_DOLLY ) { return; }

                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                var distance = Math.sqrt( dx * dx + dy * dy );

                zoomEnd.set( 0, distance );
                delta.subVectors( zoomEnd, zoomStart );

                if ( delta.y > 0 ) {
                    self.zoomOut();

                } else {
                    self.zoomIn();
                }

                zoomStart.copy( zoomEnd );
                break;

            case 3: // three-fingered touch: pan
                if ( self.noPan === true ) { return; }
                if ( state !== THREE.ViewControls.STATE.TOUCH_PAN ) { return; }

                panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                delta.subVectors( panEnd, panStart );
                
                self.pan( delta );

                panStart.copy( panEnd );
                break;

            default:
                state = THREE.ViewControls.STATE.NONE;
        }
    }

    function touchend( /* event */ ) {
        if ( self.enabled === false ) { return; }

        state = THREE.ViewControls.STATE.NONE;
    }

    this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
    this.domElement.addEventListener( 'mouseenter', onMouseEnter, false );
    this.domElement.addEventListener( 'mousedown', onMouseDown, false );
    this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
    this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox

    this.domElement.addEventListener( 'touchstart', touchstart, false );
    this.domElement.addEventListener( 'touchend', touchend, false );
    this.domElement.addEventListener( 'touchmove', touchmove, false );
};

// OrbitMode enum.
THREE.ViewControls.OrbitMode = {
    XY: 0,
    X:  1,
    Y:  2
};

// State enum.
THREE.ViewControls.STATE = {
    NONE : -1,
    ROTATE : 0,
    DOLLY : 1,
    PAN : 2,
    TOUCH_ROTATE : 3,
    TOUCH_DOLLY : 4,
    TOUCH_PAN : 5
};

THREE.ViewControls.prototype = Object.create( THREE.EventDispatcher.prototype );

THREE.ViewControls.prototype.rotateLeft = function( angle ){
    if(this.orbitMode === THREE.ViewControls.OrbitMode.X){
        return;
    }

    if ( angle === undefined ) { angle = Math.PI / 1800 * this.autoRotateSpeed; }
    this.rotateLeftDelta -= angle;
};

THREE.ViewControls.prototype.rotateUp = function( angle ){
    if(this.orbitMode === THREE.ViewControls.OrbitMode.Y){
        return;
    }

    if ( angle === undefined ) { angle = Math.PI / 1800 * this.autoRotateSpeed; }
    this.rotateUpDelta -= angle;
};

THREE.ViewControls.prototype.pan = function ( delta ) {
    var element = this.domElement === document ? this.domElement.body : this.domElement;
    var self = this;

    var panLeft = function ( distance ) {
        var panOffset = new THREE.Vector3();
        var te = self.object.matrix.elements;
        // get X column of matrix
        panOffset.set( te[0], te[1], te[2] );
        panOffset.multiplyScalar(-distance);
        
        self.panDelta.add( panOffset );
    };

    var panUp = function ( distance ) {
        var panOffset = new THREE.Vector3();
        var te = self.object.matrix.elements;
        // get Y column of matrix
        panOffset.set( te[4], te[5], te[6] );
        panOffset.multiplyScalar(distance);
        
        self.panDelta.add( panOffset );
    };

    if ( this.object.fov !== undefined ) {
        // perspective
        var position = this.object.position;
        var offset = position.clone().sub( this.target );
        var targetDistance = offset.length();

        // half of the fov is center to top of screen
        targetDistance *= Math.tan( (this.object.fov/2) * Math.PI / 180.0 );
        // we actually don't use screenWidth, since perspective camera is fixed to screen height
        panLeft( 2 * delta.x * targetDistance / element.clientHeight );
        panUp( 2 * delta.y * targetDistance / element.clientHeight );

    } else if ( this.object.top !== undefined ) {
        // orthographic
        panLeft( delta.x * (this.object.right - this.object.left) / element.clientWidth );
        panUp( delta.y * (this.object.top - this.object.bottom) / element.clientHeight );
    }
};

THREE.ViewControls.prototype.zoomIn = function ( scale ) {
    if ( scale === undefined ) {
        scale = Math.pow( 0.95, this.zoomSpeed );
    }

    this.scale /= scale;
};

THREE.ViewControls.prototype.zoomOut = function ( scale ) {
    if ( scale === undefined ) {
        scale = Math.pow( 0.95, this.zoomSpeed );
    }

    this.scale *= scale;
};

THREE.ViewControls.prototype.lookAt = function(point, normal, right) {
    this.autoRotate = false;

    //let's try target and position first
    this.object.target = new THREE.Vector3(0, 0, 0);

    var self = this;
    this.tweenTarget = new TWEEN.Tween(self.object.target).to({
        x: point[0], y: point[1], z: point[2]
    }).easing(TWEEN.Easing.Linear.None).onUpdate(function () {
        self.object.lookAt(self.object.target);
    }).onComplete(function () {
        self.object.lookAt(new THREE.Vector3(point[0], point[1], point[2]));
    }).start();

    var targetLen = this.object.position.length();
    var currentNormal = this.object.position.clone().sub(this.object.target).normalize();
    var newNormal = new THREE.Vector3(normal[0], normal[1], normal[2]);
    newNormal.normalize();
    

    self.tweenPos = new TWEEN.Tween(currentNormal).to({
        x: newNormal.x, y: newNormal.y, z: newNormal.z
    }).easing(TWEEN.Easing.Linear.None).onUpdate(function () {
        var cameraPos = self.object.target.clone();
        cameraPos.add(currentNormal.clone().normalize().multiplyScalar(targetLen));
        self.object.position = cameraPos;
        self.object.lookAt(self.object.target);
    }).onComplete(function () {
        self.object.lookAt(new THREE.Vector3(point[0], point[1], point[2]));
    }).start();
};

THREE.ViewControls.prototype.update = function () {
    var cameraDirty = false;
    var EPS = 0.001;

    TWEEN.update();

    var position = this.object.position;
    var offset = position.clone().sub( this.target );

    // angle from z-axis around y-axis
    var rotateLeftAngle = Math.atan2( offset.x, offset.z );

    if ( this.autoRotate ) {
        cameraDirty = true;
        this.rotateLeft();

    }
    else if( this.tween ){
        cameraDirty = true;
        this.tween.update();
    }

    rotateLeftAngle += this.rotateLeftDelta;

    var rotateUpAngle = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );
    if(this.pivot){
        if((rotateUpAngle + this.rotateUpDelta) < (this.maxPolarAngle - EPS) && (rotateUpAngle + this.rotateUpDelta) > (this.minPolarAngle + EPS) ){
            rotateUpAngle = rotateUpAngle + this.rotateUpDelta;
        }
        else{
            this.rotateUpDelta = 0;
        }
    }
    else{
        rotateUpAngle += this.rotateUpDelta;
        rotateUpAngle = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, rotateUpAngle ) );
        // restrict rotateUpAngle to be betwee EPS and PI-EPS
        rotateUpAngle = Math.max( EPS, Math.min( Math.PI - EPS, rotateUpAngle ) );
    }

    var radius = offset.length() * this.scale;

    // restrict radius to be between desired limits
    radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );
    
    // move target to panned location
    this.target.add( this.panDelta );
    position.copy( this.target ).add( offset );
    this.object.lookAt( this.target );  

    if(this.pivot){
        var viewDir = position.clone().sub(this.pivot).normalize();
        var viewDirV = position.clone().sub(this.target).normalize();
        var viewUp = this.object.up.clone().applyQuaternion(this.object.quaternion).normalize();
        var viewRight = viewDirV.clone().cross(viewUp).normalize();
        var targetDist = position.distanceTo(this.pivot) * this.scale;
        var targetDistV = position.distanceTo(this.target) * this.scale;

        if(this.rotateLeftDelta){//horizental
            cameraDirty = true;
            var rotation = new THREE.Quaternion();
            var delta;

            if(Math.abs(this.rotateLeftDelta) > EPS * 0.1 * Math.PI){
                delta = this.rotateLeftDelta * 0.3;
                this.rotateLeftDelta = 0.7 * this.rotateLeftDelta;
            }
            else{
                delta = this.rotateLeftDelta;
                this.rotateLeftDelta = 0;
            }
            rotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), delta);
            viewDir.applyQuaternion(rotation).normalize();
            viewDirV.applyQuaternion(rotation).normalize(); 
            viewRight.applyQuaternion(rotation).normalize();
        }

        if(this.rotateUpDelta){//vertical
            cameraDirty = true;

            var delta;
            if(Math.abs(this.rotateUpDelta) > EPS * 0.1 * Math.PI){
                delta = this.rotateUpDelta * 0.3;
                this.rotateUpDelta = 0.7 * this.rotateUpDelta;
            }
            else{
                delta = this.rotateUpDelta;
                this.rotateUpDelta = 0;
            }

            var worldD = new THREE.Vector3(0, 0, 1);
            var worldR = new THREE.Vector3(1, 0, 0);
            var vRightProj =  worldD.multiplyScalar( worldD.dot(viewRight) ).add( worldR.multiplyScalar ( worldR.dot(viewRight) ));
            vRightProj.normalize();
            var rotation = new THREE.Quaternion();
            rotation.setFromAxisAngle(vRightProj, -delta);
            viewDir.applyQuaternion(rotation).normalize();
            viewDirV.applyQuaternion(rotation).normalize(); 
        }
        position.copy(this.pivot).add(viewDir.multiplyScalar(targetDist));
        this.target.copy(position).add(viewDirV.negate().multiplyScalar(targetDistV));
        this.object.lookAt(this.target);
    }
    else{
        offset.x = radius * Math.sin( rotateUpAngle ) * Math.sin( rotateLeftAngle );
        offset.y = radius * Math.cos( rotateUpAngle );
        offset.z = radius * Math.sin( rotateUpAngle ) * Math.cos( rotateLeftAngle );

        position.copy( this.target ).add( offset );

        this.object.lookAt( this.target );  
    }
    
    this.scale = 1;
    this.panDelta.set(0,0,0);

    if ( this.lastPosition.distanceTo( this.object.position ) > 0 ) {
        cameraDirty = true;
        this.dispatchEvent( { type: 'change' } );
        this.lastPosition.copy( this.object.position );
    }

    return cameraDirty;
};

//detector.js
/*
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */

var Detector = {

	canvas: !! window.CanvasRenderingContext2D,
	webgl: ( function () { try { var canvas = document.createElement( 'canvas' ); return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ); } catch( e ) { return false; } } )(),
	workers: !! window.Worker,
	fileapi: window.File && window.FileReader && window.FileList && window.Blob,

	getWebGLErrorMessage: function () {

		var element = document.createElement( 'div' );
		element.id = 'webgl-error-message';
		element.style.fontFamily = 'monospace';
		element.style.fontSize = '13px';
		element.style.fontWeight = 'normal';
		element.style.textAlign = 'center';
		element.style.background = '#fff';
		element.style.color = '#000';
		element.style.padding = '1.5em';
		element.style.width = '400px';
		element.style.margin = '5em auto 0';

		if ( ! this.webgl ) {

			element.innerHTML = window.WebGLRenderingContext ? [
				'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />',
				'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
			].join( '\n' ) : [
				'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>',
				'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
			].join( '\n' );

		}

		return element;

	},

	addGetWebGLMessage: function ( parameters ) {

		var parent, id, element;

		parameters = parameters || {};

		parent = parameters.parent !== undefined ? parameters.parent : document.body;
		id = parameters.id !== undefined ? parameters.id : 'oldie';

		element = Detector.getWebGLErrorMessage();
		element.id = id;

		parent.appendChild( element );

	}

};
//copyshader.js
/*
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

THREE.CopyShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join("\n")

};

//ssaoshader.js
/*
 * @author alteredq / http://alteredqualia.com/
 *
 * Screen-space ambient occlusion shader
 * - ported from
 *   SSAO GLSL shader v1.2
 *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)
 *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)
 * - modifications
 * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)
 * - refactoring and optimizations
 */

THREE.SSAOShader = {

	uniforms: {

		"tDiffuse":     { type: "t", value: null },
		"tDepth":       { type: "t", value: null },
		"size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
		"cameraNear":   { type: "f", value: 1 },
		"cameraFar":    { type: "f", value: 100 },
		"onlyAO":       { type: "i", value: 0 },
		"aoClamp":      { type: "f", value: 0.5 },
		"lumInfluence": { type: "f", value: 0.5 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float cameraNear;",
		"uniform float cameraFar;",

		"uniform bool onlyAO;",      // use only ambient occlusion pass?

		"uniform vec2 size;",        // texture width, height
		"uniform float aoClamp;",    // depth clamp - reduces haloing at screen edges

		"uniform float lumInfluence;",  // how much luminance affects occlusion

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDepth;",

		"varying vec2 vUv;",

		// "#define PI 3.14159265",
		"#define DL 2.399963229728653",  // PI * ( 3.0 - sqrt( 5.0 ) )
		"#define EULER 2.718281828459045",

		// helpers

		"float width = size.x;",   // texture width
		"float height = size.y;",  // texture height

		"float cameraFarPlusNear = cameraFar + cameraNear;",
		"float cameraFarMinusNear = cameraFar - cameraNear;",
		"float cameraCoef = 2.0 * cameraNear;",

		// user variables

		"const int samples = 8;",     // ao sample count
		"const float radius = 5.0;",  // ao radius

		"const bool useNoise = false;",      // use noise instead of pattern for sample dithering
		"const float noiseAmount = 0.0003;", // dithering amount

		"const float diffArea = 0.4;",   // self-shadowing reduction
		"const float gDisplace = 0.4;",  // gauss bell center


		// RGBA depth

		"float unpackDepth( const in vec4 rgba_depth ) {",

			"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"float depth = dot( rgba_depth, bit_shift );",
			"return depth;",

		"}",

		// generating noise / pattern texture for dithering

		"vec2 rand( const vec2 coord ) {",

			"vec2 noise;",

			"if ( useNoise ) {",

				"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
				"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );",

				"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",

			"} else {",

				"float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );",
				"float gg = fract( coord.t * ( height / 2.0 ) );",

				"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",

			"}",

			"return ( noise * 2.0  - 1.0 ) * noiseAmount;",

		"}",

		"float readDepth( const in vec2 coord ) {",

			// "return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );",
			"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );",


		"}",

		"float compareDepths( const in float depth1, const in float depth2, inout int far ) {",

			"float garea = 2.0;",                         // gauss bell width
			"float diff = ( depth1 - depth2 ) * 100.0;",  // depth difference (0-100)

			// reduce left bell width to avoid self-shadowing

			"if ( diff < gDisplace ) {",

				"garea = diffArea;",

			"} else {",

				"far = 1;",

			"}",

			"float dd = diff - gDisplace;",
			"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );",
			"return gauss;",

		"}",

		"float calcAO( float depth, float dw, float dh ) {",

			"float dd = radius - depth * radius;",
			"vec2 vv = vec2( dw, dh );",

			"vec2 coord1 = vUv + dd * vv;",
			"vec2 coord2 = vUv - dd * vv;",

			"float temp1 = 0.0;",
			"float temp2 = 0.0;",

			"int far = 0;",
			"temp1 = compareDepths( depth, readDepth( coord1 ), far );",

			// DEPTH EXTRAPOLATION

			"if ( far > 0 ) {",

				"temp2 = compareDepths( readDepth( coord2 ), depth, far );",
				"temp1 += ( 1.0 - temp1 ) * temp2;",

			"}",

			"return temp1;",

		"}",

		"void main() {",

			"vec2 noise = rand( vUv );",
			"float depth = readDepth( vUv );",

			"float tt = clamp( depth, aoClamp, 1.0 );",

			"float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );",
			"float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );",

			"float ao = 0.0;",

			"float dz = 1.0 / float( samples );",
			"float z = 1.0 - dz / 2.0;",
			"float l = 0.0;",

			"for ( int i = 0; i <= samples; i ++ ) {",

				"float r = sqrt( 1.0 - z );",

				"float pw = cos( l ) * r;",
				"float ph = sin( l ) * r;",
				"ao += calcAO( depth, pw * w, ph * h );",
				"z = z - dz;",
				"l = l + DL;",

			"}",

			"ao /= float( samples );",
			"ao = 1.0 - ao;",

			"vec4 color4 = texture2D( tDiffuse, vUv );",
			"vec3 color = color4.rgb;",
			"float alpha = color4.a;",

			"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );",
			"float lum = dot( color.rgb, lumcoeff );",
			"vec3 luminance = vec3( lum );",

			"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // mix( color * ao, white, luminance )

			"if ( onlyAO ) {",

				"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // ambient occlusion only

			"}",

			"gl_FragColor = vec4( final, alpha + 0.01);",

		"}"

	].join("\n")

};
//fxaashader.js
/**
 * @author alteredq / http://alteredqualia.com/
 * @author davidedc / http://www.sketchpatch.net/
 *
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

THREE.FXAAShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec2 resolution;",

		"varying vec2 vUv;",

		"#define FXAA_REDUCE_MIN   (1.0/128.0)",
		"#define FXAA_REDUCE_MUL   (1.0/8.0)",
		"#define FXAA_SPAN_MAX     8.0",

		"void main() {",

			"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
			"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
			"vec3 rgbM  = rgbaM.xyz;",
			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float lumaNW = dot( rgbNW, luma );",
			"float lumaNE = dot( rgbNE, luma );",
			"float lumaSW = dot( rgbSW, luma );",
			"float lumaSE = dot( rgbSE, luma );",
			"float lumaM  = dot( rgbM,  luma );",
			"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
			"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",

			"vec2 dir;",
			"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
			"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",

			"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",

			"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
			"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
				  "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
						"dir * rcpDirMin)) * resolution;",
			"vec4 rgbA = (1.0/2.0) * (",
        	"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +",
			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));",
    		"vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (",
			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +",
      		"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));",
    		"float lumaB = dot(rgbB, vec4(luma, 0.0));",

			"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",

				"gl_FragColor = rgbA;",

			"} else {",
				"gl_FragColor = rgbB;",

			"}",

		"}"

	].join("\n")

};
//maskpass.js
/*
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MaskPass = function ( scene, camera ) {

	this.scene = scene;
	this.camera = camera;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;

};

THREE.MaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		// don't update color or depth

		context.colorMask( false, false, false, false );
		context.depthMask( false );

		// set up stencil

		var writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		context.enable( context.STENCIL_TEST );
		context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
		context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
		context.clearStencil( clearValue );

		// draw into the stencil buffer

		renderer.render( this.scene, this.camera, readBuffer, this.clear );
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		// re-enable update of color and depth

		context.colorMask( true, true, true, true );
		context.depthMask( true );

		// only render where stencil is set to 1

		context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
		context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

	}

};


THREE.ClearMaskPass = function () {

	this.enabled = true;

};

THREE.ClearMaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		context.disable( context.STENCIL_TEST );

	}

};

//shaderpass.js
/*
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShaderPass = function ( shader, textureID ) {

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	this.renderToScreen = false;

	this.enabled = true;
	this.needsSwap = true;
	this.clear = false;

};

THREE.ShaderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer;

		}

		THREE.EffectComposer.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera );

		} else {

			renderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, this.clear );

		}

	}

};

//effectcomposer.js
/*
 * @author alteredq / http://alteredqualia.com/
 */

THREE.EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var width = window.innerWidth || 1;
		var height = window.innerHeight || 1;
		var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

		renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.EffectComposer relies on THREE.CopyShader" );

	this.copyPass = new THREE.ShaderPass( THREE.CopyShader );

};

THREE.EffectComposer.prototype = {

	swapBuffers: function() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	},

	addPass: function ( pass ) {

		this.passes.push( pass );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},

	render: function ( delta ) {

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		var maskActive = false;

		var pass, i, il = this.passes.length;

		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( !pass.enabled ) continue;

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( pass instanceof THREE.MaskPass ) {

				maskActive = true;

			} else if ( pass instanceof THREE.ClearMaskPass ) {

				maskActive = false;

			}

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			renderTarget = this.renderTarget1.clone();

			renderTarget.width = window.innerWidth;
			renderTarget.height = window.innerHeight;

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		var renderTarget = this.renderTarget1.clone();

		renderTarget.width = width;
		renderTarget.height = height;

		this.reset( renderTarget );

	}

};

// shared ortho camera

THREE.EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

THREE.EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );

THREE.EffectComposer.scene = new THREE.Scene();
THREE.EffectComposer.scene.add( THREE.EffectComposer.quad );

//renderpass.js
/*
 * @author alteredq / http://alteredqualia.com/
 */

THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

};

THREE.RenderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		this.scene.overrideMaterial = this.overrideMaterial;

		if ( this.clearColor ) {

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		renderer.render( this.scene, this.camera, readBuffer, this.clear );

		if ( this.clearColor ) {

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

		}

		this.scene.overrideMaterial = null;

	}

};

//globals.js
		var ERROR_ARGUMENTS_MESSAGE = 'Unexpected arguments. Please refer to documentation.';
		
		var negxurl = Library.resourceURL("negx.jpg");
		var negyurl = Library.resourceURL("negy.jpg");
		var negzurl = Library.resourceURL("negz.jpg");
		var posxurl = Library.resourceURL("posx.jpg");
		var posyurl = Library.resourceURL("posy.jpg");
		var poszurl = Library.resourceURL("posz.jpg");

		var Mesh3D = CoreLibrary.Mesh3D;
		var Plugin = CoreLibrary.Plugin;
		var $ = UIToolkit.jQuery;
//material.js
/** 
Internal / Private data. This is not exported so clients can not find it or use it.
@class _Materials
@private
**/
var _Materials = { 
    
    /**
    Cache the generated material objects
    @property
    */
    _materials: {},

    _initialized: false,

    _initialize: function() {
        /*
        Customized phong material support pnoise bump, not support texture bump which supported by THREE.MeshPhongMaterial. 
        */
        THREE.CustomizedPhongMaterial = function ( parameters ) {
          THREE.ShaderMaterial.call( this );

          this.vertexShader = [
              "#define PHONG",
              "varying vec3 vViewPosition;",
              "varying vec3 vNormal;",
              THREE.ShaderChunk[ "map_pars_vertex" ],
              THREE.ShaderChunk[ "lightmap_pars_vertex" ],
              THREE.ShaderChunk[ "envmap_pars_vertex" ],
              THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
              THREE.ShaderChunk[ "color_pars_vertex" ],
              THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
              THREE.ShaderChunk[ "skinning_pars_vertex" ],
              THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
              "void main() {",

                  THREE.ShaderChunk[ "map_vertex" ],
                  THREE.ShaderChunk[ "lightmap_vertex" ],
                  THREE.ShaderChunk[ "color_vertex" ],

                  THREE.ShaderChunk[ "morphnormal_vertex" ],
                  THREE.ShaderChunk[ "skinbase_vertex" ],
                  THREE.ShaderChunk[ "skinnormal_vertex" ],
                  THREE.ShaderChunk[ "defaultnormal_vertex" ],

                  "vNormal = normalize( transformedNormal );",

                  THREE.ShaderChunk[ "morphtarget_vertex" ],
                  THREE.ShaderChunk[ "skinning_vertex" ],
                  THREE.ShaderChunk[ "default_vertex" ],

                  "vViewPosition = -mvPosition.xyz;",

                  THREE.ShaderChunk[ "worldpos_vertex" ],
                  THREE.ShaderChunk[ "envmap_vertex" ],
                  THREE.ShaderChunk[ "lights_phong_vertex" ],
                  THREE.ShaderChunk[ "shadowmap_vertex" ],

              "}"

          ].join("\n");

          this.fragmentShader = [
              "uniform vec3 diffuse;",
              "uniform float opacity;",
              "uniform vec3 ambient;",
              "uniform vec3 emissive;",
              "uniform vec3 specular;",
              "uniform float shininess;",

              THREE.ShaderChunk[ "color_pars_fragment" ],
              THREE.ShaderChunk[ "map_pars_fragment" ],
              THREE.ShaderChunk[ "lightmap_pars_fragment" ],
              THREE.ShaderChunk[ "envmap_pars_fragment" ],
              THREE.ShaderChunk[ "fog_pars_fragment" ],
              THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
              THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
              THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
              THREE.ShaderChunk[ "normalmap_pars_fragment" ],
              THREE.ShaderChunk[ "specularmap_pars_fragment" ],

              "void main() {",

                  "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

                  THREE.ShaderChunk[ "map_fragment" ],
                  THREE.ShaderChunk[ "alphatest_fragment" ],
                  THREE.ShaderChunk[ "specularmap_fragment" ],

                  THREE.ShaderChunk[ "lights_phong_fragment" ],

                  THREE.ShaderChunk[ "lightmap_fragment" ],
                  THREE.ShaderChunk[ "color_fragment" ],
                  THREE.ShaderChunk[ "envmap_fragment" ],
                  THREE.ShaderChunk[ "shadowmap_fragment" ],

                  THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

                  THREE.ShaderChunk[ "fog_fragment" ],

              "}"

          ].join("\n");

          // To supporting lighting for this material, we need set lights in the application by scene's lights!
          this.lights = []; 

          // Extended variables can be used freely, support change after material created.
          this.shading = THREE.SmoothShading;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = 'round';
          this.wireframeLinejoin = 'round';

          // Extended variables used only during compile shader, not support change after material created.
          this.metal = false;
          this.perPixel = true;
          this.fog = true;
          this.wrapAround = false;

          // Extended variables to update uniforms, support change after material created. But we need define property for this variable, and 
          // update uniforms in the property set function and during initialze.
          this.color = new THREE.Color( 0xffffff );
          this.ambient = new THREE.Color( 0xffffff );
          this.emissive = new THREE.Color( 0x000000 );
          this.specular = new THREE.Color( 0x111111 );
          this.shininess = 30;

          this.wrapRGB = new THREE.Vector3( 1, 1, 1 );
          this.bumpDensity = 2.0;
          this.bumpAmplitude = 0.05;
          this.bumpType = 1;

          this.envMap = null;
          this.combine = THREE.MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;

          this.setValues( parameters );

          // Initialze uniforms.
          this.uniforms = THREE.UniformsUtils.clone(THREE.ShaderLib.phong.uniforms);
          // Extend customized bump scale to support pnoise bump.
          this.uniforms['bumpDensity']= { type: "f", value: this.bumpDensity };
          this.uniforms['bumpAmplitude'] = {type:"f", value: this.bumpAmplitude};
          this.uniforms['bumpType'] = { type: "i", value: this.bumpType };

          this.uniforms.diffuse.value = this.color;
          this.uniforms.ambient.value = this.ambient;
          this.uniforms.emissive.value = this.emissive;
          this.uniforms.specular.value = this.specular;
          this.uniforms.shininess.value = this.shininess;
          this.uniforms.wrapRGB.value = this.wrapRGB;
          this.uniforms.envMap.value = this.envMap;
          this.uniforms.combine.value = this.combine;
          this.uniforms.reflectivity.value = this.reflectivity;
          this.uniforms.refractionRatio.value = this.refractionRatio;
          this.uniforms.opacity.value = this.opacity;

          var self = this;
          Object.defineProperty(this, 'bumpDensity', {
              set: function(value){
                  self.uniforms.bumpDensity.value = value;
              },
              get: function() {
                  return self.uniforms.bumpDensity.value;
              }
          });
          Object.defineProperty(this, 'bumpAmplitude', {
              set: function(value){
                  self.uniforms.bumpAmplitude.value = value;
              },
              get: function() {
                  return self.uniforms.bumpAmplitude.value;
              }
          });
          Object.defineProperty(this, 'bumpType', {
              set: function(value){
                  self.uniforms.bumpType.value = value;
              },
              get: function() {
                  return self.uniforms.bumpType.value;
              }
          });
          Object.defineProperty(this, 'color', {
              set: function(value){
                  self.uniforms.diffuse.value = value;
              },
              get: function() {
                  return self.uniforms.diffuse.value;
              }
          });
          Object.defineProperty(this, 'ambient', {
              set: function(value){
                  self.uniforms.ambient.value = value;
              },
              get: function() {
                  return self.uniforms.ambient.value;
              }
          });
          Object.defineProperty(this, 'emissive', {
              set: function(value){
                  self.uniforms.emissive.value = value;
              },
              get: function() {
                  return self.uniforms.emissive.value;
              }
          });
          Object.defineProperty(this, 'specular', {
              set: function(value){
                  self.uniforms.specular.value = value;
              },
              get: function() {
                  return self.uniforms.specular.value;
              }
          });
          Object.defineProperty(this, 'shininess', {
              set: function(value){
                  self.uniforms.shininess.value = value;
              },
              get: function() {
                  return self.uniforms.shininess.value;
              }
          });
          Object.defineProperty(this, 'wrapRGB', {
              set: function(value){
                  self.uniforms.wrapRGB.value = value;
              },
              get: function() {
                  return self.uniforms.wrapRGB.value;
              }
          });
          Object.defineProperty(this, 'envMap', {
              set: function(value){
                  self.uniforms.envMap.value = value;
              },
              get: function() {
                  return self.uniforms.envMap.value;
              }
          });
          Object.defineProperty(this, 'combine', {
              set: function(value){
                  self.uniforms.combine.value = value;
              },
              get: function() {
                  return self.uniforms.combine.value;
              }
          });
          Object.defineProperty(this, 'reflectivity', {
              set: function(value){
                  self.uniforms.reflectivity.value = value;
              },
              get: function() {
                  return self.uniforms.reflectivity.value;
              }
          });
          Object.defineProperty(this, 'refractionRatio', {
              set: function(value){
                  self.uniforms.refractionRatio.value = value;
              },
              get: function() {
                  return self.uniforms.refractionRatio.value;
              }
          });
          Object.defineProperty(this, 'opacity', {
              set: function(value){
                  self.uniforms.opacity.value = value;
              },
              get: function(){
                  return self.uniforms.opacity.value;
              }
          });
        };
        THREE.CustomizedPhongMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );

        this._initialized = true;
    },

    /**
    Generate the material object by speficied name
    @method _generateMaterial
    */
    _generateMaterial: function(materialName) {

        var mat = this._materials[materialName];
        var isMobileAgent = function() {
            var userAgent = navigator.userAgent.toLowerCase();
            var reAry = ["iphone", "ipad", "android"];
            var reStr = "(" + reAry.join("|") + ")";
            return userAgent.match(new RegExp(reStr,"i"));
        };

        if (!this._initialized) {
            this._initialize();
        }

        if (mat !== undefined) {
            return mat;
        }

        var setLightParams = function(mat, dirLight1, dirLight2, skyLight, ambientLight, pointLight1, pointlight2){
            mat.dirLight1 = dirLight1;
            mat.dirLight2 = dirLight2;
            mat.skyLight = skyLight;
            mat.ambientLight = ambientLight;
            if(pointLight1 !== undefined){
                mat.pointLight1 = pointLight1;
            }

            if(pointlight2 !== undefined){
                mat.pointlight2 = pointlight2;
            }
        };

        switch (materialName) {
            //colored plastic
            case 'red plastic' :
                mat = new THREE.CustomizedPhongMaterial({color:  0xa3212e, ambient: 0xa3212e, bumpType: 1});
                break;

            //polished plastic, similar as polyamide
            case 'red polyamide':
            case 'red polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xa3212e, specular: 0x444444, ambient: 0xa3212e, bumpType: 1});
                setLightParams(mat, 0.65, 0.25, 0.05, '0x555555');
                break;
            case 'white polyamide':
            case 'white polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xe2e2e2, specular: 0x303030, ambient: 0xe2e2e2, bumpType: 1});
                setLightParams(mat, 0.25, 0.1, 0.5, '0x111111');
                break;
            case 'black polyamide':
            case 'black polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0x474747, specular: 0x404040, ambient: 0x474747, bumpType: 1});
                setLightParams(mat, 0.3, 0.15, 0.1, '0x111111');
                break;
            case 'blue polyamide':
            case 'blue polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0x384fa0, specular: 0x303030, ambient: 0x384fa0, bumpType: 1});
                setLightParams(mat, 0.3, 0.7, 0.45, '0x222222');
                break;
            case 'yellow polyamide':
            case 'yellow polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xfff009, specular: 0x202020, ambient: 0xfff009, bumpType: 1});
                setLightParams(mat, 0.25, 0.15, 0.4, '0x111111');
                break;
            case 'beige polyamide':
            case 'beige polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xc4b783, specular: 0x222222, ambient: 0xc4b783, bumpType: 1});
                setLightParams(mat, 0.35, 0.15, 0.35, '0x111111');
                break;
            case 'green polyamide':
            case 'green polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0x7fc242, specular: 0x202020, ambient: 0x7fc242, bumpType: 1});
                setLightParams(mat, 0.25, 0.1, 0.25, '0x333333');
                break;
            case 'brown polyamide':
            case 'brown polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0x6f5136, specular: 0x303030, ambient: 0x6f5136, bumpType: 1});
                setLightParams(mat, 0.4, 0.15, 0.35, '0x111111');
                break;
            case 'pink polyamide':
            case 'pink polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xed558c, specular: 0x202020, ambient: 0xed558c, bumpType: 1});
                setLightParams(mat, 0.25, 0.3, 0.2, '0x222222');
                break;
            case 'orange polyamide':
            case 'orange polished plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xea4b17, specular: 0x444444, ambient: 0xea4b17, bumpType: 1});
                setLightParams(mat, 0.6, 0.2, 0.25, '0x151515');
                break;

            case 'natrual white plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xFCF8F1, specular: 0x303030, ambient: 0xe2e2e2, bumpType: 1, 
                  combine: THREE.MultiplyOperation, transparent: true, opacity: 0.9});
                setLightParams(mat, 0.25, 0.1, 0.5, '0x111111');
                break;
            case 'dremel blue plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0x125EA7, specular: 0x303030, ambient: 0x384fa0, bumpType: 1});
                setLightParams(mat, 0.3, 0.7, 0.45, '0x222222');
                break;
            case 'cotton white plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xFFFFFF, specular: 0x303030, ambient: 0xe2e2e2, bumpType: 1});
                setLightParams(mat, 0.25, 0.1, 0.5, '0x111111');
                break;
            case 'deep black plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0x404040, specular: 0x404040, ambient: 0x474747, bumpType: 1});
                setLightParams(mat, 0.3, 0.15, 0.1, '0x111111');
                break;
            case 'electric orange plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xF59728, specular: 0x444444, ambient: 0xea4b17, bumpType: 1});
                setLightParams(mat, 0.6, 0.2, 0.25, '0x151515');
                break;
            case 'grass green plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0x098D4C, specular: 0x202020, ambient: 0x7fc242, bumpType: 1});
                setLightParams(mat, 0.25, 0.1, 0.25, '0x333333');
                break;
            case 'racecar red plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xEB2128, specular: 0x444444, ambient: 0xa3212e, bumpType: 1});
                setLightParams(mat, 0.65, 0.25, 0.05, '0x555555');
                break;
            case 'gold medal plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0xBB8747, specular: 0x222222, ambient: 0xc4b783, bumpType: 1});
                setLightParams(mat, 0.35, 0.15, 0.35, '0x111111');
                break;
            case 'silver spoon plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0x6A6964, specular: 0x222222, ambient: 0xc4b783, bumpType: 1});
                setLightParams(mat, 0.35, 0.15, 0.35, '0x111111');
                break;
            case 'purple orchid plastic':
                mat = new THREE.CustomizedPhongMaterial({color: 0x802C8C, specular: 0x222222, ambient: 0xc4b783, bumpType: 1});
                setLightParams(mat, 0.35, 0.15, 0.35, '0x111111');
                break;

            //ceramic
            case 'white ceramic' : 
                mat = new THREE.MeshLambertMaterial({ambient: 0xffffff, color: 0xE8E8E8, specular: 0xffffff, reflectivity: 0.15});
                setLightParams(mat, 0.1, 0.25, 0.5, '0x111111');
                mat.useEnvMap = true;
                break;
            case 'yellow ceramic' : 
                mat = new THREE.MeshLambertMaterial({ambient: 0xffffff, color: 0xF5EF70, specular: 0xffffff, reflectivity: 0.20});
                setLightParams(mat, 0.25, 0.25, 0.35, '0x111111');
                mat.useEnvMap = true;
                break;
            case 'green ceramic' : 
                mat = new THREE.MeshLambertMaterial({ambient: 0xffffff, color: 0xA7C774, specular: 0xffffff, reflectivity: 0.15});
                setLightParams(mat, 0.3, 0.2, 0.25, '0x333000');
                mat.useEnvMap = true;
                break;
            case 'aqua ceramic' : 
                mat = new THREE.MeshLambertMaterial({ambient: 0xffffff, color: 0x9BC8D6, specular: 0xffffff, reflectivity: 0.15});
                setLightParams(mat, 0.3, 0.35, 0.25, '0x111111');
                mat.useEnvMap = true;
                break;
            case 'black ceramic' :
                mat = new THREE.MeshLambertMaterial({ambient: 0xffffff, color: 0x474747, specular: 0xffffff, reflectivity: 0.75});
                setLightParams(mat, 0.1, 0.2, 0.1, '0x222222');
                mat.useEnvMap = true;
                break;
            case 'orange ceramic' :
                mat = new THREE.MeshLambertMaterial({ambient: 0xFFA06E, color: 0xFFA06E, specular: 0xffffff, reflectivity: 0.15});
                setLightParams(mat, 0.25, 0.25, 0.25, '0x333333');
                mat.useEnvMap = true;
                break;
                
            //sliver
            case 'polished silver' :
                mat = new THREE.CustomizedPhongMaterial( { color: 0xfefeff, ambient: 0xffffff, specular: 0xffffff, reflectivity: 0.85, shininess: 90, combine: THREE.MultiplyOperation, bumpType: 4} );
                setLightParams(mat, 0.1, 0.1, 0.45, '0x111111');
                mat.useEnvMap = true;
                mat.bumpDensity = 10;
                mat.useDefaultBumpDensity = true;
                break;

            //stainless steel
            case 'stainless steel antique bronze':
                mat = new THREE.CustomizedPhongMaterial({color: 0x885348, specular: 0xAAAAAA, ambient: 0xe2e2e2, 
                    combine: THREE.MultiplyOperation, reflectivity: 1.0, bumpType: 3});
                setLightParams(mat, 0.7, 0.1, 0.0, '0x000000', 0.0, 0.0);
                break;
            case 'stainless steel polished':
                mat = new THREE.CustomizedPhongMaterial({color: 0xfee8e1, specular: 0x555555, ambient: 0xe2e2e2, 
                    combine: THREE.MultiplyOperation, reflectivity: 0.40, bumpType: 3});
                setLightParams(mat, 0.6, 0.1, 0.1, '0x000000', 0.0, 0.0);
                break;
            case 'stainless steel wheat penny':
                mat = new THREE.CustomizedPhongMaterial({color: 0x806b6f, specular: 0xAAAAAA, ambient: 0xe2e2e2, 
                    combine: THREE.MultiplyOperation, reflectivity: 1.0, bumpType: 3});
                setLightParams(mat, 0.7, 0.1, 0.0, '0x000000', 0.0, 0.0);
                break;

            // alumide
            case 'alumide' :
                mat = new THREE.CustomizedPhongMaterial( { color: 0xa5a5a5, ambient: 0xa5a5a5, specular: 0x999999, shininess: 1000, combine: THREE.MultiplyOperation, bumpType: 1} );
                setLightParams(mat, 0.4, 0.35, 0.1, '0x111111', 0.75, 0.25);
                break;

            // titanium
            case 'titanium':
                mat = new THREE.MeshPhongMaterial( { color: 0xdfd8ce, ambient: 0xdfd8ce, specular: 0xffffff, reflectivity: 0.25, combine: THREE.MultiplyOperation} );
                setLightParams(mat, 0.35, 0.25, 0.35, '0x111111', 0.3, 0.3);
                mat.useEnvMap = true;
                break;

            // platinum
            case 'platinum':
                mat = new THREE.MeshPhongMaterial( { color: 0xd9d9d9, ambient: 0xd9d9d9, specular: 0xffffff, reflectivity: 0.45, shininess: 100, combine: THREE.MultiplyOperation} );
                setLightParams(mat, 0.3, 0.35, 0.3, '0x111111', 0.3, 0.3);
                mat.useEnvMap = true;
                break;

            // brass, bronze
            case 'brass':
                mat = new THREE.MeshPhongMaterial( { color: 0xecddae, ambient: 0xecddae, specular: 0xd5bb73, reflectivity: 0.45, combine: THREE.MultiplyOperation} );
                setLightParams(mat, 0.15, 0.25, 0.25, '0x795211', 0.2, 0.3);
                mat.useEnvMap = true;
                break;
            case 'bronze':
                mat = new THREE.MeshPhongMaterial( { color: 0xd99f75, ambient: 0xd99f75, specular: 0xb75e06, reflectivity: 0.15, combine: THREE.MultiplyOperation/*, bumpType: 3*/} );
                setLightParams(mat, 0.4, 0.2, 0.3, '0x222222', 0.25, 0.25);
                mat.useEnvMap = true;
                break;

            // gold
            case '14k gold':
                mat = new THREE.MeshPhongMaterial( { color: 0xf0d4a9/*ecd740*/, ambient: 0xf0d4a9, specular: 0xe7b44f, reflectivity: 0.45, shininess: 90, combine: THREE.MultiplyOperation} );
                setLightParams(mat, 0.3, 0.35, 0.3, '0x111111', 0.3, 0.3);
                mat.useEnvMap = true;
                break;
            case '14k rose gold':
                mat = new THREE.MeshPhongMaterial( { color: 0xf5d5c2/*ecd740*/, ambient: 0xf5d5c2, specular: 0x8b4608, reflectivity: 0.45, shininess: 90, combine: THREE.MultiplyOperation} );
                setLightParams(mat, 0.3, 0.35, 0.3, '0x111111', 0.3, 0.3);
                mat.useEnvMap = true;
                break;
            case '14k white gold':
                mat = new THREE.MeshPhongMaterial( { color: 0xd9dbcd/*ecd740*/, ambient: 0xd9dbcd, specular: 0xffffff, reflectivity: 0.45, shininess: 90, combine: THREE.MultiplyOperation} );
                setLightParams(mat, 0.3, 0.35, 0.3, '0x111111', 0.3, 0.3);
                mat.useEnvMap = true;
                break;
            case '18k gold':
                mat = new THREE.MeshPhongMaterial( { color: 0xfad667/*ecd740*/, ambient: 0xfad667, specular: 0xcaa847, reflectivity: 0.5, shininess: 90, combine: THREE.MultiplyOperation} );
                setLightParams(mat, 0.3, 0.35, 0.3, '0x111111', 0.3, 0.3);
                mat.useEnvMap = true;
                break;
            case '18k rose gold':
                mat = new THREE.MeshPhongMaterial( { color: 0xfac393/*ecd740*/, ambient: 0xfac393, specular: 0xffffff, reflectivity: 0.45, shininess: 90, combine: THREE.MultiplyOperation} );
                setLightParams(mat, 0.3, 0.35, 0.3, '0x111111', 0.3, 0.3);
                mat.useEnvMap = true;
                break;

            // wax
            case 'orange wax':
                mat = new THREE.MeshPhongMaterial( { color: 0xfd8736/*ecd740*/, ambient: 0xfd8736, specular: 0x404040, shininess: 200, combine: THREE.MultiplyOperation} );
                setLightParams(mat, 0.3, 0.35, 0.3, '0x111111', 0.3, 0.3);
                break;

            // rubber
            case 'black rubber':
                mat = new THREE.MeshPhongMaterial({color: 0x474747, ambient: 0x474747, specular: 0x404040});
                setLightParams(mat, 0.3, 0.15, 0.0, '0x111111');
                break;

            // resin
            case 'white resin':
                mat = new THREE.MeshPhongMaterial({color: 0xc6c7cb, ambient: 0xc6c7cb, specular: 0xffffff, reflectivity: 0.15, shininess: 90, combine: THREE.MultiplyOperation});
                setLightParams(mat, 0.45, 0.35, 0.05, '0x828282');
                mat.useEnvMap = true;
                break;
            case 'black resin':
                mat = new THREE.MeshPhongMaterial({color: 0x282829, ambient: 0x282829, specular: 0x909090, reflectivity: 0.15, shininess: 90, combine: THREE.MultiplyOperation});
                setLightParams(mat, 0.2, 1.0, 0.3, '0x111111');
                mat.useEnvMap = true;
                break;
            case 'translucent resin':
                mat = new THREE.MeshPhongMaterial({color: 0xdddcda, ambient: 0xdddcda, specular: 0x909090, reflectivity: 0.15, shininess: 90, combine: THREE.MultiplyOperation, transparent: true, opacity: 0.9});
                setLightParams(mat, 0.45, 0.35, 0.25, '0x333333');
                mat.useEnvMap = true;
                break;

            //highlight
            case 'highlight':
                mat = new THREE.MeshBasicMaterial( { color: 0x5a2200, transparent:true, opacity:1.0} );
                break;

            //prism materials
            case 'white ceramic prism':
                mat = Prism._prismOpaque({"x":230/255.0,"y":230/255.0,"z":230/255.0,}, 0.45, 0.40);
                break;
            case 'yellow ceramic prism':
                mat = Prism._prismOpaque({"x":245/255.0,"y":238/255.0,"z":133/255.0,}, 0.45, 0.40);
                break;
            case 'green ceramic prism':
                mat = Prism._prismOpaque({"x":18/255.0,"y":199/255.0,"z":17/255.0}, 0.45, 0.45);
                break;
            case 'polished silver prism':
                mat = Prism._prismMetal({"x":0.9672,"y":0.95555,"z":0.9137}, 0.07746);
                break;
             case '14k gold prism':
                mat = Prism._prismMetal({"x":0.905258349924144,"y":0.7840366658696786,"z":0.38656667340964346}, 0.0746);
                break;

            //'default'
            case 'default':
                mat = new THREE.MeshLambertMaterial( { color: 0xffffff, ambient: 0xff2200, shading: THREE.FlatShading, side: THREE.DoubleSide } );
                setLightParams(mat, 0.25, 0.1, 0.5, '0x111111');
                break;

            // don't support
            default:
                mat = null;
        }

        if(mat){
            if (isMobileAgent() && mat.hasOwnProperty("bumpType")) {
                mat.bumpType = 5;
                mat.bumpDensity = 10;
                mat.bumpAmplitude = 0.02;
                mat.useDefaultBumpDensity = true;
            }

            this._materials[materialName] = mat;
        }
        
        return mat;
    }

};

/**
Materials management class, not exposed to external yet 
@class Materials
@static
@since 1.0.0
@private
**/
var Materials = {

    /**
    Generates the material object by a specified name. 
    @method material
    @since 1.0.0
    @private
    **/
    material: function(materialName) {
        return this._impl._generateMaterial(materialName);
    }

};

// Create the IMPL such that clients can't see it
Object.defineProperty(Materials, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: _Materials
});
//light.js
/**
Pipeline class, not exposed to external yet 
@class Pipeline
@static
@since 2.1.0
@private
**/
var Light = function(params){ 
    this.scene = params.scene;
    this.camera = params.camera;

    this.bounds = params.bounds;
    this.material = params.globalMaterial;

    this.initialized = false;

    this.dirLight1 = null;
    this.dirLight2 = null;
    this.pointLight1 = null;
    this.pointLight2 = null;
    this.skyLight = null;
    this.ambientLight = null;
};

Light.prototype = {
    initialize : function(){
        if(this.initialized || !this.bounds || !this.scene){
            return;
        }

        this.ambientLight = new THREE.AmbientLight( 0x111111 );
        this.scene.add( this.ambientLight );

        this.skyLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.4);
        this.scene.add(this.skyLight);

        var boundingSphere = this.bounds;
        var radius = boundingSphere.radius;
        if(!this.dirLight1){
            this.dirLight1 = new THREE.DirectionalLight(0xFFFFFF, 0.85);
            this.dirLight1.intensity = 0.6;
            this.dirLight1.castShadow = true;
            //for debug
            this.dirLight1.shadowCameraVisible = false;
               
            this.dirLight1.shadowCameraNear = 1;
            this.dirLight1.shadowCameraFov = 45;
                   
            this.dirLight1.shadowBias =  -0.001;
            this.dirLight1.shadowDarkness = 0.2;
            this.dirLight1.shadowMapWidth = 1024;
            this.dirLight1.shadowMapHeight = 1024;
                   
            this.scene.add(this.dirLight1);
            
            this.dirLight1.shadowCameraFar = 20 * radius;
            this.dirLight1.shadowCameraLeft = - radius;
            this.dirLight1.shadowCameraRight = radius;
            this.dirLight1.shadowCameraTop = radius;
            this.dirLight1.shadowCameraBottom = -radius;
            
            //readd dirlight, so shadow parameters can be updated.
            this.scene.add(this.dirLight1);
            var targetObj = new THREE.Object3D();
            this.dirLight1.target = targetObj;
            this.dirLight1.target.matrixWorld.setPosition(boundingSphere.center);
        }

        if(!this.dirLight2){
            this.dirLight2 = new THREE.DirectionalLight(0xFFFFFF, 0.85);
            this.dirLight2.intensity = 0.1;
            this.dirLight2.castShadow = false;

            this.scene.add(this.dirLight2);
            var targetObj = new THREE.Object3D();
            this.dirLight2.target = targetObj;
            this.dirLight2.target.matrixWorld.setPosition(boundingSphere.center);            
        }

        if(!this.pointLight1){
          this.pointLight1 = new THREE.PointLight(0xffffff, 0.3, 5 * radius);
          this.scene.add(this.pointLight1);
        }
 
        if(!this.pointLight2){
          this.pointLight2 = new THREE.PointLight(0xffffff, 0.3, 5 * radius);
          this.scene.add(this.pointLight2);
        }

        this.initialized = true;
        this.globalMaterial(this.material);
        this.sceneBounds(this.bounds);
    },

    globalMaterial : function(material){
        this.material = material;

        if(!this.initialized){
            return;
        }

        if(this.initialized && material){
            if(material['dirLight1'] !== undefined){
                this.dirLight1.intensity = material['dirLight1'];
            }

            if(material['dirLight2'] !== undefined){
                this.dirLight2.intensity = material['dirLight2'];
            }

            if(material['skyLight'] !== undefined){
                this.skyLight.intensity = material['skyLight'];
            }

            if(material['ambientLight'] !== undefined){
                this.ambientLight.color.set(parseInt(material['ambientLight']));
            }

            if(material['pointLight1'] !== undefined){
                this.pointLight1.intensity = material['pointLight1'];
            }

            if(material['pointLight2'] !== undefined){
                this.pointLight2.intensity = material['pointLight2'];
            }
        }
    },

    sceneBounds : function(bounds){
        this.bounds = bounds;

        if(!this.initialized){
            return;
        }

        var boundingSphere = this.bounds;
        var radius = boundingSphere.radius;

        var cameraUp = this.camera.up.clone().applyQuaternion(this.camera.quaternion);
        var cameraLookAt = this.camera.position.clone().sub(boundingSphere.center);
        var cameraRight = cameraLookAt.clone().cross(cameraUp);
        var modelPos = boundingSphere.center.clone();
        //update light position
        var dirPos1 = modelPos.clone().add(cameraUp.clone().normalize().multiplyScalar(radius * 0.2));
        dirPos1.add(cameraRight.clone().normalize().multiplyScalar(radius));
        dirPos1.add(cameraLookAt.clone().normalize().multiplyScalar(radius));
        this.dirLight1.position = dirPos1;
        
        var dirPos2 = modelPos.clone().add(cameraUp.clone().normalize().multiplyScalar(radius));
        dirPos2.add(cameraRight.clone().normalize().multiplyScalar(-radius));
        dirPos2.add(cameraLookAt.clone().normalize().multiplyScalar(radius));
        this.dirLight2.position = dirPos2;

        dirPos1 = modelPos.clone();
        dirPos1.add(cameraRight.clone().normalize().multiplyScalar(radius * 2));
        dirPos1.add(cameraLookAt.clone().normalize().multiplyScalar(radius * 2));
        this.pointLight1.position = dirPos1;

        dirPos2 = modelPos.clone();
        dirPos2.add(cameraRight.clone().normalize().multiplyScalar(-2 * radius));
        dirPos2.add(cameraLookAt.clone().normalize().multiplyScalar(2 * radius));
        this.pointLight2.position = dirPos2;

        this.globalMaterial(this.material);
    }
};



//viewer.js
/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _Viewer
@param {ViewerParams} params the Parameters passed in Viewer. 
@private
**/
var _Viewer = function(params) {

    /**
    An HTML DIV where the Viewer should be inserted into.
    @private
    @property
    **/
    this.element = params.parent;

    /**
    Define the material name used in the viewer
    @private
    @property {String} globalMaterial
    **/
    this.globalMaterial = params['globalMaterial'] || 'default';

    /**
    Show debug ui or not
    @private
    @property {boolean}
    **/
    this.showDebugUI = false;

    /**Define the 2D backgroundURL used in the viewer
    @private
    @property {String} backgroundURL
    **/
    this.backgroundURL = '';

    /**
    Define the 3D enviroment used in the viewer
    @private
    @property {String} environment
    **/
    this.environment = '';
    this.environmentTexture = null;

    /**
    Define the shading mode.
    @private
    @property {String} shading
    **/
    this.shading = "flat";

    /**Define the center of the models in the viewer
    @private
    @property {THREE.Vector3} position
    **/
    this.position = new THREE.Vector3(0, 0, 0);

    /**
    @private
    @propterty {Boolean} turntable
    **/
    this.turntable = true;

    /**
    @private
    @property {Boolean} dataDirty
    */
    this.dataDirty = true;

    /**
    @private
    @property {Boolean} cameraDirty
    */
    this.cameraDirty = true;

    /**
    @private
    @property {Boolean} suspended
    */
    this.suspended = false;

    /**
    @private
    @property {Boolean} ssao
    */
    this.ssao = true;

    /**
    @private
    @property {float} 
    */
    this.bumpScale = 1.0;

    // The THREE objects
    this.camera = null;
    this.scene = null;
    this.renderer = null;
    this.rootObject = null;
    this.boundingBox = null;
    this.controls = null;
    this.viewDir = new THREE.Vector3(1, 3, 2);

    this._errorText='';
    this._statusText='';

    // Store the highlighted meshes
    this._highlightSet = new CoreLibrary.RefSet();

    // pipeline to render scene
    this._renderingPipeline = null;

    try{
        this._initialize();
    }catch(e){     
        Plugin.panic("Failed to render in Viewer");
    }
    
};

_Viewer.prototype = {
        
    /** 
    @private
    @method _initialize
    @since 1.0.0
    **/
    _initialize : function () {
        ThreePatches.initialize();

        this.devicePixelRatio = (Host && Host.devicePixelRatio) ? Host.devicePixelRatio : 
            ((window && window.devicePixelRatio) ? window.devicePixelRatio : 1);

        if(this.showDebugUI) {
            var parent = this.element;
            //hard code UI size
            var parentWidth = 544;
            var parentHeight = 478;
            var debugUIWidth = 200; 
            var debugUIHeight = parentHeight;
            this.element = this.element.ownerDocument.createElement("div");
            this.debugUI = new _DebugUI(parent, debugUIWidth, debugUIHeight, this);

            parent.appendChild(this.element);
            this.element.setAttribute("style","background-color:#FFA500;float:left; width:" + (parentWidth - debugUIWidth) + "px; height:" + parentHeight + "px;");
        }

        //camera setting
        this.camera = new THREE.PerspectiveCamera(60, this._getViewportWidth() / this._getViewportHeight(), 1, 500);
        this.camera.position.y = 0;
        this.camera.position.z = 500;

        // control
        this.controls = new THREE.ViewControls( this.camera, this.element );
        this.controls.autoRotate = false;
        this.controls.rotateSpeed = 1.0;
        this.controls.zoomSpeed = 1.0;
        this.controls.panSpeed = 0.8;
        //disable zoom and pan
        this.controls.noZoom = false;
        this.controls.noPan = false;
    
        this.controls.center = new THREE.Vector3(0, 0, 0);
        var self = this;
        this.controls.autoRotateChangedCallback = function(autoRotate){
            if(!autoRotate){
                self._statusText="";
                self._hideStatusText();
            }
        }

        //renderer
        if(Detector.webgl){
            // PremultipliedAlpha set as false will make canvas dataURL inverted on Safari, comment it out. To apply transparent clear color, only need set alpha as true and set
            // clear as black(alpha is zero).
            this.renderer = new THREE.WebGLRenderer({preserveDrawingBuffer:true, premultiplied:true, antialias:true, maxLights:6, alpha: true/*, premultipliedAlpha: false*/});
            if (this.renderer) {
                this.renderer.setSize( this._getElementWidth(), this._getElementHeight() );
                this.renderer.shadowMapEnabled = false;
            } else {
                CoreLibrary.Plugin.panic("WebGL is not supported.");
            }
        } else {
            CoreLibrary.Plugin.panic("WebGL is not supported.");
        }

        this.renderer.setClearColor(0xFFC0CB, 1);
        this.renderer.setSize( this._getElementWidth(), this._getElementHeight() );

        this.scene = new THREE.Scene();
        this.rootObject = new THREE.Object3D();
        this.rootObject.position = this.position;
        this.scene.add(this.rootObject );

        this.element.appendChild( this.renderer.domElement );

        //set up lights
        var lightParams = {'scene' : this.scene,
                            'camera' : this.camera}
        this.light = new Light(lightParams);

        var getRenderingPipeline = function(){
            if(!self._renderingPipeline){
                var params = {'rootObject': self.rootObject,
                            'bgCamera': self.bgCamera, 
                            'bgScene': self.bgScene,
                            'camera': self.camera,
                            'scene': self.scene,
                            'renderer': self.renderer,
                            'width': self._getViewportWidth(),
                            'height': self._getViewportHeight(),
                            'highlightSet': self._highlightSet};
                var pipeline = new Pipeline(params);
                pipeline.SSAO(self.ssao);

                self._renderingPipeline = pipeline;
            }
            return self._renderingPipeline;
        };

        var animate = function () {
            requestAnimationFrame( animate );
 
            self.cameraDirty = self.controls.update() || self.cameraDirty;
            if(self.cameraDirty){
                var elements = self.camera.matrixWorldInverse.elements;
                var material = Materials.material(self.globalMaterial);
                if(material.uniforms && material.uniforms['viewDirection']){
                    material.uniforms['viewDirection'].value = new THREE.Vector3(elements[2] * (-1), elements[6] * (-1), elements[10] * (-1));
                }
            }

            if(!self.suspended 
                && (self.dataDirty || self.cameraDirty)){
                
                //update lighting position based on camera and bounds
                if(self.light && self.boundingBox){
                    var sphere = self.boundingBox.getBoundingSphere();
                    self.light.sceneBounds(sphere);
                }

                //create debug ui after lighting is set.
                if(self.debugUI && self.light.dirLight1 && self.light.dirLight2){
                    self.debugUI.createDebugUIControls();
                }
                
                //render
                var pipeline = getRenderingPipeline();
                if(pipeline){
                    pipeline.render();
                }

                if(self._monitor){
                    self._monitor.end();
                }
            }
            else{
                if(self._monitor){
                    self._monitor.begin();
                }
            }
                
            self.dataDirty = false;
            self.cameraDirty = false;
        };
        animate();
        
        //Material
        this._setGlobalMaterial(this.globalMaterial);

        /*
        The handler for highlighting the item added
        @method highlightAddedHandler
        */
        var highlightAddedHandler = function (event){
            if (event.data instanceof Mesh3D) {
                var mesh = event.data;
                var threemesh = mesh.attributes['viewer']['threemesh'];
                if(threemesh){
                    threemesh._highlighted = true;
                    threemesh.receiveShadow = false;
                    self.dataDirty = true;
                }
            } 
        };

        /*
        The handler for removing the highlight of the item removed
        @method highlightRemovedHandler
        */
        var highlightRemovedHandler = function (event){
            if (event.data instanceof Mesh3D) {
                var mesh = event.data;
                var threemesh = mesh.attributes['viewer']['threemesh'];
                if(threemesh){
                    delete threemesh._highlighted;
                    threemesh.receiveShadow = true;
                    self.dataDirty = true;
                }
            } 
        };

        //Set the highlight handlers
        this._highlightSet.itemAdded.bind(highlightAddedHandler);

        this._highlightSet.itemRemoved.bind(highlightRemovedHandler);
    },

    _getElementWidth : function () {
        return this.element.clientWidth;
    },

    _getElementHeight : function () {
        return this.element.clientHeight;
    },

    _getViewportWidth : function () {
        return this.devicePixelRatio * this.element.clientWidth;
    },

    _getViewportHeight : function () {
        return this.devicePixelRatio * this.element.clientHeight;
    },

    /** 
    @private
    @method _enableSSAO
    @since 2.1.0
    **/
    _enableSSAO : function(enabled) {
        this.ssao = enabled;
        if(this._renderingPipeline){
            this._renderingPipeline.SSAO(enabled);
        }
        this.dataDirty = true;
    },

    /**
    @since 1.0.0
    @private
    @method _addMesh
    @param {Mesh3D} mesh
    **/
    _addMesh : function(mesh){
        if (!(mesh instanceof Mesh3D)) {
            Plugin.panic("The input mesh data is not a Mesh3D object.");
        }

        var self = this;
        var getTHREEMesh = function(mesh){
            // Get from cache
            if(mesh['attributes']["viewer"] && mesh['attributes']["viewer"]["threemesh"]){
                // Update material
                mesh['attributes']["viewer"]["threemesh"].material = Materials.material(self.globalMaterial);
                return mesh['attributes']["viewer"]["threemesh"];
            }

            var Tris = mesh._impl._triangles;
            var Verts = mesh._impl._vertices;

            var bufferGeometry = THREE.BufferGeometryUtils.createBufferGeometry(Verts, Tris);
            THREE.BufferGeometryUtils.updateNormals(bufferGeometry, self.shading);
            var material = Materials.material(self.globalMaterial);
            var threemesh = new THREE.Mesh(bufferGeometry, material);
            // Rotate model to make tinkercad's models look right.
            threemesh.rotation.x = Math.PI*-0.5;

            //cache three mesh into mesh3d
            if(undefined === mesh['attributes']["viewer"]){
                mesh['attributes']["viewer"] = {};
                mesh.change.bind(threeMeshChangeHandler);
            }
            mesh['attributes']["viewer"]["threemesh"]=threemesh;

            return threemesh;  
        }

        var threemesh =  getTHREEMesh(mesh);
        self.rootObject.add(threemesh);
        threemesh.castShadow = true;
        threemesh.receiveShadow = true;
        this.boundingBox = undefined;
        this._computeBoundingBox();
        this.dataDirty = true;
    },

    /**
    @private
    @method _removeAllMeshes
    @since 1.0.0
    **/
    _removeAllMeshes : function(){
        var removedList = [];
        this.rootObject.getDescendants(removedList);
        for(var i = 0, len = removedList.length; i<len; ++i){
            var mesh = removedList[i]
            if(mesh instanceof THREE.Mesh){
                this.rootObject.remove(mesh);
            }
        }

        this.dataDirty = true;
        this.boundingBox = undefined;
    },

    /**
    @private
    @method _setGlobalMaterial
    @since 1.0.0
    @param {String} materialName
    **/
    _setGlobalMaterial : function(materialName){
        if (this.globalMaterial !== materialName) {
            var mat = Materials.material(materialName);
            if(mat){
                this.globalMaterial = materialName;
                this.rootObject.traverse (function (mesh) {
                    if (mesh instanceof THREE.Mesh) {
                        mesh.material = mat;              
                    }
                });

                this._updateMaterial();
                this.light.globalMaterial(mat);
                this.dataDirty = true;
            }
        }
        
        return this;
    },


    /**
    Calculate the bump density
    @private
    @method _computeBumpDensity
    @since 1.0.0
    **/
    _computeBumpDensityAndAmplitude: function(mat){
        // TODO: figure the relationship with model size and view port. 
        if (mat.useDefaultBumpDensity) {
            return;
        }

        var bumpDensity = 2.0;
        var bumpAmplitude = 0.02;
        if (this.globalMaterial.indexOf('stainless steel') !== -1) {
            if (this.boundingBox && !this.boundingBox.empty()) {
                var x = this.boundingBox.max.x - this.boundingBox.min.x;
                var y = this.boundingBox.max.y - this.boundingBox.min.y;
                var z = this.boundingBox.max.z - this.boundingBox.min.z;
                var area = x*y + y*z + z*x;
                bumpDensity = 10000.0/area;
                bumpAmplitude = 0.2/bumpDensity;
                if(bumpAmplitude<0.3){
                    bumpAmplitude = bumpAmplitude/2;
                }
            }
        } else {
            if (this.boundingBox && !this.boundingBox.empty()) {
                var boundingSphere = this.boundingBox.getBoundingSphere();
                bumpDensity = 1.0 / boundingSphere.radius * 50.0;
            }
        }

        mat.bumpDensity = bumpDensity;
        mat.bumpAmplitude = bumpAmplitude;
    },

    /**
    Update current material after settings(like shading, environment, etc) changed.
    @private
    @method _updateMaterial
    @since 1.0.0
    **/
    _updateMaterial : function(){
        var mat = Materials.material(this.globalMaterial);
        if(mat){
            if ('smooth' === this.shading && mat.shading !== THREE.SmoothShading) {
                mat.shading = THREE.SmoothShading;
            }
            else if ('flat' === this.shading && mat.shading !== THREE.FlatShading) {
                mat.shading = THREE.FlatShading;
            }    

            // Need set the environment map after environment loaded, otherwise environment can't be shown successfully on Firefox.
            // See bug TINK-736
            if(mat.useEnvMap && mat.envMap != this.environmentTexture){
                if (this.environmentTexture && this.environmentTexture.hasOwnProperty('loaded')) {
                    mat.envMap = this.environmentTexture;
                    mat.needsUpdate = true;    
                }
                else if(!this.environmentTexture){
                    mat.needsUpdate = true;  
                    mat.envMap = null;
                }
            }

            //adjust highlight color according to current color
            var highlightMaterial = Materials.material('highlight');
            if(highlightMaterial && mat.color){
                //base color is orange
                var color = new THREE.Color(THREE.ColorKeywords.orange);
                var hsl = color.getHSL();
                var h = hsl.h;
                var s = hsl.s;
                //get current material color
                var materialColor = new THREE.Color(mat.color);
                var mhsl = materialColor.getHSL();

                //set higher lightness for darker color
                var l = 0.3;
                if(mhsl.l>0.35){
                    l = 0.15;
                }

                //reduce saturation, so highlight will not cover material
                s = s * 0.6;

                color.setHSL(h, s, l);
                highlightMaterial.color = color;
            }

            // reset material bump scale
            this._computeBumpDensityAndAmplitude(mat);
            this.dataDirty = true;

            //update relfection map
            if(!mat.uniforms){
                return;
            }
            
            var uniform = mat.uniforms["radianceLogLuvCube_samp"];
            if(uniform){
                uniform.value = this.radianceMap;
            }

            uniform = mat.uniforms["glossLogLuvCube_samp"];
            if(uniform){
               uniform.value = this.irradianceMap;
            }

            uniform = mat.uniforms["irradianceLogLuvCube_0_fiu_samp"];
            if(uniform){
                uniform.value = this.irradianceMap;
            }

            // update view direction
            var elements = this.camera.matrixWorldInverse.elements;
            uniform = mat.uniforms['viewDirection'];
            if(uniform){
                uniform.value = new THREE.Vector3(elements[2] * (-1), elements[6] * (-1), elements[10] * (-1));
            }

            uniform = mat.uniforms['WorldIT'];
            if(uniform){
                var axis = new THREE.Vector3( 1, 0, 0 );
                var angle = -Math.PI / 2;
                var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
                uniform.value = matrix; 
            }

            uniform = mat.uniforms['World'];
            if(uniform){
                var axis = new THREE.Vector3( 1, 0, 0 );
                var angle = -Math.PI / 2;
                var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
                uniform.value = matrix; 
            }
        }
    },
    
    /** 
    @private
    @method _windowResizeHandler
    @since 1.0.0
    **/
    _windowResizeHandler : function () {
        var self = this;
        var handler = function(){
            self.camera.aspect = self._getViewportWidth() / self._getViewportHeight();
            self.camera.updateProjectionMatrix();
            if (self.renderer) {
                self.renderer.setSize( self._getElementWidth(), self._getElementHeight());
            }

            if(self._renderingPipeline){
                delete self._renderingPipeline;
            }
            self.dataDirty = true;
        };

        return handler;
    },

    /** 
    @private
    @method _setBackground
    @param {String} backgroundURL
    @since 1.0.0
    **/
    _setBackground : function(backgroundURL) {
        if(this.backgroundURL === backgroundURL){
            return;
        }

        //change background clear color as white before background image is downloaded.
        if(this.renderer){
            this.renderer.setClearColor(0x000000, 0);
        }
        
        if(!this.backgroundURL){
            var self = this;
            THREE.ImageUtils.loadTexture(backgroundURL, undefined, function(bgmap) {
                self.bgCamera = new THREE.Camera();
                self.bgScene = new THREE.Scene();
                self.bgScene.add(self.bgCamera);
                self.bg = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({map: bgmap }));
                self.bgScene.add(self.bg);

                if(self._renderingPipeline){
                    self._renderingPipeline.background(self.bgScene, self.bgCamera);
                    self.dataDirty = true;
                }
            });
        }
        else{
            this._renderingPipeline.background(null, null);
            this.dataDirty = true;
        }
        this.backgroundURL = backgroundURL;
    },

    /**
    @private
    @method _setEnvironment
    @since 2.2.0
    @param {String|Array} a single environment url of png/jpeg file, 
    or two environment urls of dds file, first one is irradiance reflection map and second is randiance reflection map.
    **/
    _setEnvironment : function(environmentURL){
        if (typeof environmentURL === 'string' && this.environment !== environmentURL) {
            this.environment = environmentURL;

            if (environmentURL !== '') {
                this.environmentTexture = new THREE.Texture();
                var envImages = [];
                this.environmentTexture.flipY = false;
                this.environmentTexture.image = envImages;

                var envImg = new Image();
                var self = this;
                envImg.onload = function(event) {
                    var img = event.target;
                    var canvas = document.createElement('canvas');
                    // 6 enviroment image are combined to one by our tool, and 6 images will be combined as below:
                    //      posxImage          negxImage          posyImage
                    //      negyImage          poszImage          negzImage
                    // So we need pick up them respectively here.
                    canvas.width = img.width / 3;
                    canvas.height = img.height / 2;

                    var canvasCtx = canvas.getContext('2d');
                    var dividedImg = null;
                    var finshedImageCounts = 0;
                    for (var i = 0; i < 2; ++i) {
                        for (var j = 0; j < 3; ++j) {
                            canvasCtx.drawImage(img, j * canvas.width, i * canvas.height, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
                            dividedImg = new Image();
                            dividedImg.onload = function(event) {
                                if (++finshedImageCounts == 6) {
                                    self.environmentTexture.needsUpdate = true;
                                    self.environmentTexture.loaded = true;
                                    // Update material's environment map.
                                    var mat = Materials.material(self.globalMaterial);
                                    if (mat && mat.useEnvMap) {
                                        mat.envMap = self.environmentTexture;
                                        mat.needsUpdate = true;
                                    }
                                }
                            }
                            dividedImg.src = canvas.toDataURL("image/jpeg"); // The combined image created by the tool will always be jpg format.

                            envImages.push(dividedImg);
                        }
                    }
                };
                
                envImg.src = this.environment;
            }
            else {
                this.environmentTexture = null;
                var mat = Materials.material(this.globalMaterial);
                if (mat.envMap) {
                    mat.envMap = null;
                    mat.needsUpdate = true;
                }
            }
        }

        if(environmentURL instanceof Array && environmentURL.length === 2){
            var ext0 = environmentURL[0].split('.').pop();
            var ext1 = environmentURL[1].split('.').pop();
            if(ext0 === ext1 && ext0 ==='dds'){
                this.environment = environmentURL;
                this.irradianceURL = environmentURL[0];
                this.radianceURL = environmentURL[1];
                this._loadReflectionMaps();   
            }
        }

        this.dataDirty = true;
        return this;
    },

    /** 
    Set proper shading mode, can be "smooth", "flat".
    @private
    @method _setShading
    @param {String} shading
    @since 1.0.0
    **/
    _setShading : function(shading) {
        if(this.shading != shading){
            this.shading = shading;
            //need to update normals of geometries         
            this.rootObject.traverse (function (mesh) {
                if (mesh instanceof THREE.Mesh) {
                    THREE.BufferGeometryUtils.updateNormals(mesh.geometry, shading);
                }
            });
            this._updateMaterial();
            this.dataDirty = true;
        }
    },

    /** 
    @private
    @method _setCamera
    @param {CoreLibrary.CameraConfigurationJSON} camera
    @since 1.0.0
    **/
    _setCamera : function(camera) {
        if (camera) {
            var dir = camera.direction;
            if(dir && dir.length === 3){
                this.viewDir.set(dir[0], dir[1], dir[2]);
                this.dataDirty = true; 
            }
        }
    },

    _setOrbitMode : function(orbitMode){
        if(this.controls){
            if(orbitMode === 'xy'){
                this.controls.orbitMode = THREE.ViewControls.OrbitMode.XY;
            }
            else if(orbitMode === 'x'){
                this.controls.orbitMode = THREE.ViewControls.OrbitMode.X;
            }
            else if(orbitMode === 'y'){
                this.controls.orbitMode = THREE.ViewControls.OrbitMode.Y;
            }
            else{
                //assert failed
             }
        }
        else{
            //assert failed
        }
        this.dataDirty = true;
    },

    _setTurntable : function(turntable){
        if(this.controls){
            this.turntable = turntable;
            this.controls.autoRotate = turntable;
        }
        else{
            //assert failed
        }
        this.dataDirty = true;
    },

    _setBumpDensity : function(bumpDensity){
        this.bumpDensity = bumpDensity;

        this.dataDirty = true;
    },

    /**
    @private
    @method _computeBoundingBox
    @since 1.0.0
    **/
    _computeBoundingBox : function(){
        // calculate the world-axis-aligned bounding box
        if(!this.boundingBox){
            this.boundingBox = new THREE.Box3();
            //computes world 
            this.boundingBox.setFromObject(this.rootObject);
            this._updateMaterial();
            this.light.sceneBounds(this.boundingBox.getBoundingSphere());
        }
    },

    /**
    @private
    @method _home
    @since 1.0.0
    **/
    _home : function(){
        this._computeBoundingBox();
        
        // restore to camera home
        var boundingSphere = this.boundingBox.getBoundingSphere();
        this.camera.position = boundingSphere.center.clone();
        var radius = boundingSphere.radius;
       
        var fov = 45;
        var vpRadius = radius;
        var canvasWidth = this.renderer.domElement.width; // Set by renderer.setSize() method.
        var canvasHeight = this.renderer.domElement.height;
        if (canvasWidth > 0 && canvasHeight > 0) {
            var aspectRatio = canvasWidth / canvasHeight;
            if (aspectRatio > 0 && aspectRatio < 1) {
                vpRadius /= aspectRatio;
            }
        }
        var distance = vpRadius / Math.tan((fov/2) * Math.PI / 180); 

        var offset = this.viewDir.clone().normalize();
        this.camera.position.z += distance * offset.z;
        this.camera.position.y += distance * offset.y;
        this.camera.position.x += distance * offset.x;
        this.camera.lookAt(boundingSphere.center.clone());

        // Update near/far with bounding box, to make sure the frustum tight arround the model.
        var distance = this.camera.position.distanceTo(boundingSphere.center);
        this.camera.near = distance * 0.001;
        this.camera.far = (distance + boundingSphere.radius) * 10;
        this.camera.updateProjectionMatrix();

        this.controls.target = boundingSphere.center.clone();
        this.controls.pivot = boundingSphere.center.clone();

        this.light.sceneBounds(boundingSphere);
        //initialize light when camera is ready.
        this.light.initialize();

        this.dataDirty = true;
        this.cameraDirty = true;
    },

    /**
    @private
    @method _home
    @since 1.0.0
    **/
    _lookAt : function(point, normal, right){
        this.controls.lookAt(point, normal, right);
        this.dataDirty = true;
    },

    /**
    Return the png format thumbnail data(base64 encoded) by given size, the given thumbnail will always be in home state no matter
    what operations user has done.
    @private
    @method _imageURL
    @since 1.0.0
    **/
    _imageURL: function(width, height) {
        var originalCamera = this.camera; // Hold original camera object.
        var originalControls = this.controls; // Hold original controls object.
        var originalWidth = this._getElementWidth();
        var originalHeight = this._getElementHeight();

        // Update camera with given width and height.
        this.camera = originalCamera.clone();
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();

        // Update render and do home operation to make sure the thumbnail caught in home state.
        this.renderer.setSize(width, height);
        this.controls = new THREE.ViewControls( this.camera, this.element ); // Use temporary controls and will restore it after thumbnail generation.
        this._home();
        this.controls.autoRotate = false;

        // force render and generate thumbnail.
        this.renderer.clear(true, true, true);

        this.renderer.render( this.scene, this.camera );
        var thumbnailData = this.renderer.domElement.toDataURL('image/png');

        // restore canvas and controls.
        this.camera = originalCamera;
        this.controls = originalControls;
        this.renderer.setSize(originalWidth, originalHeight);

        // Set as dirty so that scene will be update automatically.
        this.dataDirty = true;

        return thumbnailData;
    },

    /**
    @private
    @method _suspend
    @since 1.0.0
    **/
    _suspend: function(){
        this.suspended = true;
    },

    /**
    @private
    @method _resume
    @since 1.0.0
    **/
    _resume: function(){
        this.suspended = false;
    },

    _showErrorText: function(str){
        var background = "background: -moz-linear-gradient(left, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0.35) 65%, rgba(255,255,255,0) 100%);background: -webkit-gradient(linear, left top, right top, color-stop(0%,rgba(255,255,255,0.4)), color-stop(65%,rgba(255,255,255,0.35)), color-stop(100%,rgba(255,255,255,0)));background: -webkit-linear-gradient(left, rgba(255,255,255,0.4) 0%,rgba(255,255,255,0.35) 65%,rgba(255,255,255,0) 100%); background: -o-linear-gradient(left, rgba(255,255,255,0.4) 0%,rgba(255,255,255,0.35) 65%,rgba(255,255,255,0) 100%);background: -ms-linear-gradient(left, rgba(255,255,255,0.4) 0%,rgba(255,255,255,0.35) 65%,rgba(255,255,255,0) 100%);background: linear-gradient(to right, rgba(255,255,255,0.4) 0%,rgba(255,255,255,0.35) 65%,rgba(255,255,255,0) 100%);";
        var elementStyle = "position: absolute;bottom: -1px;padding: 5px;width: 100%;color: red;text-align: center; font-size: 16px;" + background;
        this._showTextElement(str, 'viewer_error_text', elementStyle);
    },
    _hideErrorText: function(){
        this._hideTextElement('viewer_error_text');
    },

    _showStatusText: function(str){
        var background = "background: -moz-linear-gradient(left, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0.35) 65%, rgba(255,255,255,0) 100%);background: -webkit-gradient(linear, left top, right top, color-stop(0%,rgba(255,255,255,0.4)), color-stop(65%,rgba(255,255,255,0.35)), color-stop(100%,rgba(255,255,255,0)));background: -webkit-linear-gradient(left, rgba(255,255,255,0.4) 0%,rgba(255,255,255,0.35) 65%,rgba(255,255,255,0) 100%); background: -o-linear-gradient(left, rgba(255,255,255,0.4) 0%,rgba(255,255,255,0.35) 65%,rgba(255,255,255,0) 100%);background: -ms-linear-gradient(left, rgba(255,255,255,0.4) 0%,rgba(255,255,255,0.35) 65%,rgba(255,255,255,0) 100%);background: linear-gradient(to right, rgba(255,255,255,0.4) 0%,rgba(255,255,255,0.35) 65%,rgba(255,255,255,0) 100%);";
        var elementStyle = "position: absolute;bottom: -1px;padding: 5px;width: 100%;color: #494641;text-align: center; font-size: 16px;" + background;
        this._showTextElement(str, 'viewer_status_text', elementStyle);
    },
    _hideStatusText: function(){
        this._hideTextElement('viewer_status_text');
    },

    _showTextElement: function(str, elementId, elementStyle){
        var element = $('#' + elementId);
        if(element.length === 0){
            var statusCode = '<div id="'+elementId+'" style="'+elementStyle+'">'+str+'</div>';
            element=$(statusCode);

            // Add the status element to the parent element of view canvas.
            var parent = this.element;
            if (parent) {
                element.appendTo(parent);
            }
        } else {
            element.text(str);
            element.show();
        }
    },

    _hideTextElement: function(elementId){
        var element = $('#' + elementId);
        if(element.length !== 0){
            element.hide();
        }
    },

    _showLoadingElement: function(visible) {
        var element = $('#viewer_loading');
        if (visible) {
            if (element.length === 0) {
                var loadingDiv = '<div id="viewer_loading" style="position:absolute;left:50%;top:50%;margin-left:-44px;width:88px;height:24px;line-height:24px;color:rgba(255,255,255,0.9);text-align:center;font-size:16px;background-color: rgba(0,0,0,0.2);-moz-border-radius:3px;-webkit-border-radius:3px;border-radius:3px;"> Loading... </div>';
                element = $(loadingDiv);

                // Add the status element to the parent element of view canvas.
                var parent = this.element;
                if (parent) {
                    element.appendTo(parent);
                }
            } else {
                element.show();
            }
        } else {
            if (element.length !== 0) {
                element.hide();
            }
        }
    },

    _setDebug: function(value){
        if(value && !this._monitor){
            var monitor = new Stats();
            // Align top-left
            monitor.domElement.style.position = 'fixed';
            monitor.domElement.style.left = '0px';
            monitor.domElement.style.top = '0px';

            document.body.appendChild( monitor.domElement );
            this._monitor = monitor;
        }

        if(!value && this._monitor){
            document.body.removeChild( this._monitor.domElement );
            delete this._monitor;
        }
    },

    _getDebug: function(){
        return this._monitor!=undefined;
    },

    _getDebugInfo: function(){
        if(!this._monitor){
            return undefined;
        }

        var result = {};
        result.averageFps = this._monitor.fpsSum/this._monitor.fpsCount;
        result.minFps = this._monitor.fpsMin;
        result.maxFps = this._monitor.fpsMax;
        result.timeCost = (this._monitor.fpsEnd - this._monitor.fpsStart) / 1000.0;
        result.rendererInfo = this.renderer.info;
        //todo add more info

        return JSON.stringify(result);
    },

    _loadReflectionMaps : function(){
        var self = this;

        var mapLoaded = function(){
            self._updateMaterial();
            self.dataDirty  = true;
        };

        this.irradianceMap = THREE.ImageUtils.loadCompressedTextureCube(this.irradianceURL, new THREE.CubeReflectionMapping(), mapLoaded);
        this.radianceMap = THREE.ImageUtils.loadCompressedTextureCube(this.radianceURL, new THREE.CubeReflectionMapping(), mapLoaded);       
    },   
};

/**
The various parameters that can be passed to the constructor of the Viewer.
@class ViewerParams
@since 1.0.0
@see Viewer
@unlisted
**/
var ViewerParams = function() {

    /**
    An HTML DIV where the Viewer should be inserted into.
    @public
    @property {HTMLElement} parent
    @for ViewerParams
    **/
    this.parent = undefined;

    /**
    The enum string for the material. 
    @public
    @property {String} globalMaterial
    @for ViewerParams
    **/
    this.globalMaterial = "";
};

/**
@class Viewer
@constructor
@since 1.0.0
@see ViewerParams
@param {ViewerParams} params Viewer parameters.
**/
var Viewer =  function(params) {

    /**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @private 
    @property {_Viewer} _impl
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Viewer(params)
    });

    /**
    The material name to use. Some supported materials now are 
    1. 'red plastic'
    1. 'red polyamide'
    1. 'white polyamide'
    1. 'black polyamide'
    1. 'blue polyamide'
    1. 'yellow polyamide'
    1. 'beige polyamide'
    1. 'green polyamide'
    1. 'brown polyamide'
    1. 'pink polyamide'
    1. 'orange polyamide'
    1. 'red polished plastic'
    1. 'white polished plastic'
    1. 'black polished plastic'
    1. 'blue polished plastic'
    1. 'yellow polished plastic'
    1. 'beige polished plastic'
    1. 'green polished plastic'
    1. 'brown polished plastic'
    1. 'pink polished plastic'
    1. 'orange polished plastic'
    1. 'natrual white plastic'
    1. 'dremel blue plastic'
    1. 'cotton white plastic'
    1. 'deep black plastic'
    1. 'electric orange plastic'
    1. 'grass green plastic'
    1. 'racecar red plastic'
    1. 'gold medal plastic'
    1. 'silver spoon plastic'
    1. 'purple orchid plastic'
    1. 'white ceramic'
    1. 'yellow ceramic'
    1. 'green ceramic'
    1. 'aqua ceramic'
    1. 'black ceramic'
    1. 'orange ceramic' 
    1. 'polished silver'
    1. 'alumide'
    1. 'titanium'
    1. 'platinum'
    1. 'brass'
    1. 'bronze'
    1. '14k gold'
    1. '14k rose gold'
    1. '14k white gold'
    1. '18k gold'
    1. '18k rose gold'
    1. 'orange wax'
    1. 'black rubber'
    1. 'white resin'
    1. 'black resin'
    1. 'translucent resin'
    1. 'stainless steel antique bronze'
    1. 'stainless steel polished'
    1. 'stainless steel wheat penny'
    @property {string} globalMaterial
    @since 1.0.0
    @markdown
    **/
    Object.defineProperty(this, 'globalMaterial', {
        get : function(){ 
            return this._impl.globalMaterial;
        },
        set: function(value){
            this._impl._setGlobalMaterial(value);
        },
        enumerable : true
    });

    /**
    The background image URL
    @property {string} background
    @since 1.0.0
    **/
    Object.defineProperty(this, 'background', {
        get : function(){ 
            return this._impl.backgroundURL;
        },
        set: function(value){
            this._impl._setBackground(value);
        },
        enumerable : true
    });

    /**
    The environment image URL(s) is a single environment url of .png/jpeg file, 
    or a array of two .dds environment urls, first is irradiance reflection map and second is randiance reflection map.
    @property {string|Array} environment
    @since 2.2.0
    **/
    Object.defineProperty(this, 'environment', {
        get : function(){ 
            return this._impl.environment;
        },
        set: function(value){
            this._impl._setEnvironment(value);
        },
        enumerable : true
    });
    
    /**
    The camera setting 
    @property {CoreLibrary.CameraConfigurationJSON} camera
    @since 1.0.0
    @example
        this.camera = {'direction' : [0, 1, 1]}
    **/
    Object.defineProperty(this, 'camera', {
        set: function(value){
            this._impl._setCamera(value);
        },
        enumerable : true
    });

    /**
    The highlight set to add or remove meshes for highlight effects. {CoreLibrary.Mesh3D} objects can be added or removed from this set. 
    @property {CoreLibrary.RefSet} highlightSet
    @since 1.0.0
    **/
    Object.defineProperty(this, 'highlightSet', {
        get : function(){ 
            return this._impl._highlightSet;
        },
        enumerable: false,
        configurable: false
    });

    /**
    Set the error message. 
    @property {String} errorText
    @since 1.1.0
    **/
    Object.defineProperty(this, 'errorText', {
        enumerable: true,
        get: function(){
            return this._impl._errorText;
        },
        set: function(value){
            if (value !== undefined) {
                if (typeof value === 'string' && this._impl._errorText !== value) {
                    this._impl._errorText = value;
                    if (value === '') {
                        this._impl._hideErrorText();
                        if(this._impl._statusText){
                            // recover the previous status text.
                            this._impl._showStatusText();
                        } 
                    } else {
                        this._impl._showErrorText(value);
                        if (this._impl._statusText) {
                            this._impl._hideStatusText();
                        }
                    }
                } 

            }
        }
    });

    /**
    Set the status message. 
    @property {String} statusText
    @since 1.1.0
    **/
    Object.defineProperty(this, 'statusText', {
        enumerable: true,
        get: function(){
            return this._impl._statusText;
        },
        set: function(value){
            if (value !== undefined) {
                if (typeof value === 'string' && this._impl._statusText !== value) {
                    this._impl._statusText = value;
                    if (value === '') {
                        this._impl._hideStatusText();
                    } else {
                        if (!this._impl._errorText){
                            this._impl._showStatusText(value);
                        } 
                    }
                }
            }
        }
    });

    /**
    The boolean for turntable. 
    @property {Boolean} turntable
    @since 1.2.0
    **/
    Object.defineProperty(this, 'turntable', {
        get : function(){ 
            return this._impl.turntable;
        },
        set: function(value){
            this._impl._setTurntable(value);
        },
        enumerable : true
    });

    /**
    Show the loading message. 
    @property {Boolean} showLoading
    @since 1.2.0
    **/
    Object.defineProperty(this, 'showLoading', {
        set: function(value){
            this._impl._showLoadingElement(value);
        },
        enumerable : false,
        configurable: false
    });

    /**
    Turn on/off ssao effect in viewer. 
    @property {Boolean} ssao
    @since 2.1.0
    **/
    Object.defineProperty(this, 'ssao', {
        set: function(value){
            this._impl._enableSSAO(value);
        },
        enumerable : false,
        configurable: false
    });

    /**
    The enum string for shading mode. The supported values are ["smooth","flat"].
    @property {String} shading
    @since 2.1.0
    **/
    Object.defineProperty(this, 'shading', {
        set: function(value){
            this._impl._setShading(value);
        },
        enumerable : false,
        configurable: false
    });

    /**
    Turn on/off debug in viewer. And if debug is on, Viewer.debugInfo keeps debug info. 
    @public
    @property {Boolean} debug
    @since 2.1.0
    **/
    Object.defineProperty(this, 'debug',{
        set: function(value){
            this._impl._setDebug(value);
        },
        get : function(){ 
            return this._impl._getDebug();
        },
        enumerable: false,
        configurable: false
    }); 

    /**
    The debug info string for viewer. 
    @property {String} debugInfo
    @since 2.1.0
    **/
    Object.defineProperty(this, 'debugInfo',{
        get : function(){ 
            return this._impl._getDebugInfo();
        },
        enumerable: false,
        configurable: false
    });  
};

Viewer.prototype = {
    /**
    Adds a mesh to viewer. The mesh can be decorated in its attributes property to be identifed in downstream workflows.
    @since 1.0.0
    @public
    @method addMesh
    @param {CoreLibrary.Mesh3D} mesh The mesh to be added to the scene
    @chainable
    **/
    addMesh : function(mesh) {
        this._impl._addMesh(mesh);

        return this;
    },

    
    /**
    Removes all the meshes from the scene.
    @since 1.0.0
    @public
    @method removeAllMeshes
    @chainable
    **/
    removeAllMeshes : function() {
        this._impl._removeAllMeshes();

        return this;
    },

    /**
    Restores camera to home position.
    @since 1.0.0
    @public
    @method home
    @chainable
    **/
    home: function(){
        this._impl._home();

        return this;
    },

    /**
    Looks at a certain face.
    @since 1.0.0
    @public
    @param {Array} point the point to look at. e.g. [0, 0, 0]
    @param {Array} normal the normal of the face. 
    @param {Array} right the right direction.
    @method lookAt
    @chainable
    **/
    lookAt: function(point, normal, right){
        this._impl._lookAt(point, normal, right);

        return this;
    },

    /**
    Returns a thumbnail image data URL with given width and height. The result is a png data stream.
    @since 1.0.0
    @public
    @param {Number} width the width of the image
    @param {Number} height the height of the image
    @method imageURL
    @return {String}
    **/
    imageURL: function(width, height){
        return this._impl._imageURL(width, height);
    },

    /**
    Suspends rendering
    @since 1.0.0
    @public
    @method suspend
    @chainable
    **/
    suspend: function(){
        this._impl._suspend();
        return this;
    },

    /**
    Resumes rendering
    @since 1.0.0
    @public
    @method resume
    @chainable
    **/
    resume: function(){
        this._impl._resume();
        return this;
    },

    /**
    Refreshes the layout by resizing the canvas
    @since 1.0.0
    @public
    @method refresh
    @chainable
    **/
    refresh: function () {
        var handler = this._impl._windowResizeHandler();
        handler();
        return this;
    }
};

/*
The handler for updating attributes
@method mesh3DChangeHandler
*/
function threeMeshChangeHandler(event){
    if (event.data instanceof Mesh3D) {
        var mesh = event.data;
        if (mesh.attributes['viewer'] !== undefined && mesh.attributes['viewer']['threemesh'] !== undefined) {
            delete mesh.attributes['viewer']['threemesh'];
        }
    } 
};

Library.exports.Viewer = Viewer;

//pipeline.js
/**
Pipeline class, not exposed to external yet 
@class Pipeline
@static
@since 2.1.0
@private
**/
var Pipeline = function(params){ 
    
    this._renderer = params.renderer;
    this._scene = params.scene;
    this._camera = params.camera;
    this._bgScene = params.bgScene;
    this._bgCamera = params.bgCamera;
    this._rootObject = params.rootObject;
    this._windowWidth = params.width;
    this._windowHeight = params.height;
    this._highlightSet = params.highlightSet;

    this._ssao = null;
    this._ssaoRenderer = null;
    this._highlightRenderer = null;

};

Pipeline.prototype = {

    _getSSAORenderer : function(){
        if(!this._windowWidth || !this._windowHeight){
            return undefined;
        }

        if(this._ssaoRenderer){
            return this._ssaoRenderer;
        }

        var ssaoRenderer = {};

        var renderTargetParametersRGBA = { minFilter: THREE.LinearFilter, 
                            magFilter: THREE.LinearFilter, 
                            format: THREE.RGBAFormat};
        var renderTargetParametersRGB = { minFilter: THREE.LinearFilter, 
                            magFilter: THREE.LinearFilter, 
                            format: THREE.RGBFormat};
        var depthTarget = new THREE.WebGLRenderTarget(this._windowWidth, 
                this._windowHeight, 
                renderTargetParametersRGBA);
        var colorTarget = new THREE.WebGLRenderTarget(this._windowWidth, 
                this._windowHeight, 
                renderTargetParametersRGBA);
        ssaoRenderer.depthTarget = depthTarget;
        ssaoRenderer.colorTarget = colorTarget;

        ssaoRenderer.ssaoComposer = new THREE.EffectComposer( this._renderer, colorTarget);

        ssaoRenderer.effectSSAO = new THREE.ShaderPass(THREE.SSAOShader);
        ssaoRenderer.effectSSAO.uniforms[ 'tDepth' ].value = depthTarget;
        ssaoRenderer.effectSSAO.uniforms[ 'aoClamp' ].value = 0.5;
        ssaoRenderer.effectSSAO.uniforms[ 'onlyAO' ].value = 0;
        ssaoRenderer.effectSSAO.uniforms[ 'lumInfluence' ].value = 0.2;
        ssaoRenderer.effectSSAO.enabled = true;
        ssaoRenderer.ssaoComposer.addPass(ssaoRenderer.effectSSAO);

        ssaoRenderer.effectFxaa = new THREE.ShaderPass(THREE.FXAAShader);
        ssaoRenderer.ssaoComposer.addPass(ssaoRenderer.effectFxaa);

        if(!this.depthPlugin){
            this.depthPlugin = new THREE.DepthPassPlugin();
            this.depthPlugin.enabled = false;
            this._renderer.addPrePlugin(this.depthPlugin);
        }
        this.depthPlugin.renderTarget = depthTarget;
        ssaoRenderer.renderToScreen = true;
        ssaoRenderer.outputColorTarget = null;

        var self = this;
        ssaoRenderer.render = function(scene, camera){
            var renderer = self._renderer;

            // Sync near/far with camera's near/far.
            this.effectSSAO.uniforms[ 'cameraNear' ].value = camera.near;
            this.effectSSAO.uniforms[ 'cameraFar' ].value = camera.far;

            var ssaoScale = 16;
            this.effectSSAO.uniforms[ 'size' ].value.set(self._windowWidth * ssaoScale, self._windowHeight * ssaoScale);
            this.effectFxaa.uniforms['resolution'].value.set(1.0 / self._windowWidth,
                                                            1.0 / self._windowHeight);
            // Set up input & output params
            this.effectFxaa.renderToScreen = this.renderToScreen;
            if(!this.renderToScreen){ //output color target
                this.outputColorTarget = this.ssaoComposer.renderTarget2;
            }

            // Step1 render background
            if(self._bgScene && self._bgCamera){
                renderer.render( self._bgScene, self._bgCamera, this.ssaoComposer.renderTarget2, true );
                renderer.autoClearColor = false;
            }

            // Step2 render models and generate depth information for ssao pass
            self.depthPlugin.enabled = true;
            self._renderer.render( scene, camera, this.ssaoComposer.renderTarget2, true );
            self.depthPlugin.enabled = false;

            // Step3 blend ssao on background & model, and fxaa is applied for antialias
            this.ssaoComposer.render(self.scene, self.camera);
        };

        this._ssaoRenderer = ssaoRenderer;
        return ssaoRenderer;
    },

    _getHighlightRenderer : function (){
        if(!this._windowWidth || !this._windowHeight){
            return undefined;
        }

        if(this._highlightRenderer){
            return this._highlightRenderer;
        }

        var highlightRenderer = {};
        var renderTargetParameters = { minFilter: THREE.LinearFilter, 
                            magFilter: THREE.LinearFilter, 
                            format: THREE.RGBAFormat, 
                            stencilBuffer: false };
        highlightRenderer.renderTarget = new THREE.WebGLRenderTarget(this._windowWidth, 
                this._windowHeight, 
                renderTargetParameters);
        
        // step 1 render meshes on temp target, used for ssao disabled case.
        highlightRenderer.renderModelComposer = new THREE.EffectComposer(this._renderer, highlightRenderer.renderTarget); 
        var renderModel = new THREE.RenderPass( this._scene, this._camera );
        highlightRenderer.renderModelComposer.addPass(renderModel);

        // step 2 render highlight for selected meshes on temp target
        highlightRenderer.highlightComposer = new THREE.EffectComposer( this._renderer, highlightRenderer.renderTarget );
        highlightRenderer.highlightComposer.renderTarget2.shareDepthFrom = highlightRenderer.renderModelComposer.renderTarget2;
        var renderHighlight = new THREE.RenderPass( this._scene, this._camera );         
        renderHighlight.overrideMaterial = Materials.material('highlight'); ;
        highlightRenderer.highlightComposer.addPass( renderHighlight );

        var effectHorizBlur = new THREE.ShaderPass( THREE.HorizontalBlurShader );
        var effectVertiBlur = new THREE.ShaderPass( THREE.VerticalBlurShader );

        highlightRenderer.effectHorizBlur = effectHorizBlur;
        highlightRenderer.effectVertiBlur = effectVertiBlur;
        highlightRenderer.highlightComposer.addPass( effectHorizBlur );
        highlightRenderer.highlightComposer.addPass( effectVertiBlur );

        // step 3 compose result 1 and 2    
        highlightRenderer.finalComposer = new THREE.EffectComposer( this._renderer, highlightRenderer.renderTarget );
        var effectBlend = new THREE.ShaderPass( THREE.AdditiveBlendShader );
        effectBlend.uniforms[ 'fOpacity' ].value = 1.0;
        effectBlend.renderToScreen = true;
        highlightRenderer.effectBlend = effectBlend;
        highlightRenderer.finalComposer.addPass( effectBlend );

        highlightRenderer.inputColorTarget = undefined;
        var self = this;
        highlightRenderer.render = function(scene, camera){
            var renderer = self._renderer;

            this.effectHorizBlur.uniforms[ "h" ].value = 0.5 / self._windowWidth;
            this.effectVertiBlur.uniforms[ "v" ].value = 0.5 / self._windowHeight;

            // Step1 render background & model on target 
            if(self._bgScene && self._bgCamera){
                renderer.render( self._bgScene, self._bgCamera, this.renderModelComposer.renderTarget2, true );
                renderer.autoClearColor = false;
            }
            this.renderModelComposer.render();

            // Step2 render highlighed parts on target
            // reuse depth buffer, so don't clear depth here
            renderer.autoClearColor = true;
            renderer.autoClearDepth = false;
            // make unhighlighted meshes invisible, draw highlighed meshes only
            self._rootObject.traverse (function (mesh) {
                if (mesh instanceof THREE.Mesh) {
                    if(!mesh._highlighted){
                        mesh.visible = false;
                    }
                }
            });
            renderer.setClearColor(0x000000, 0);
            this.highlightComposer.render();
            
            // Step3 compose step1 and step2
            this.effectBlend.uniforms[ 'tDiffuse1' ].value = this.inputColorTarget ? this.inputColorTarget : highlightRenderer.renderModelComposer.renderTarget2;
            this.effectBlend.uniforms[ 'tDiffuse2' ].value = highlightRenderer.highlightComposer.renderTarget2;
            this.finalComposer.render();

            //restore renderer status
            renderer.autoClearDepth = true;
            // make unhighlighted mesh visible
            self._rootObject.traverse (function (mesh) {
                if (mesh instanceof THREE.Mesh) {
                    if(!mesh._highlighted){
                        mesh.visible = true;
                    }
                }
            });
        };

        this._highlightRenderer = highlightRenderer;
        return highlightRenderer;
    },

    render : function(){
        if(!this._windowWidth || !this._windowHeight){
            return;
        }

        var scene = this._scene;
        var camera = this._camera;
        var ssao = this._ssao;
        var highlight = this._highlightSet && this._highlightSet.size()>0;
        var renderer = this._renderer;
        var background = this._bgScene && this._bgCamera;
        renderer.autoClearColor = true;
        renderer.clear(true, true, true); 

        if(!ssao && !highlight){
            if(background){
                renderer.render(this._bgScene, this._bgCamera);
                // prevent background from being cleared by next pass.
                renderer.autoClearColor = false;
            }
            renderer.render(scene, camera);
            return;
        }

        if(ssao){
            var ssaoRenderer = this._getSSAORenderer();
            if(ssaoRenderer){
                ssaoRenderer.renderToScreen = !highlight;
                ssaoRenderer.render(scene, camera);
            }
        }

        if(highlight){
            var highlightRenderer = this._getHighlightRenderer();
            if(highlightRenderer){
                highlightRenderer.inputColorTarget = ssao ? 
                            ssaoRenderer.outputColorTarget : null;
                highlightRenderer.render(scene, camera);
            }
        }
    },

    highlightSet : function(highlightSet){
        this._highlightSet = highlightSet;
    },

    SSAO : function(ssao){
        this._ssao = ssao;
    },

    background : function(bgScene, bgCamera){
        this._bgScene = bgScene;
        this._bgCamera = bgCamera;
    }
};



//topic-introduction.js
/**
<p>The Autodesk Creative Platform Viewer is used to visualize 3D content. It provides rich settings in order to achieve the best visualization quality for different content.
  
Below is example code that explains how to include the Autodesk Creative Platform Viewer library in an HTML page.</p>

<pre class="prettyprint lang-html">
&lt;!-- Includes the Creative Platform Runtime --&gt;
&lt;script type="text/javascript" src="https://api.tinkercad.com/libraries/1jiw9epElcK/0/library.min.js"&gt;&lt;/script&gt;

&lt;!-- Downloads the Creative Platform Core and Viewer libraries --&gt;
&lt;script type="text/javascript"&gt;
creativePlatformRuntime.require(
    [
        { // Core library
            id: '1vxKXGNaLtr',
            version: 0 
        },
        { // Viewer library
            id: "c0HjtqUm7Wz", 
            version: 0
        }
    ], 
    function(core, viewer) { // Success callback
        // Initialize the Viewer 
        var div = document.getElementById("ViewerDiv");
        var params = {parent: div};
        var viewerApp = new viewer.Viewer(params);
        
        // Prepare content
        var mesh = new core.Mesh3D();
        
        viewerApp.addMesh(mesh)
        
        // Set options
        viewerApp.globalMaterial = 'red plastic';
        viewerApp.turntable = true;
    },
    function() { // Failure callback
    }
);

&lt;/script&gt;
</pre>

<br> 
<p>Here is an interactive demo to show different settings of the Viewer. It's built by using Creative Platform Core library and UI toolkit library</a>. 
<br> 

<div id="ViewerDiv" style="width:910px; height:660px; position: relative; background-color:#eeeeee;background-repeat: no-repeat;background-size: cover;"></div>

<script src="/libraries/1jiw9epElcK/0/library.min.js"></script>
<script>
$(document).ready(function () {
    var rt = window.creativePlatformRuntime;
    var environment = rt.environment;
    environment.setVariable(['urls', 'api'], window.location.protocol + '//' + window.location.host);
    var viewerLibrary = { // Viewer
        "id": 'c0HjtqUm7Wz',  
        "version": 0 
    };
    var coreLibrary = { // Core
        "id": '1vxKXGNaLtr',
        "version": 0 
    };
    var uiToolkitLibrary = {
        "id": 'aZS9YbvfqUX',
        "version": 0
    };
    rt.require(
        [viewerLibrary, coreLibrary, uiToolkitLibrary], 
        function(viewer, core, toolkit) {
            var divElement = document.getElementById("ViewerDiv");
            var viewLib = rt.findLibrary({'exportedSymbol':'Viewer'});
            divElement.style.backgroundImage = 'url(' + viewLib.resourceURL('divbackground.jpg') + ')';

            // Create two columns, left one is a viewer canvas and right one are some controls that can configure viewer.
            var width = parseInt(divElement.style.width) || divElement.clientWidth;
            var height = parseInt(divElement.style.height) || divElement.height;
            var leftDiv = divElement.ownerDocument.createElement("div");
            leftDiv.setAttribute("style","position: relative; float:left; width:" + (width - 250) 
                + "px; height:" + 600 + "px;");
            divElement.appendChild(leftDiv);
            
            var rightDiv = divElement.ownerDocument.createElement("div");
            rightDiv.setAttribute("style","position: absolute; right: 0px; top: 0px; width:" 
                + 250 + "px; height:" + 600 + "px;");
            divElement.appendChild(rightDiv);

            var params = {parent: leftDiv};
            window.viewerApp = new viewer.Viewer(params);

            // Controls to configure viewer by APIs
            var controls = toolkit.Controls;

            // create material drop down list to list all supported materials
            var getItem = function(id, text){
                var item = {};
                item.value = id;
                item.text = text;
                return item;
            };

            var addSeparate = function(){
                var div = divElement.ownerDocument.createElement("div");
                rightDiv.appendChild(div);
                div.innerHTML = '<br/>';
            };

            var meshLabel = divElement.ownerDocument.createElement("div");
            rightDiv.appendChild(meshLabel);
            meshLabel.innerHTML = '<label>{Viewer#addMesh}</label>';
            var meshDiv = divElement.ownerDocument.createElement("div");
            meshDiv.id = 'meshDiv';
            rightDiv.appendChild(meshDiv);

            window.meshControl = new controls.Dropdown({
                id:'meshes',
                parent: 'meshDiv',
                items: [
                    getItem(1, 'torus.stl'),
                    getItem(2, 'ring.stl'),
                    getItem(3, 'voronoi.stl'),
                    getItem(4, 'helix.stl'),
                    getItem(5, 'text.stl'),
                    getItem(6, 'pandent.stl'),
                    getItem(7, 'belt.stl'),
                    getItem(8, 'cufflink.stl')
                ]
            });
            
            window.highlightCheckBox = null;
            window.ssaoCheckBox = null;    
            window.meshControl.change.bind(function() {
                viewLib.resourceDataView(meshControl.selectedText, function(stlData) {
                    var mesh = core.Conversions.toMesh3DFromSTL(stlData);
                    
                    //clear highlight
                    if(highlightCheckBox && highlightCheckBox.checked){
                        highlightCheckBox.checked = false;
                    }

                    // API remveAllMeshes
                    viewerApp.removeAllMeshes();  
                    // API Viewer.addMesh
                    viewerApp.addMesh(mesh);
                    // API Viewer.home
                    viewerApp.home();

                    window.meshControl.mesh = mesh;
                });
            });
            meshControl.selectedText = 'torus.stl';
            
            addSeparate();
            var materialLabel = divElement.ownerDocument.createElement("div");
            rightDiv.appendChild(materialLabel);
            materialLabel.innerHTML = '<label>{Viewer#globalMaterial}</label>';
            var materialDiv = divElement.ownerDocument.createElement("div");
            materialDiv.id = 'materialDiv';
            rightDiv.appendChild(materialDiv);

            window.materialControl = new controls.Dropdown({
                id:'materials',
                parent: 'materialDiv',
                items: [
                    getItem(1, 'red plastic'),
                    getItem(2, 'red polished plastic'),
                    getItem(3, 'white polished plastic'),
                    getItem(4, 'black polished plastic'),
                    getItem(5, 'blue polished plastic'),
                    getItem(6, 'yellow polished plastic'),
                    getItem(7, 'beige polished plastic'),
                    getItem(8, 'green polished plastic'),
                    getItem(9, 'brown polished plastic'),
                    getItem(10, 'pink polished plastic'),
                    getItem(11, 'orange polished plastic'),

                    getItem(12, 'white ceramic'),
                    getItem(13, 'yellow ceramic'),
                    getItem(14, 'green ceramic' ),
                    getItem(15, 'aqua ceramic'),
                    getItem(16, 'black ceramic'),
                    getItem(17, 'orange ceramic' ),

                    getItem(18, 'polished silver'),

                    getItem(20, 'stainless steel antique bronze'),
                    getItem(21, 'stainless steel polished'),
                    getItem(22, 'stainless steel wheat penny'),
                    
                    getItem(23, 'natrual white plastic'),
                    getItem(24, 'dremel blue plastic'),
                    getItem(25, 'cotton white plastic'),
                    getItem(26, 'deep black plastic'),
                    getItem(27, 'electric orange plastic'),
                    getItem(28, 'grass green plastic'),
                    getItem(29, 'racecar red plastic'),
                    getItem(30, 'gold medal plastic'),
                    getItem(31, 'silver spoon plastic'),
                    getItem(32, 'purple orchid plastic'),

                    getItem(33, 'red polyamide'),
                    getItem(34, 'white polyamide'),
                    getItem(35, 'black polyamide'),
                    getItem(36, 'blue polyamide'),
                    getItem(37, 'yellow polyamide'),
                    getItem(38, 'beige polyamide'),
                    getItem(39, 'green polyamide'),
                    getItem(40, 'brown polyamide'),
                    getItem(41, 'pink polyamide'),
                    getItem(42, 'orange polyamide'),

                    getItem(43, 'alumide'),
                    getItem(44, 'titanium'),
                    getItem(45, 'platinum'),
                    getItem(46, 'brass'),
                    getItem(47, 'bronze'),
                    getItem(48, '14k gold'),
                    getItem(49, '14k rose gold'),
                    getItem(50, '14k white gold'),
                    getItem(51, '18k gold'),
                    getItem(52, '18k rose gold'),
                    getItem(53, 'orange wax'),
                    getItem(54, 'black rubber'),
                    getItem(55, 'white resin'),
                    getItem(56, 'black resin'),
                    getItem(57, 'translucent resin'),

                    getItem(60,  'green ceramic prism'),
                    getItem(61, 'yellow ceramic prism'),
                    getItem(62, 'white ceramic prism'),
                    getItem(63, '14k gold prism'),
                    getItem(64, 'polished silver prism')
                ]
            });
            
            materialControl.change.bind(function() {
                // API Viewer.globalMaterial
                viewerApp.globalMaterial = materialControl.selectedText;
            });
            materialControl.selectedText = 'red plastic';

            addSeparate();
            var envsLabel = divElement.ownerDocument.createElement("div");
            rightDiv.appendChild(envsLabel);
            envsLabel.innerHTML = '<label>{Viewer#environment}</label>';
            var envsDiv = divElement.ownerDocument.createElement("div");
            envsDiv.id = 'envsDiv';
            rightDiv.appendChild(envsDiv);
            window.envsControl = new controls.Dropdown({
                id:'envs',
                parent: 'envsDiv',
                items: [
                    getItem(2, 'idviz'),
                    getItem(3, 'scgeneric'),
                    getItem(1, 'infinitypool'),
                    getItem(4, 'riverbank')
                ]
            });
           
            envsControl.change.bind(function() {
                var envs = [];
                var name = envsControl.selectedText;
                var url1 = viewLib.resourceURL(name + '_irr.logluv.dds');
                var url2 = viewLib.resourceURL(name + '_mipdrop.logluv.dds');
                envs.push(url1);
                envs.push(url2);
                // API Viewer.globalMaterial
                viewerApp.environment = envs;
            });
            envsControl.selectedText = 'idviz';

            var addCheckBox = function(name, addLabel, labelName, callback, textName, defaultValue){
                if(addLabel){
                    addSeparate();
                    var label = divElement.ownerDocument.createElement("div");
                    rightDiv.appendChild(label);
                    label.innerHTML = labelName;
                }
                
                var div = divElement.ownerDocument.createElement("div");
                div.id = name + 'Div';
                rightDiv.appendChild(div);
                var control = new controls.Checkbox({
                    id:'chk' + name,
                    parent: name + 'Div',
                    text: textName ? textName : 'Enable'
                });

                control.change.bind(callback);

                control.enable = defaultValue !== undefined ? defaultValue : false;

                return control;
            };

            // Create ssao check box
            window.ssaoCallback = function () {
                // API Viewer.ssao
                viewerApp.ssao = window.ssaoCheckBox.checked;         
            };
            window.ssaoCheckBox = addCheckBox('ssao', true, '<label>{Viewer#ssao}</label>', window.ssaoCallback);
            
            // Create highlight check box for mesh
            window.highlightCallback = function () {
                if(window.highlightCheckBox.checked){
                    // API Viewer.highlightSet.add
                    viewerApp.highlightSet.add(window.meshControl.mesh);
                }
                else{
                    // API Viewer.highlightSet.remove
                    viewerApp.highlightSet.remove(window.meshControl.mesh);
                }
            };
            window.highlightCheckBox = addCheckBox('highlightSet', true, '<label>{Viewer#highlightSet}</label>', window.highlightCallback);

            // Create turntable check box
            window.turntableCallback = function(){
                // API Viewer.turntable
                viewerApp.turntable = window.turntableCheckBox.checked;
            };           
            window.turntableCheckBox = addCheckBox('turntable', true, '<label>{Viewer#turntable}</label>', turntableCallback, 'Enabled', true);
            turntableCheckBox.checked = true;

            // Create check boxes for statusText, errorText, showLoading 
            window.statusTextCallback = function () {
                if(statusTextCheckBox.checked){
                    // API Viewer.statusText
                    viewerApp.statusText = 'This is a text status.';
                }
                else{
                    viewerApp.statusText = '';    
                }            
            };
            window.statusTextCheckBox = addCheckBox('statusText', true, '<label>{Viewer#statusText}</label>', window.statusTextCallback);

            window.errorTextCallback = function () {
                if(window.errorTextCheckBox.checked){
                    // API Viewer.errorText
                    viewerApp.errorText = 'This is a error text.';
                }
                else{
                    viewerApp.errorText = '';    
                }            
            };
            window.errorTextCheckBox = addCheckBox('errorText', true, '<label>{Viewer#errorText}</label>', window.errorTextCallback);

            window.showLoadingCallback = function () {
                // API Viewer.showLoading
                viewerApp.showLoading = showLoadingCheckBox.checked;            
            };
            window.showLoadingCheckBox = addCheckBox('showLoading', true, '<label>{Viewer#showLoading}</label>', window.showLoadingCallback);

            // Create check box for background
            window.backgroundCallback = function () {
                if(window.backgroundCheckBox.checked){
                    // API Viewer.background
                    viewerApp.background = viewLib.resourceURL('background.jpg');
                }
                else{
                    viewerApp.background = '';    
                }            
            };
            window.backgroundCheckBox = addCheckBox('background', true, '<label>{Viewer#background}</label>', window.backgroundCallback);

            // Create check box for environment
            window.environmentCallback = function () {
                if(environmentCheckBox.checked){
                    // API Viewer.environment
                    viewerApp.environment = viewLib.resourceURL('environment.jpg');
                }
                else{
                    viewerApp.environment = '';    
                }            
            };
            window.environmentCheckBox = addCheckBox('environment', true, '<label>{Viewer#environment}</label>', window.environmentCallback);

            // Create combobox for shading mode
            addSeparate();
            var shadingLabel = divElement.ownerDocument.createElement("div");
            rightDiv.appendChild(shadingLabel);
            shadingLabel.innerHTML = '<label>{Viewer#shading}</label>';
            var shadingDiv = divElement.ownerDocument.createElement("div");
            shadingDiv.id = 'shadingDiv';
            rightDiv.appendChild(shadingDiv);

            window.shadingControl = new controls.Dropdown({
                id:'shading',
                parent: 'shadingDiv',
                items: [
                    getItem(1, 'flat'),
                    getItem(2, 'smooth')
                ]
            });
            
            shadingControl.change.bind(function() {
                // API Viewer.shading
                viewerApp.shading = shadingControl.selectedText;
            });
            shadingControl.selectedText = 'flat';

            window.debugCallback = function () {
                viewerApp.debug = debugCheckbox.checked;          
            };
            window.debugCheckbox = addCheckBox('debug', true, '<label>{Viewer#debug}</label>', window.debugCallback);
        },
        function() {
            alert('Failed to load 3D Viewer');
        }
    );
});
</script>


@topic Interactive Demonstration
**/

//documentation.js
/**
This version represents the initial debut of 3D Viewer.
@version 1.0.0
@released 2014-03-03T00:00:00Z
@markdown
**/

/**
- Added `errorText` property in {Viewer} class.
- Added `statusText` property in {Viewer} class.
@version 1.1.0
@released 2014-06-13T00:00:00Z
@markdown
**/

/**
- Added `highlightSet` property in {Viewer} class which is a {CoreLibrary.RefSet} type
@version 1.2.0
@released 2014-06-23T00:00:00Z
@markdown
**/

/**
- Moved {CoreLibrary.RefSet} to the Core library
@version 2.0.0
@released 2014-07-03T00:00:00Z
@markdown
**/

/**
- Added `ssao` property in {Viewer} class which is a {boolean} type
@version 2.1.0
@released 2014-07-10T00:00:00Z
@markdown
**/

//additiveblend.js

/**
shader to add additive blend 
@class AdditiveBlendShader
@since 2.1.0
@private
**/
THREE.AdditiveBlendShader = {

    uniforms: {
    
        "tDiffuse1": { type: "t", value: null },
        "tDiffuse2": { type: "t", value: null },
        "fOpacity" : { type: "f", value: 1.0},
    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

            "vUv = uv;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform sampler2D tDiffuse1;",
        "uniform sampler2D tDiffuse2;",
        "uniform float fOpacity;",

        "varying vec2 vUv;",

        "void main() {",

            "vec4 texel1 = texture2D( tDiffuse1, vUv );",
            "vec4 texel2 = texture2D( tDiffuse2, vUv );",
            "vec3 additiveColor = vec3(0.0);",
            "float alpha = texel1.a;",
            "if(alpha==0.0 && texel2.a != 0.0){",
                "additiveColor = vec3(0.1);",
                "alpha = 0.01;",
            "}",
            "gl_FragColor = vec4(texel1.rgb  + additiveColor + (texel2 * fOpacity).rgb, alpha);",
        "}"

    ].join("\n")

};
//horizontalblurshader.js
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

THREE.HorizontalBlurShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"h":        { type: "f", value: 1.0 / 512.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float h;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};

//verticalblurshader.js
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

THREE.VerticalBlurShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"v":        { type: "f", value: 1.0 / 512.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float v;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};

//debugui.js
/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _DebugUI
@param {DOMElement} parent parent to show the debug UI. 
@param {Int} width width for the debug UI Div. 
@param {Int} height height for the debug UI Div. 
@private
**/
var _DebugUI = function(parent, width, height, viewer) {
    this.viewer = viewer;
    this.Div = parent.ownerDocument.createElement("div");
    parent.appendChild(this.Div);
    //left 200 px for debug ui div; right region for canvas 3d
    this.Div.setAttribute("style","background-color:#FFA500;float:right; width:" + width + "px; height:" + height + "px;");

    this.currentItemDiv = null;
};

/**   
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _DebugUI
@private
**/
_DebugUI.prototype = {
    /**
    This method used to create display item together with display label to show its name and result label to show the result value.
    @method createDisplayItem
    @since 1.0.0
    @param {String} name The label name for the item.
    @param {String} itemType The type of item element, can be "input", "div", etc.
    @param {JSON Object} params attributes used to apply on the item element.
    @param {Function} onchangeCallback
    @param {Bool} needShowResult Whether the result label need be added.
    @private
    **/
    createDisplayItem : function(name, 
                                itemType, 
                                params, 
                                onchangeCallback, 
                                needShowResult) {
        this.currentItemDiv = this.Div.ownerDocument.createElement("div");

        // Create label with given display name.
        var label = this.Div.ownerDocument.createElement("label");
        label.innerHTML = name;
        this.currentItemDiv.appendChild(label);
        label.setAttribute("style", "float: none;");

        if (itemType) {
            var item = this.Div.ownerDocument.createElement(itemType);
            if (params) {
                for (var key in params) {
                    item.setAttribute(key, params[key]);
                }
            }

            this.currentItemDiv.appendChild(item);

            var valueLabel = null;
            if (needShowResult) {
                valueLabel = this.Div.ownerDocument.createElement("label");
                valueLabel.setAttribute("style", "float: none;display:inline");
                valueLabel.setAttribute("id", params.hasOwnProperty("id") ? params.id + "Val" : name + "Val");
                if (params.hasOwnProperty("value")) {
                    valueLabel.innerHTML = params.value;
                }
                this.currentItemDiv.appendChild(valueLabel);
            }
            
            item.onchange = function() { 
                if (valueLabel) {
                    valueLabel.innerHTML = item.value;
                }

                if (onchangeCallback) {
                    onchangeCallback(item.value);
                }
            };
        }

        this.Div.appendChild(this.currentItemDiv);
        return this.currentItemDiv;
    },

    /**
    This method used to create only display item, the created display item will be append to current item Div.
    @method appendDisplayItem
    @since 1.0.0
    @param {String} itemType The type of item element, can be "input", "div", etc.
    @param {JSON Object} params attributes used to apply on the item element.
    @param {Function} onchangeCallback
    @private
    **/
    appendDisplayItem : function(itemType, params, onchangeCallback) {
        var item = this.Div.ownerDocument.createElement(itemType);
        if (params) {
            for (var key in params) {
                item.setAttribute(key, params[key]);
            }
        }

        this.currentItemDiv.appendChild(item);
        
        item.onchange = function() { 
            if (onchangeCallback) {
                onchangeCallback(item.value);
            }
        };

        return item;
    },

    /**
    This method used to create debug UI for viewer including lightings, materials.
    @method createDebugUIControls
    @since 2.1.0
    @param {String} itemType The type of item element, can be "input", "div", etc.
    @param {JSON Object} params attributes used to apply on the item element.
    @param {Function} onchangeCallback
    @private
    **/
    createDebugUIControls : function () {
        if(!this.initialized){
            var viewer = this.viewer;
            var updateValues = function() {
                var mat = Materials.material(viewer.globalMaterial);
                viewer._computeBumpDensityAndAmplitude(mat);
                document.getElementById("dir1Intensity").value = mat.dirLight1 ? mat.dirLight1 : viewer.light.dirLight1.intensity;
                document.getElementById("dir1IntensityVal").innerHTML = mat.dirLight1 ? mat.dirLight1 : viewer.light.dirLight1.intensity;

                document.getElementById("dir2Intensity").value = mat.dirLight2 ? mat.dirLight2 : viewer.light.dirLight2.intensity;
                document.getElementById("dir2IntensityVal").innerHTML = mat.dirLight2 ? mat.dirLight2 : viewer.light.dirLight2.intensity;

                document.getElementById("pointLight1Intensity").value = mat.pointLight1 ? mat.pointLight1 : viewer.light.pointLight1.intensity;
                document.getElementById("pointLight1IntensityVal").innerHTML = mat.pointLight1 ? mat.pointLight1 : viewer.light.pointLight1.intensity;

                document.getElementById("pointLight2Intensity").value = mat.pointLight2 ? mat.pointLight2 : viewer.light.pointLight2.intensity;
                document.getElementById("pointLight2IntensityVal").innerHTML = mat.pointLight2 ? mat.pointLight2 : viewer.light.pointLight2.intensity;

                document.getElementById("sky").value = mat.skyLight ? mat.skyLight : viewer.light.skyLight.intensity;
                document.getElementById("skyVal").innerHTML = mat.skyLight ? mat.skyLight : viewer.light.skyLight.intensity;

                document.getElementById("ambientLight").value = mat.ambientLight ? mat.ambientLight : "0x" + viewer.ambientLight.color.getHexString();
                document.getElementById("color").value = "0x" + (mat.color ? mat.color.getHexString() : "");
                document.getElementById("specular").value = "0x" + (mat.specular ? mat.specular.getHexString() : "");

                document.getElementById("reflection").value = mat && mat.useEnvMap ? mat.reflectivity : 0;
                document.getElementById("reflectionVal").innerHTML = mat && mat.useEnvMap ? mat.reflectivity : 0;

                document.getElementById("bumpDensity").value = mat.bumpDensity;
            };

            // The material label.
            var textParams = {"id": "material",
                              "value": viewer.globalMaterial,
                              "size": "15"
                             };
            this.createDisplayItem("material", "input", textParams, function(newVal) {
                viewer._setGlobalMaterial(newVal);
                updateValues();
                viewer.dataDirty = true;
            });

            // Material properties, these property value need be changed after material changes.
            // ------------------------
            var rangeParams = {"id": "dir1Intensity",
                              "type": "range",
                              "min": "0.0",
                              "max": "1.0",
                              "step": "0.05"
                              };
            this.createDisplayItem("light1", "input", rangeParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                if (mat.hasOwnProperty("dirLight1")) {
                    mat.dirLight1 = parseFloat(newVal);
                }
                viewer.light.dirLight1.intensity = parseFloat(newVal); 
                viewer.dataDirty = true;
            }, true);

            rangeParams.id = "dir2Intensity";
            this.createDisplayItem("light2", "input", rangeParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                if (mat.hasOwnProperty("dirLight2")) {
                    mat.dirLight2 = parseFloat(newVal);
                }
                viewer.light.dirLight2.intensity = parseFloat(newVal); 
                viewer.dataDirty = true;
            }, true);

            rangeParams.id = "pointLight1Intensity";
            this.createDisplayItem("pointlight1", "input", rangeParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                if (mat.hasOwnProperty("pointLight1")) {
                    mat.pointLight1 = parseFloat(newVal);
                }
                viewer.light.pointLight1.intensity = parseFloat(newVal); 
                viewer.dataDirty = true;
            }, true);

            rangeParams.id = "pointLight2Intensity";
            this.createDisplayItem("pointlight2", "input", rangeParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                if (mat.hasOwnProperty("pointLight2")) {
                    mat.pointLight2 = parseFloat(newVal);
                }
                viewer.light.pointLight2.intensity = parseFloat(newVal); 
                viewer.dataDirty = true;
            }, true);

            rangeParams.id = "sky";
            this.createDisplayItem("sky", "input", rangeParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                if (mat.hasOwnProperty("skyLight")) {
                    mat.skyLight = parseFloat(newVal);
                }
                viewer.light.skyLight.intensity = parseFloat(newVal); 
                viewer.dataDirty = true;
            }, true);

            textParams.id = "color";
            textParams.size = "15";
            this.createDisplayItem("color", "input", textParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                if (mat.hasOwnProperty("color")) {
                    mat.color.set(parseInt(newVal));
                    mat.ambient.set(parseInt(newVal));
                    viewer.dataDirty = true;
                }
            });

            textParams.id = "ambientLight";
            textParams.size = "15";
            this.createDisplayItem("ambient", "input", textParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                if (mat.hasOwnProperty("ambientLight")) {
                    mat.ambientLight = newVal;
                }
                viewer.light.ambientLight.color.set(parseInt(newVal));
                viewer.dataDirty = true;
            });

            textParams.id = "specular";
            textParams.size = "15";
            this.createDisplayItem("specular", "input", textParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                mat.specular.set(parseInt(newVal));
                viewer.dataDirty = true;
            });

            rangeParams.id = "reflection";
            rangeParams.style = "float: none;width: 100px";
            this.createDisplayItem("reflection", "input", rangeParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                mat.reflectivity = newVal;
                viewer.dataDirty = true;
            }, true);

            textParams.id = "bumpDensity";
            textParams.size = "15";
            this.createDisplayItem("bumpDensity", "input", textParams, function(newVal) {
                var mat = Materials.material(viewer.globalMaterial);
                mat.bumpDensity = parseFloat(newVal);
                viewer.dataDirty = true;
            });

            // Call update to update control values.
            updateValues();

            this.initialized = true;
        }
    },
};
//stats.js
/**
 * @author mrdoob / http://mrdoob.com/
 */

var Stats = function () {

	var startTime = Date.now(), prevTime = startTime;
	var ms = 0, msMin = Infinity, msMax = 0;
	var fps = 0, fpsMin = Infinity, fpsMax = 0;
	var frames = 0, mode = 0;

	var container = document.createElement( 'div' );
	container.id = 'stats';
	container.addEventListener( 'mousedown', function ( event ) { event.preventDefault(); setMode( ++ mode % 2 ) }, false );
	container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';

	var fpsDiv = document.createElement( 'div' );
	fpsDiv.id = 'fps';
	fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
	container.appendChild( fpsDiv );

	var fpsText = document.createElement( 'div' );
	fpsText.id = 'fpsText';
	fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
	fpsText.innerHTML = 'FPS';
	fpsDiv.appendChild( fpsText );

	var fpsGraph = document.createElement( 'div' );
	fpsGraph.id = 'fpsGraph';
	fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
	fpsDiv.appendChild( fpsGraph );

	while ( fpsGraph.children.length < 74 ) {

		var bar = document.createElement( 'span' );
		bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
		fpsGraph.appendChild( bar );

	}

	var msDiv = document.createElement( 'div' );
	msDiv.id = 'ms';
	msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
	container.appendChild( msDiv );

	var msText = document.createElement( 'div' );
	msText.id = 'msText';
	msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
	msText.innerHTML = 'MS';
	msDiv.appendChild( msText );

	var msGraph = document.createElement( 'div' );
	msGraph.id = 'msGraph';
	msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
	msDiv.appendChild( msGraph );

	while ( msGraph.children.length < 74 ) {

		var bar = document.createElement( 'span' );
		bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
		msGraph.appendChild( bar );

	}

	var setMode = function ( value ) {

		mode = value;

		switch ( mode ) {

			case 0:
				fpsDiv.style.display = 'block';
				msDiv.style.display = 'none';
				break;
			case 1:
				fpsDiv.style.display = 'none';
				msDiv.style.display = 'block';
				break;
		}

	}

	var updateGraph = function ( dom, value ) {

		var child = dom.appendChild( dom.firstChild );
		child.style.height = value + 'px';

	}

	return {

		REVISION: 11,

		domElement: container,

		setMode: setMode,

		fpsCount: 0,
		
		fpsSum: 0,

		begin: function () {

			startTime = Date.now();

		},

		end: function () {

			var time = Date.now();

			ms = time - startTime;
			msMin = Math.min( msMin, ms );
			msMax = Math.max( msMax, ms );

			msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
			updateGraph( msGraph, Math.min( 30, 30 - ( ms / 200 ) * 30 ) );
			
			if(!this.fpsCount){
				this.fpsStart = prevTime;
			}
			this.fpsEnd = time;

			frames ++;

			if ( time > prevTime + 500 ) {

				fps = Math.round( ( frames * 1000 ) / ( time - prevTime ) );
				fpsMin = Math.min( fpsMin, fps );
				fpsMax = Math.max( fpsMax, fps );

				this.fpsCount ++;
				this.fpsSum += fps;
				this.fpsMin = fpsMin;
				this.fpsMax = fpsMax;

				fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
				updateGraph( fpsGraph, Math.min( 30, 30 - ( fps / 100 ) * 30 ) );     

				prevTime = time;
				frames = 0;

			}

			return time;

		},

		update: function () {

			startTime = this.end();

		}

	}

};
//threepatches.js
/**
ThreePatches class, not exposed to external yet 
@class ThreePatches
@static
@since 2.1.0
@private
**/

var ThreePatches = {
  initialize : function(){
        ThreePatches._patchShaderToSupportProcedureTexture();
        ThreePatches._patchGeometryToAddCustomizedNormals();
        ThreePatches._patchMesh3DToBufferGeometry();
        ThreePatches._patchImageUtils();
        ThreePatches._patchSetFromObject();
    },
    
    _patchShaderToSupportProcedureTexture : function(){
        // Extend phong shader to let it support procedural shading.
        // To use the procedural shading, we need call _useCustomizedBump on the materil object. Otherwise, the extended code
        // won't take any effects.
        THREE.ShaderChunk['lights_phong_pars_vertex'] = THREE.ShaderChunk['lights_phong_pars_vertex'] + 
        ["",
         "varying vec3 vTexCoord3D;",
         "varying vec3 vObjectNormal;"
        ].join("\n");
        THREE.ShaderChunk['lights_phong_vertex'] = THREE.ShaderChunk['lights_phong_vertex'] + 
        ["",
         "vTexCoord3D = worldPosition.xyz;",
         "vObjectNormal = normal;"
        ].join("\n");

        THREE.ShaderChunk['lights_phong_pars_fragment'] = THREE.ShaderChunk['lights_phong_pars_fragment'] + 
        ["",
            "#ifndef USE_BUMPMAP",
            "varying vec3 vTexCoord3D;",
            "varying vec3 vObjectNormal;",
            "uniform float bumpDensity;",
            "uniform float bumpAmplitude;",
            "uniform int bumpType;",
            "#extension GL_OES_standard_derivatives : enable",
            "vec3 mod289(vec3 x)",
            "{",
              "return x - floor(x * (1.0 / 289.0)) * 289.0;",
            "}",

            "vec4 mod289(vec4 x)",
            "{",
             " return x - floor(x * (1.0 / 289.0)) * 289.0;",
            "}",

            "vec4 permute(vec4 x)",
            "{",
            "  return mod289(((x*34.0)+1.0)*x);",
            "}",

            "vec4 taylorInvSqrt(vec4 r)",
            "{",
            "  return 1.79284291400159 - 0.85373472095314 * r;",
            "}",

            "vec3 fade(vec3 t) {",
            "  return t*t*t*(t*(t*6.0-15.0)+10.0);",
            "}",

            // Classic Perlin noise, periodic variant
            "float pnoise(vec3 P, vec3 rep)",
            "{",
             " vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period",
              "vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period",
              "Pi0 = mod289(Pi0);",
              "Pi1 = mod289(Pi1);",
              "vec3 Pf0 = fract(P); // Fractional part for interpolation",
              "vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0",
              "vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);",
              "vec4 iy = vec4(Pi0.yy, Pi1.yy);",
              "vec4 iz0 = Pi0.zzzz;",
              "vec4 iz1 = Pi1.zzzz;",

              "vec4 ixy = permute(permute(ix) + iy);",
              "vec4 ixy0 = permute(ixy + iz0);",
              "vec4 ixy1 = permute(ixy + iz1);",

              "vec4 gx0 = ixy0 * (1.0 / 7.0);",
              "vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;",
              "gx0 = fract(gx0);",
              "vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);",
              "vec4 sz0 = step(gz0, vec4(0.0));",
              "gx0 -= sz0 * (step(0.0, gx0) - 0.5);",
              "gy0 -= sz0 * (step(0.0, gy0) - 0.5);",

              "vec4 gx1 = ixy1 * (1.0 / 7.0);",
              "vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;",
              "gx1 = fract(gx1);",
              "vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);",
              "vec4 sz1 = step(gz1, vec4(0.0));",
              "gx1 -= sz1 * (step(0.0, gx1) - 0.5);",
              "gy1 -= sz1 * (step(0.0, gy1) - 0.5);",

              "vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);",
              "vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);",
              "vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);",
              "vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);",
              "vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);",
              "vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);",
              "vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);",
              "vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);",

              "vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));",
              "g000 *= norm0.x;",
              "g010 *= norm0.y;",
              "g100 *= norm0.z;",
              "g110 *= norm0.w;",
              "vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));",
              "g001 *= norm1.x;",
              "g011 *= norm1.y;",
              "g101 *= norm1.z;",
              "g111 *= norm1.w;",

              "float n000 = dot(g000, Pf0);",
              "float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));",
              "float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));",
              "float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));",
              "float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));",
              "float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));",
              "float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));",
              "float n111 = dot(g111, Pf1);",

              "vec3 fade_xyz = fade(Pf0);",
              "vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);",
              "vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);",
              "float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); ",
              "return 2.2 * n_xyz;",
            "}",

            "float stripes( float x, float f) {",
                    "float PI = 3.14159265358979323846264;",
                    "float t = .5 + .5 * sin( f * 2.0 * PI * x);",
                    "return t * t - .5;",
            "}",

            "float turbulence( vec3 p, float scale ) {",
            "   float w = 100.0;",
            "   float t = -1.5;",
            "   for (float f = 1.0 ; f <= 1.0 ; f++ ){",
            "       float power = pow( 2.0, f ) * scale;",
            "       t += abs( pnoise( vec3( power * p ), vec3(0, 0, 0 ) ) / power );",
            "   }",
            "   return t;",
            "}",
            "vec3 perturbNormalArbEx( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",
              "vec3 vSigmaX = dFdx( surf_pos );",
              "vec3 vSigmaY = dFdy( surf_pos );",
              "vec3 vN = surf_norm;",     // normalized

              "vec3 R1 = cross( vSigmaY, vN );",
              "vec3 R2 = cross( vN, vSigmaX );",

              "float fDet = dot( vSigmaX, R1 );",

              "vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
              "return normalize( abs( fDet ) * surf_norm - vGrad );",
            "}",

            "float snoise(vec3 v) {",
              "const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;",
              "const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);",

            // First corner
              "vec3 i  = floor(v + dot(v, C.yyy) );",
              "vec3 x0 =   v - i + dot(i, C.xxx) ;",

            // Other corners
              "vec3 g = step(x0.yzx, x0.xyz);",
              "vec3 l = 1.0 - g;",
              "vec3 i1 = min( g.xyz, l.zxy );",
              "vec3 i2 = max( g.xyz, l.zxy );",

              //   x0 = x0 - 0.0 + 0.0 * C.xxx;
              //   x1 = x0 - i1  + 1.0 * C.xxx;
              //   x2 = x0 - i2  + 2.0 * C.xxx;
              //   x3 = x0 - 1.0 + 3.0 * C.xxx;
              "vec3 x1 = x0 - i1 + C.xxx;",
              "vec3 x2 = x0 - i2 + C.yyy;", // 2.0*C.x = 1/3 = C.y
              "vec3 x3 = x0 - D.yyy;",      // -1.0+3.0*C.x = -0.5 = -D.y

            // Permutations
              "i = mod289(i);",
              "vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));",

            // Gradients: 7x7 points over a square, mapped onto an octahedron.
            // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
              "float n_ = 0.142857142857;", // 1.0/7.0
              "vec3  ns = n_ * D.wyz - D.xzx;",

              "vec4 j = p - 49.0 * floor(p * ns.z * ns.z);",  //  mod(p,7*7)

              "vec4 x_ = floor(j * ns.z);",
              "vec4 y_ = floor(j - 7.0 * x_ );",    // mod(j,N)

              "vec4 x = x_ *ns.x + ns.yyyy;",
              "vec4 y = y_ *ns.x + ns.yyyy;",
              "vec4 h = 1.0 - abs(x) - abs(y);",

              "vec4 b0 = vec4( x.xy, y.xy );",
              "vec4 b1 = vec4( x.zw, y.zw );",

              //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
              //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
              "vec4 s0 = floor(b0)*2.0 + 1.0;",
              "vec4 s1 = floor(b1)*2.0 + 1.0;",
              "vec4 sh = -step(h, vec4(0.0));",

              "vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;",
              "vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;",

              "vec3 p0 = vec3(a0.xy,h.x);",
              "vec3 p1 = vec3(a0.zw,h.y);",
              "vec3 p2 = vec3(a1.xy,h.z);",
              "vec3 p3 = vec3(a1.zw,h.w);",

            //Normalise gradients
              "vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));",
              "p0 *= norm.x;",
              "p1 *= norm.y;",
              "p2 *= norm.z;",
              "p3 *= norm.w;",

            // Mix final noise value
              "vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);",
              "m = m * m;",
              "return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );",
            "}",

            // Classic Perlin noise
            "float cnoise(vec3 P)",
            "{",
              "vec3 Pi0 = floor(P); // Integer part for indexing",
              "vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1",
              "Pi0 = mod289(Pi0);",
              "Pi1 = mod289(Pi1);",
              "vec3 Pf0 = fract(P); // Fractional part for interpolation",
              "vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0",
              "vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);",
              "vec4 iy = vec4(Pi0.yy, Pi1.yy);",
              "vec4 iz0 = Pi0.zzzz;",
              "vec4 iz1 = Pi1.zzzz;",

              "vec4 ixy = permute(permute(ix) + iy);",
              "vec4 ixy0 = permute(ixy + iz0);",
              "vec4 ixy1 = permute(ixy + iz1);",

              "vec4 gx0 = ixy0 * (1.0 / 7.0);",
              "vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;",
              "gx0 = fract(gx0);",
              "vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);",
              "vec4 sz0 = step(gz0, vec4(0.0));",
              "gx0 -= sz0 * (step(0.0, gx0) - 0.5);",
              "gy0 -= sz0 * (step(0.0, gy0) - 0.5);",

              "vec4 gx1 = ixy1 * (1.0 / 7.0);",
              "vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;",
              "gx1 = fract(gx1);",
              "vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);",
              "vec4 sz1 = step(gz1, vec4(0.0));",
              "gx1 -= sz1 * (step(0.0, gx1) - 0.5);",
              "gy1 -= sz1 * (step(0.0, gy1) - 0.5);",

              "vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);",
              "vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);",
              "vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);",
              "vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);",
              "vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);",
              "vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);",
              "vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);",
              "vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);",

              "vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));",
              "g000 *= norm0.x;",
              "g010 *= norm0.y;",
              "g100 *= norm0.z;",
              "g110 *= norm0.w;",
              "vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));",
              "g001 *= norm1.x;",
              "g011 *= norm1.y;",
              "g101 *= norm1.z;",
              "g111 *= norm1.w;",

              "float n000 = dot(g000, Pf0);",
              "float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));",
              "float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));",
              "float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));",
              "float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));",
              "float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));",
              "float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));",
              "float n111 = dot(g111, Pf1);",

              "vec3 fade_xyz = fade(Pf0);",
              "vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);",
              "vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);",
              "float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);",
              "return 2.2 * n_xyz;",
            "}",
            "#endif"
        ].join("\n");

        var keyword = '#endif';
        var originalChunk = THREE.ShaderChunk['lights_phong_fragment'];
        THREE.ShaderChunk['lights_phong_fragment'] = originalChunk.substr(0, originalChunk.indexOf(keyword) + keyword.length) +
        [
            "",
            "float diffuseFactor = 1.0;",
            "float reflectionFactor = 1.0;",
            "vec3 diffuseColor = diffuse;",
            "#ifndef USE_BUMPMAP",
                "if (bumpType == 1) { // generate bumps for plastic",
                    "float tol = 0.01;",
                    "float ntol = 0.0;",
                    "float noise0 = turbulence(vTexCoord3D, bumpDensity);",
                    "float noise1 = turbulence(vec3(vTexCoord3D.x + tol, vTexCoord3D.y, vTexCoord3D.z), bumpDensity);",
                    "float noise2 = turbulence(vec3(vTexCoord3D.x, vTexCoord3D.y + tol, vTexCoord3D.z), bumpDensity);",
                    "float noise3 = turbulence(vec3(vTexCoord3D.x, vTexCoord3D.y, vTexCoord3D.z + tol), bumpDensity);",
                    "vec3 df = vec3(0.1 * (noise1-noise0)/tol, 0.1 * (noise2-noise0)/tol, 0.1 * (noise3-noise0)/tol);",
                    "normal = vec3(normal.x - df.x, normal.y - df.y, normal.z - df.z);",
                    "normal = normalize(normal);",
                "}",
                "else if (bumpType == 2) { //generate bumps for stainless steel",
                "}",
                "else if (bumpType == 3) {", // use charmr's shader to generate bump for stainless steel.
                    "float noise = min(1.0, 0.3 + pnoise(vTexCoord3D * vec3(bumpDensity,bumpDensity,bumpDensity),vec3(300.0))) * bumpAmplitude;",
                     "normal = perturbNormalArbEx(-vViewPosition, normal, vec2(noise, noise));",
                "}",
                "else if (bumpType == 4){",
                    "float noise = cnoise(vec3(vTexCoord3D.x * bumpDensity, vTexCoord3D.y * bumpDensity, vTexCoord3D.z * bumpDensity));",
                    "normal = perturbNormalArbEx(-vViewPosition, normal, vec2(noise * 0.005, noise * 0.005));", 
                "}",
                "else if (bumpType == 5){",
                    "float noise = snoise(vec3(vTexCoord3D.x * bumpDensity, vTexCoord3D.y * bumpDensity, vTexCoord3D.z * bumpDensity)) * bumpAmplitude;",
                    "normal = perturbNormalArbEx(-vViewPosition, normal, vec2(noise * 0.005, noise * 0.005));", 
                "}",
            "#endif",
            ""
        ].join("\n") + originalChunk.substr(originalChunk.indexOf(keyword) + keyword.length);
    },

    _patchGeometryToAddCustomizedNormals : function(){
        THREE.Geometry.prototype.computeCustomizedNormals = function() {
            var v, vl, f, fl, face, vertices;
            if ( this.__tmpVertices === undefined ) {
                this.__tmpVertices = new Array( this.vertices.length );
                vertices = this.__tmpVertices;

                for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
                    vertices[ v ] = new THREE.Vector3();
                    vertices[ v ].normals = [];
                }
                for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
                    face = this.faces[ f ];
                    face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
                }

            } else {
                vertices = this.__tmpVertices;

                for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
                    vertices[ v ].set( 0, 0, 0 );
                    vertices[ v ].normals = [];
                }
            }

            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
                face = this.faces[ f ];
                vertices[ face.a ].add( face.normal );
                vertices[ face.a ].normals.push( face.normal.normalize() );
                vertices[ face.b ].add( face.normal );
                vertices[ face.b ].normals.push( face.normal.normalize() );
                vertices[ face.c ].add( face.normal );
                vertices[ face.c ].normals.push( face.normal.normalize() );

            }

            for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
                vertices[ v ].normalize();
            }

            var computeFaceNormal = function(normal, normals){
                var res = normal.clone();
                var findTheSame = false;
                for(var i = 0, len = normals.length; i<len; ++i){
                    if(!findTheSame && normal.equals(normals[i])){
                        findTheSame = true;
                        continue;
                    }

                    var angle = Math.abs(normal.angleTo(normals[i]));
                    if( (angle < (Math.PI * 15/180) && angle >= 0) || (angle > (Math.PI * 75/180) && angle < (Math.PI * 105/180)) ){
                        res.add(normals[i]);
                    }
                }
                return res;
            };

            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

                face = this.faces[ f ];

                face.vertexNormals[ 0 ].copy( computeFaceNormal(face.normal, vertices[face.a].normals) );
                face.vertexNormals[ 1 ].copy( computeFaceNormal(face.normal, vertices[face.b].normals) );
                face.vertexNormals[ 2 ].copy( computeFaceNormal(face.normal, vertices[face.c].normals) );
            }
        };
    },

    _patchMesh3DToBufferGeometry: function(){
        THREE.BufferGeometryUtils = {};
        THREE.BufferGeometryUtils.createBufferGeometry = function(vertices, triangles){
            var geometry = new THREE.BufferGeometry();
            geometry._vertices = vertices;
            geometry._triangles = triangles;

            var faceCount = triangles.length/3;

            geometry.attributes = {
                index: {
                    itemSize: 1,
                    array: new Uint16Array( faceCount * 3 )
                },
                position: {
                    itemSize: 3,
                    array: new Float32Array( faceCount * 3 * 3 )
                },
                normal: {
                    itemSize: 3,
                    array: new Float32Array( faceCount * 3 * 3 )
                }
            }

            // break geometry into
            // chunks of 21,845 triangles (3 unique vertices per triangle)
            // for indices to fit into 16 bit integer number
            // floor(2^16 / 3) = 21845
            var chunkSize = 21845;
            var indices = geometry.attributes.index.array;
            for ( var i = 0; i < indices.length; i ++ ) {
                indices[ i ] = i % ( 3 * chunkSize );
            }

            var positions = geometry.attributes.position.array;
            var normals = geometry.attributes.normal.array;

            var pA = new THREE.Vector3();
            var pB = new THREE.Vector3();
            var pC = new THREE.Vector3();

            var cb = new THREE.Vector3();
            var ab = new THREE.Vector3();

            var posIdx = 0;
            var idx = 0;
            var x, y, z;
            var pointIdx;
            for ( var i = 0; i < faceCount; i += 1 ) {
                posIdx = i * 3 * 3;
                idx = i * 3;

                pointIdx = triangles[idx];
                x = vertices[pointIdx * 3];
                y = vertices[pointIdx * 3 + 1];
                z = vertices[pointIdx * 3 + 2];
                pA.set( x, y, z );
                positions[ posIdx ]     = x;
                positions[ posIdx + 1 ] = y;
                positions[ posIdx + 2 ] = z;

                pointIdx = triangles[idx + 1 ];
                x = vertices[pointIdx * 3];
                y = vertices[pointIdx * 3 + 1];
                z = vertices[pointIdx * 3 + 2];
                pB.set( x, y, z );
                positions[ posIdx + 3 ] = x;
                positions[ posIdx + 4 ] = y;
                positions[ posIdx + 5 ] = z;

                pointIdx = triangles[idx + 2 ];
                x = vertices[pointIdx * 3];
                y = vertices[pointIdx * 3 + 1];
                z = vertices[pointIdx * 3 + 2];
                pC.set( x, y, z );
                positions[ posIdx + 6 ] = x;
                positions[ posIdx + 7 ] = y;
                positions[ posIdx + 8 ] = z;

                // flat face normals
                cb.subVectors( pC, pB );
                ab.subVectors( pA, pB );
                cb.cross( ab );

                cb.normalize();

                var nx = cb.x;
                var ny = cb.y;
                var nz = cb.z;

                normals[ posIdx ]     = nx;
                normals[ posIdx + 1 ] = ny;
                normals[ posIdx + 2 ] = nz;

                normals[ posIdx + 3 ] = nx;
                normals[ posIdx + 4 ] = ny;
                normals[ posIdx + 5 ] = nz;

                normals[ posIdx + 6 ] = nx;
                normals[ posIdx + 7 ] = ny;
                normals[ posIdx + 8 ] = nz;
            }

            geometry.offsets = [];

            var offsets = faceCount / chunkSize;

            for ( var i = 0; i < offsets; i ++ ) {

              var offset = {
                start: i * chunkSize * 3,
                index: i * chunkSize * 3,
                count: Math.min( faceCount - ( i * chunkSize ), chunkSize ) * 3
              };

              geometry.offsets.push( offset );
            }
            return geometry;
        };

        THREE.BufferGeometryUtils.computeVerticsNormal = function(geometry){
            var positions = geometry._vertices;
            var indices = geometry._triangles;
            var normals = new Float32Array(positions.length);
            var vA, vB, vC, x, y, z;
            var pA = new THREE.Vector3();
            var pB = new THREE.Vector3();
            var pC = new THREE.Vector3();
            var cb = new THREE.Vector3();
            var ab = new THREE.Vector3();
            for (var i = 0, len = indices.length; i < len; i += 3 ) {
                vA = indices[ i ];
                vB = indices[ i + 1 ];
                vC = indices[ i + 2 ];

                x = positions[ vA * 3 ];
                y = positions[ vA * 3 + 1 ];
                z = positions[ vA * 3 + 2 ];
                pA.set( x, y, z );

                x = positions[ vB * 3 ];
                y = positions[ vB * 3 + 1 ];
                z = positions[ vB * 3 + 2 ];
                pB.set( x, y, z );

                x = positions[ vC * 3 ];
                y = positions[ vC * 3 + 1 ];
                z = positions[ vC * 3 + 2 ];
                pC.set( x, y, z );

                cb.subVectors( pC, pB );
                ab.subVectors( pA, pB );
                cb.cross( ab );
                cb.normalize();

                //compute average normal of every triangle
                normals[ vA * 3 ]     += cb.x;
                normals[ vA * 3 + 1 ] += cb.y;
                normals[ vA * 3 + 2 ] += cb.z;

                normals[ vB * 3 ]     += cb.x;
                normals[ vB * 3 + 1 ] += cb.y;
                normals[ vB * 3 + 2 ] += cb.z;

                normals[ vC * 3 ]     += cb.x;
                normals[ vC * 3 + 1 ] += cb.y;
                normals[ vC * 3 + 2 ] += cb.z;
            }

            for ( i = 0, len = indices.length; i < len; i += 3 ) {
                cb.set( normals[ i ], normals[ i + 1 ], normals[ i + 2 ]);
                cb.normalize();
                normals[ i ]     = cb.x;
                normals[ i + 1 ] = cb.y;
                normals[ i + 2 ] = cb.z;
            }

            geometry._normals = normals;
        };

        THREE.BufferGeometryUtils.updateNormals = function(geometry, shadingMode){
            if(shadingMode === 'smooth'){
                if(!geometry._normals){
                    THREE.BufferGeometryUtils.computeVerticsNormal(geometry);
                }

                var normals = geometry.attributes.normal.array;
                var vnormals = geometry._normals;
                var indices = geometry._triangles;
                var idx, idx2;  
                for(var i = 0, len = indices.length; i<len; i = i+3 ){
                    idx = Math.floor( i / 3 ) * 9;
                    idx2 = indices[i];
                    normals[ idx ]     = vnormals[ idx2 * 3 ];
                    normals[ idx + 1 ] = vnormals[ idx2 * 3 + 1 ];
                    normals[ idx + 2 ] = vnormals[ idx2 * 3 + 2 ];

                    idx2 = indices[ i + 1 ];
                    normals[ idx + 3 ] = vnormals[ idx2 * 3 ];
                    normals[ idx + 4 ] = vnormals[ idx2 * 3 + 1 ];
                    normals[ idx + 5 ] = vnormals[ idx2 * 3 + 2 ];

                    idx2 = indices[ i + 2 ];
                    normals[ idx + 6 ] = vnormals[ idx2 * 3 ];
                    normals[ idx + 7 ] = vnormals[ idx2 * 3 + 1 ];
                    normals[ idx + 8 ] = vnormals[ idx2 * 3 + 2 ];
                }

                delete geometry._normals; //release memory
            }
            else { //flat 
                var positions = geometry.attributes.position.array;
                var normals = geometry.attributes.normal.array;

                var pA = new THREE.Vector3();
                var pB = new THREE.Vector3();
                var pC = new THREE.Vector3();

                var cb = new THREE.Vector3();
                var ab = new THREE.Vector3();

                var posIdx = 0;
                var idx = 0;
                var x, y, z;
                var pointIdx;
                for ( var i = 0, len = positions.length/9; i < len; i += 1 ) {
                    posIdx = i * 3 * 3;
                    x = positions[ posIdx ];
                    y = positions[ posIdx + 1 ];
                    z = positions[ posIdx + 2 ];
                    pA.set( x, y, z );

                    x = positions[ posIdx + 3 ];
                    y = positions[ posIdx + 4 ];
                    z = positions[ posIdx + 5 ];
                    pB.set( x, y, z );

                    x = positions[ posIdx + 6 ];
                    y = positions[ posIdx + 7 ];
                    z = positions[ posIdx + 8 ];
                    pC.set( x, y, z );

                    // flat face normals
                    cb.subVectors( pC, pB );
                    ab.subVectors( pA, pB );
                    cb.cross( ab );
                    cb.normalize();

                    var nx = cb.x;
                    var ny = cb.y;
                    var nz = cb.z;

                    normals[ posIdx ]     = nx;
                    normals[ posIdx + 1 ] = ny;
                    normals[ posIdx + 2 ] = nz;

                    normals[ posIdx + 3 ] = nx;
                    normals[ posIdx + 4 ] = ny;
                    normals[ posIdx + 5 ] = nz;

                    normals[ posIdx + 6 ] = nx;
                    normals[ posIdx + 7 ] = ny;
                    normals[ posIdx + 8 ] = nz;
                }
            }

            geometry.attributes.normal.needsUpdate = true;
        };
    },

    _patchImageUtils: function(){
        THREE.ImageUtils.loadCompressedTextureCube = function ( array, mapping, onLoad, onError ) {

            var images = [];
            images.loadCount = 0;

            var texture = new THREE.CompressedTexture();
            texture.image = images;
            if ( mapping !== undefined ) texture.mapping = mapping;

            // no flipping for cube textures
            // (also flipping doesn't work for compressed textures )

            texture.flipY = false;

            // can't generate mipmaps for compressed textures
            // mips must be embedded in DDS files

            texture.generateMipmaps = false;

            var generateCubeFaceCallback = function ( rq, img ) {

                return function () {

                    var buffer = rq.response;
                    var dds = THREE.ImageUtils.parseDDS( buffer, true );

                    img.format = dds.format;

                    img.mipmaps = dds.mipmaps;
                    img.width = dds.width;
                    img.height = dds.height;

                    images.loadCount += 1;

                    if ( images.loadCount === 6 ) {

                        texture.format = dds.format;
                        texture.needsUpdate = true;

                        //The default for Texture is Mip filter, which will fail if there are no mips
                        //And for DDS we do not auto-generate them.
                        if (dds.mipmapCount == 1)
                            texture.minFilter = THREE.LinearFilter;

                        texture.needsUpdate = true;
                        
                        if ( onLoad ) onLoad( texture );

                    }

                }

            }

            // compressed cubemap textures as 6 separate DDS files

            if ( array instanceof Array ) {

                for ( var i = 0, il = array.length; i < il; ++ i ) {

                    var cubeImage = {};
                    images[ i ] = cubeImage;

                    var request = new XMLHttpRequest();

                    request.onload = generateCubeFaceCallback( request, cubeImage );
                    request.onerror = onError;

                    var url = array[ i ];

                    request.open( 'GET', url, true );
                    request.responseType = "arraybuffer";
                    request.send( null );

                }

            // compressed cubemap texture stored in a single DDS file

            } else {

                var url = array;
                var request = new XMLHttpRequest();

                request.onload = function( ) {

                    var buffer = request.response;
                    var dds = THREE.ImageUtils.parseDDS( buffer, true );

                    if ( dds.isCubemap ) {

                        var faces = dds.mipmaps.length / dds.mipmapCount;

                        for ( var f = 0; f < faces; f ++ ) {

                            images[ f ] = { mipmaps : [] };

                            for ( var i = 0; i < dds.mipmapCount; i ++ ) {

                                images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
                                images[ f ].format = dds.format;
                                images[ f ].width = dds.width;
                                images[ f ].height = dds.height;

                            }

                        }

                        texture.format = dds.format;
                        texture.needsUpdate = true;

                        //The default for Texture is Mip filter, which will fail if there are no mips
                        //And for DDS we do not auto-generate them.
                        if (dds.mipmapCount == 1)
                            texture.minFilter = THREE.LinearFilter;

                        texture.needsUpdate = true;

                        if ( onLoad ) onLoad( texture );

                    }

                }

                request.onerror = onError;

                request.open( 'GET', url, true );
                request.responseType = "arraybuffer";
                request.send( null );

            }

            return texture;

        };

        THREE.ImageUtils.loadDDSTexture = function ( url, mapping, onLoad, onError ) {

            var images = [];
            images.loadCount = 0;

            var texture = new THREE.CompressedTexture();
            texture.image = images;
            if ( mapping !== undefined ) texture.mapping = mapping;

            // no flipping for cube textures
            // (also flipping doesn't work for compressed textures )

            texture.flipY = false;

            // can't generate mipmaps for compressed textures
            // mips must be embedded in DDS files

            texture.generateMipmaps = false;

            {
                var request = new XMLHttpRequest();

                request.onload = function( ) {

                    var buffer = request.response;
                    var dds = THREE.ImageUtils.parseDDS( buffer, true );

                    if ( dds.isCubemap ) {

                        var faces = dds.mipmaps.length / dds.mipmapCount;

                        for ( var f = 0; f < faces; f ++ ) {

                            images[ f ] = { mipmaps : [] };

                            for ( var i = 0; i < dds.mipmapCount; i ++ ) {

                                images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
                                images[ f ].format = dds.format;
                                images[ f ].width = dds.width;
                                images[ f ].height = dds.height;

                            }

                        }


                    } else {
                        texture.image.width = dds.width;
                        texture.image.height = dds.height;
                        texture.mipmaps = dds.mipmaps;
                    }

                    texture.format = dds.format;
                    texture.type = dds.type;
                    //The default for Texture is Mip filter, which will fail if there are no mips
                    //And for DDS we do not auto-generate them.
                    if (dds.mipmapCount == 1)
                        texture.minFilter = THREE.LinearFilter;
                    texture.needsUpdate = true;
                    if ( onLoad ) onLoad( texture );

                }

                request.onerror = onError;

                request.open( 'GET', url, true );
                request.responseType = "arraybuffer";
                request.send( null );

            }

            return texture;

        };
    },

    _patchSetFromObject : function(){
        THREE.Box3.prototype.setFromObject = function() {
            // Computes the world-axis-aligned bounding box of an object (including its children),
            // accounting for both the object's, and childrens', world transforms
            var v1 = new THREE.Vector3();
            return function( object ) {
                var scope = this;
                object.updateMatrixWorld( true );
                this.makeEmpty();
                object.traverse( function ( node ) {
                    if ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {
                        var vertices = node.geometry.vertices;
                        var mtx = node.matrixWorld;
                        for ( var i = 0, il = vertices.length; i < il; i++ ) {
                            v1.copy( vertices[ i ] );
                            v1.applyMatrix4( mtx );
                            scope.expandByPoint( v1 );
                        }
                    }
                    else if ( node.geometry !== undefined && node.geometry.attributes !== undefined && node.geometry.attributes.position !== undefined) {
                        var positions = node.geometry._vertices ? node.geometry._vertices : node.geometry.attributes.position.array;
                        var vertices = node.geometry.vertices;
                        var mtx = node.matrixWorld;
                        for ( var i = 0, len = positions.length; i < len; i += 3) {
                            v1.set(positions[i], positions[i + 1], positions[i + 2]);
                            v1.applyMatrix4( mtx );
                            scope.expandByPoint( v1 );
                        }
                    }
                });
                return this;
            };
        }();
    }
};



//prism.js
/** 
Internal / Private data. This is not exported so clients can not find it or use it.
@private
@class prism
@since 2.2.0
**/
var Prism = {};

Prism._prismOpaque = function(diffuseColor, reflectionFactor, roughnessFactor) {
    var vertexShaderString = [
        "precision highp int;",
        "",
        "#define VTX_SHADER",
        "//=========================================================",
        "//         OGSFX Copyright (c) 2013 Autodesk, Inc. ",
        "//=========================================================",
        "",
        "",
        "//----------------",
        "//Global block ",
        "//----------------",
        "",
        "#ifdef PIX_SHADER",
        "",
        "    #extension GL_OES_standard_derivatives : enable",
        "#endif",
        "",
        " precision highp float;",
        "",
        "",
        "//----------------",
        "//OGS Standard Library Block ",
        "#define lerp mix",
        "#define atan2 atan",
        "#ifndef GL_ES",
        "#define texture2D  texture",
        "#define texture1D  texture",
        "#define textureCube texture",
        "#define texture3D  texture",
        "#define texture2DLod textureLod",
        "#define texture1DLod textureLod",
        "#define textureCubeLod textureLod",
        "#define texture3DLod textureLod",
        "#endif",
        "vec4 mul (in vec4 matx[4],in vec4 v)",
        "{",
        "mat4 tmpMtx=mat4(matx[0],matx[1],matx[2],matx[3]);",
        "return tmpMtx*v;",
        "}",
        "vec4 mul (in vec4 v,in vec4 matx[4])",
        "{",
        "vec4 retVal;",
        "retVal.x=dot(matx[0],v);",
        "retVal.y=dot(matx[1],v);",
        "retVal.z=dot(matx[2],v);",
        "retVal.w=dot(matx[3],v);",
        "return retVal;",
        "}",
        "vec3 mul (in vec3 matx[3],in vec3 v)",
        "{",
        "mat3 tmpMtx=mat3(matx[0],matx[1],matx[2]);",
        "return tmpMtx*v;",
        "}",
        "vec3 mul (in vec3 v,in vec3 matx[3])",
        "{",
        "vec3 retVal;",
        "retVal.x=dot(matx[0],v);",
        "retVal.y=dot(matx[1],v);",
        "retVal.z=dot(matx[2],v);",
        "return retVal;",
        "}",
        "vec3 mul (in vec4 matx[4],in vec3 v)",
        "{",
        "return mul(matx,vec4(v,0.0)).xyz;",
        "}",
        "vec3 mul (in vec3 v, in vec4 matx[4])",
        "{",
        "return mul(vec4(v,0.0),matx).xyz;",
        "}",
        "void transpose (in vec4 matx[4], out vec4 matOut[4])",
        "{",
        "matOut[0].x=matx[0].x;",
        "matOut[0].y=matx[1].x;",
        "matOut[0].z=matx[2].x;",
        "matOut[0].w=matx[3].x;",
        "matOut[1].x=matx[0].y;",
        "matOut[1].y=matx[1].y;",
        "matOut[1].z=matx[2].y;",
        "matOut[1].w=matx[3].y;",
        "matOut[2].x=matx[0].z;",
        "matOut[2].y=matx[1].z;",
        "matOut[2].z=matx[2].z;",
        "matOut[2].w=matx[3].z;",
        "matOut[3].x=matx[0].w;",
        "matOut[3].y=matx[1].w;",
        "matOut[3].z=matx[2].w;",
        "matOut[3].w=matx[3].w;",
        "}",
        "void transpose (in vec3 matx[3], out vec3 matOut[3])",
        "{",
        "matOut[0].x=matx[0].x;",
        "matOut[0].y=matx[1].x;",
        "matOut[0].z=matx[2].x;",
        "matOut[1].x=matx[0].y;",
        "matOut[1].y=matx[1].y;",
        "matOut[1].z=matx[2].y;",
        "matOut[2].x=matx[0].z;",
        "matOut[2].y=matx[1].z;",
        "matOut[2].z=matx[2].z;",
        "}",
        "vec4 lit(in float NdotL , in float NdotH , in float m )",
        "{",
        "float spec = (NdotL > 0.0) ? pow(max(0.0, NdotH), m) : 0.0;",
        "return vec4(1.0, max(0.0, NdotL), spec, 1.0);",
        "}",
        "float saturate (in float v)",
        "{",
        "return clamp(v,0.0,1.0);",
        "}",
        "vec3 saturate(in vec3 v)",
        "{",
        "#ifdef GL_ES",
        "return vec3(saturate(v.x),saturate(v.y), saturate(v.z));",
        "#else",
        "return clamp(v,0.0,1.0);",
        "#endif",
        "}",
        "float fmod(float x, float y)",
        "{",
        "return x - y * floor(x/y);",
        "}",
        "vec4 saturate (in vec4 v)",
        "{",
        "#ifdef GL_ES",
        "return vec4(saturate(v.x),saturate(v.y), saturate(v.z),saturate(v.w));",
        "#else",
        "return clamp(v,0.0,1.0);",
        "#endif",
        "}",
        "#ifdef PIX_SHADER",
        "void clip( in float x )",
        "{",
        "if (x < 0.0)",
        "discard;",
        "}",
        "void clip( in vec2 v )",
        "{",
        "bvec2 r=lessThan(v,vec2(0.0,0.0));",
        "if(any(r)) discard;",
        "}",
        "void clip( in vec3 v )",
        "{",
        "bvec3 r=lessThan(v,vec3(0.0,0.0,0.0));",
        "if(any(r)) discard;",
        "}",
        "void clip( in vec4 v )",
        "{",
        "bvec4 r=lessThan(v,vec4(0.0,0.0,0.0,0.0));",
        "if(any(r)) discard;",
        "}",
        "const mat3 InverseM = mat3(6.0014, -2.7008, -1.7996,",
        "-1.3320,  3.1029, -5.7721,",
        "0.3008, -1.0882,  5.6268);",
        "#endif",
        "",
        "//----------------",
        "",
        "//----------------",
        "//Autogenerated uniform code:",
        "//----------------",
        "struct irradiance {vec3 diffuseI;",
        "vec3 specularI;",
        "vec3 L;",
        "float shadowFrac;",
        "};",
        "uniform   mat4 World;",
        "uniform   vec3 viewDirection;",
        "uniform  bool localviewer;",
        "uniform   mat4 WorldIT;",
        "uniform   float DepthPriority;",
        "uniform   vec3 SurfaceDiffuse_value;",
        "uniform   int SurfaceNDF_value;",
        "uniform   float SurfaceRough_value;",
        "uniform   float SurfaceAniso_value;",
        "uniform  bool flag;",
        "uniform   float SurfaceRotation_value;",
        "uniform   float SurfaceReflect_value;",
        "uniform   vec3 SurfaceAlbedo_value;",
        "uniform  samplerCube irradianceLogLuvCube_0_fiu_samp;",
        "uniform   mat4 irradianceLogLuvCube_0_fiu_transform;",
        "uniform  bool irradianceLogLuvCube_0_fiu_isLogLuv;",
        "uniform   vec3 irradianceLogLuvCube_0_fiu_gain;",
        "uniform  samplerCube glossLogLuvCube_samp;",
        "uniform   mat4 glossLogLuvCube_transform;",
        "uniform   float glossLogLuvCube_reflectionCoeff;",
        "uniform  bool glossLogLuvCube_isLogLuv;",
        "uniform   vec3 glossLogLuvCube_gain;",
        "uniform  samplerCube radianceLogLuvCube_samp;",
        "uniform   mat4 radianceLogLuvCube_transform;",
        "uniform   float radianceLogLuvCube_reflectionCoeff;",
        "uniform  bool radianceLogLuvCube_isLogLuv;",
        "uniform   vec3 radianceLogLuvCube_gain;",
        "uniform   float cutout;",
        "uniform   float opacity;",
        "uniform   int alphaTestFunc;",
        "uniform   float alphaTestRef;",
        "",
        "//=============================",
        "//      In attributes",
        "//=============================",
        "//=============================",
        "//      Out attributes",
        "//=============================",
        "varying vec3 io_1188_VwLocal;",
        "varying vec3 io_1191_Nw;",
        "varying vec3 io_1192_Vw;",
         "varying vec3 vWorldPosition;",
        "//======================================",
        "// FX file :MAINFX",
        "// FX line :170",
        "//======================================",
        "// Vertex shader block:testShaderName_VS",
        "",
        "",
        "",
        "vec3 iVwLocal(in vec3 position, in vec3 Ew, in mat4 world, in vec3 viewDir, in bool localViewer )",
        "{",
        " vec4 Pw = ( world * vec4(position,1.0) );",
        " return localViewer ? normalize( Ew - Pw.xyz ) : -viewDir;",
        "}",
        "",
        "",
        "vec3 iNw(in vec3 nm, in mat4 worldITC)",
        "{",
        " return ( worldITC * vec4(nm,0.0) ).xyz;",
        "}",
        "",
        "vec3 iVw( in vec3 position, in vec3 Ew, in mat4 world )",
        "{",
        " vec4 Pw = ( world * vec4(position,1.0) );",
        " return Ew - Pw.xyz;",
        "}",
        "",
        "vec4 iPcPriority(in vec3 pm, in float depthPriority, in mat4 worldViewProjectionC)",
        "{",
        " vec4 P = ( worldViewProjectionC * vec4(pm,1.0) );",
        " P.z -= P.w * 2.0 * depthPriority;",
        " return P;",
        "}",
        "",
        "",
        "",
        " ",
        "void main()",
        " {",
        "",
        " ",
        " io_1188_VwLocal = iVwLocal( position, cameraPosition, World, viewDirection, localviewer );",
        " io_1191_Nw = iNw( normal, WorldIT );",
        " io_1192_Vw = iVw( position, cameraPosition, World );",
        " vec4 pos = modelViewMatrix * vec4(position, 1.0); vWorldPosition = pos.xyz/pos.w;",
        " vec4 mvpPosition = projectionMatrix*(modelViewMatrix*vec4(position,1.0)); mvpPosition.z -= mvpPosition.w * 2.0 * DepthPriority; gl_Position = mvpPosition;",
        " ",
        " }"].join("\n");

    var fragmentShaderString = ["precision highp int;",
      "#define PIX_SHADER",
      "//=========================================================",
      "//         OGSFX Copyright (c) 2013 Autodesk, Inc. ",
      "//=========================================================",
      "",
      "",
      "//----------------",
      "//Global block ",
      "//----------------",
      "",
      "#ifdef PIX_SHADER",
      "",
      "    #extension GL_OES_standard_derivatives : enable",
      "#endif",
      "",
      " precision highp float;",
      "",
      "",
      "//----------------",
      "//OGS Standard Library Block ",
      "#define lerp mix",
      "#define atan2 atan",
      "#ifndef GL_ES",
      "#define texture2D  texture",
      "#define texture1D  texture",
      "#define textureCube texture",
      "#define texture3D  texture",
      "#define texture2DLod textureLod",
      "#define texture1DLod textureLod",
      "#define textureCubeLod textureLod",
      "#define texture3DLod textureLod",
      "#endif",
      "",
      "vec4 iPcPriority(in vec3 pm, in float depthPriority, in mat4 worldViewProjectionC)",
      "{",
      "vec4 P = worldViewProjectionC * vec4(pm,1.0);",
      "P.z -= P.w * 2.0 * depthPriority;",
      "return P;",
      "}",
      "vec4 mul (in vec4 matx[4],in vec4 v)",
      "{",
      "mat4 tmpMtx=mat4(matx[0],matx[1],matx[2],matx[3]);",
      "return tmpMtx*v;",
      "}",
      "vec4 mul (in vec4 v,in vec4 matx[4])",
      "{",
      "vec4 retVal;",
      "retVal.x=dot(matx[0],v);",
      "retVal.y=dot(matx[1],v);",
      "retVal.z=dot(matx[2],v);",
      "retVal.w=dot(matx[3],v);",
      "return retVal;",
      "}",
      "vec3 mul (in vec3 matx[3],in vec3 v)",
      "{",
      "mat3 tmpMtx=mat3(matx[0],matx[1],matx[2]);",
      "return tmpMtx*v;",
      "}",
      "vec3 mul (in vec3 v,in vec3 matx[3])",
      "{",
      "vec3 retVal;",
      "retVal.x=dot(matx[0],v);",
      "retVal.y=dot(matx[1],v);",
      "retVal.z=dot(matx[2],v);",
      "return retVal;",
      "}",
      "vec3 mul (in vec4 matx[4],in vec3 v)",
      "{",
      "return mul(matx,vec4(v,0.0)).xyz;",
      "}",
      "vec3 mul (in vec3 v, in vec4 matx[4])",
      "{",
      "return mul(vec4(v,0.0),matx).xyz;",
      "}",
      "void transpose (in vec4 matx[4], out vec4 matOut[4])",
      "{",
      "matOut[0].x=matx[0].x;",
      "matOut[0].y=matx[1].x;",
      "matOut[0].z=matx[2].x;",
      "matOut[0].w=matx[3].x;",
      "matOut[1].x=matx[0].y;",
      "matOut[1].y=matx[1].y;",
      "matOut[1].z=matx[2].y;",
      "matOut[1].w=matx[3].y;",
      "matOut[2].x=matx[0].z;",
      "matOut[2].y=matx[1].z;",
      "matOut[2].z=matx[2].z;",
      "matOut[2].w=matx[3].z;",
      "matOut[3].x=matx[0].w;",
      "matOut[3].y=matx[1].w;",
      "matOut[3].z=matx[2].w;",
      "matOut[3].w=matx[3].w;",
      "}",
      "void transpose (in vec3 matx[3], out vec3 matOut[3])",
      "{",
      "matOut[0].x=matx[0].x;",
      "matOut[0].y=matx[1].x;",
      "matOut[0].z=matx[2].x;",
      "matOut[1].x=matx[0].y;",
      "matOut[1].y=matx[1].y;",
      "matOut[1].z=matx[2].y;",
      "matOut[2].x=matx[0].z;",
      "matOut[2].y=matx[1].z;",
      "matOut[2].z=matx[2].z;",
      "}",
      "vec4 lit(in float NdotL , in float NdotH , in float m )",
      "{",
      "float spec = (NdotL > 0.0) ? pow(max(0.0, NdotH), m) : 0.0;",
      "return vec4(1.0, max(0.0, NdotL), spec, 1.0);",
      "}",
      "float saturate (in float v)",
      "{",
      "return clamp(v,0.0,1.0);",
      "}",
      "vec3 saturate(in vec3 v)",
      "{",
      "#ifdef GL_ES",
      "return vec3(saturate(v.x),saturate(v.y), saturate(v.z));",
      "#else",
      "return clamp(v,0.0,1.0);",
      "#endif",
      "}",
      "float fmod(float x, float y)",
      "{",
      "return x - y * floor(x/y);",
      "}",
      "vec4 saturate (in vec4 v)",
      "{",
      "#ifdef GL_ES",
      "return vec4(saturate(v.x),saturate(v.y), saturate(v.z),saturate(v.w));",
      "#else",
      "return clamp(v,0.0,1.0);",
      "#endif",
      "}",
      "#ifdef PIX_SHADER",
      "void clip( in float x )",
      "{",
      "if (x < 0.0)",
      "discard;",
      "}",
      "void clip( in vec2 v )",
      "{",
      "bvec2 r=lessThan(v,vec2(0.0,0.0));",
      "if(any(r)) discard;",
      "}",
      "void clip( in vec3 v )",
      "{",
      "bvec3 r=lessThan(v,vec3(0.0,0.0,0.0));",
      "if(any(r)) discard;",
      "}",
      "void clip( in vec4 v )",
      "{",
      "bvec4 r=lessThan(v,vec4(0.0,0.0,0.0,0.0));",
      "if(any(r)) discard;",
      "}",
      "const mat3 InverseM = mat3(6.0014, -2.7008, -1.7996,",
      "-1.3320,  3.1029, -5.7721,",
      "0.3008, -1.0882,  5.6268);",
      "#endif",
      "",
      "//----------------",
      "",
      "//----------------",
      "//Autogenerated uniform code:",
      "//----------------",
      "struct irradiance {vec3 diffuseI;",
      "vec3 specularI;",
      "vec3 L;",
      "float shadowFrac;",
      "};",
      "uniform   mat4 World;",
      "uniform   vec3 viewDirection;",
      "uniform  bool localviewer;",
      "uniform   mat4 WorldIT;",
      "uniform   float DepthPriority;",
      "uniform   vec3 SurfaceDiffuse_value;",
      "uniform   int SurfaceNDF_value;",
      "uniform   float SurfaceRough_value;",
      "uniform   float SurfaceAniso_value;",
      "uniform  bool flag;",
      "uniform   float SurfaceRotation_value;",
      "uniform   float SurfaceReflect_value;",
      "uniform   vec3 SurfaceAlbedo_value;",
      "uniform  samplerCube irradianceLogLuvCube_0_fiu_samp;",
      "uniform   mat4 irradianceLogLuvCube_0_fiu_transform;",
      "uniform  bool irradianceLogLuvCube_0_fiu_isLogLuv;",
      "uniform   vec3 irradianceLogLuvCube_0_fiu_gain;",
      "uniform  samplerCube glossLogLuvCube_samp;",
      "uniform   mat4 glossLogLuvCube_transform;",
      "uniform   float glossLogLuvCube_reflectionCoeff;",
      "uniform  bool glossLogLuvCube_isLogLuv;",
      "uniform   vec3 glossLogLuvCube_gain;",
      "uniform  samplerCube radianceLogLuvCube_samp;",
      "uniform   mat4 radianceLogLuvCube_transform;",
      "uniform   float radianceLogLuvCube_reflectionCoeff;",
      "uniform  bool radianceLogLuvCube_isLogLuv;",
      "uniform   vec3 radianceLogLuvCube_gain;",
      "uniform   float cutout;",
      "uniform   float opacity;",
      "uniform   int alphaTestFunc;",
      "uniform   float alphaTestRef;",
      "",
      "//=============================",
      "//      In attributes",
      "//=============================",
      "varying vec3 io_1188_VwLocal;",
      "varying vec3 io_1191_Nw;",
      "varying vec3 io_1192_Vw;",
      "varying vec3 vWorldPosition;",
      "",
      "//=============================",
      "//      Out attributes",
      "//=============================",
      "varying vec4 ColorOut;",
      "//======================================",
      "// FX file :MAINFX",
      "// FX line :526",
      "//======================================",
      "// Pixel shader block:testShaderName",
      "",
      "",
      "",
      "vec3 PassFloat3( in vec3 value )",
      "{",
      " return value;",
      "}",
      "",
      "vec3 DiffuseLobe(in vec3 diffuseColor)",
      "{",
      " const float PI = 3.141592654;",
      " return diffuseColor / PI;",
      "}",
      "",
      "int PassInt( int value )",
      "{",
      " return value;",
      "}",
      "",
      "float PassFloat( float value )",
      "{",
      " return value;",
      "}",
      "",
      "vec3 RoughnessToAlpha(int ndfType, in float roughness, in float anisotropy)",
      "{",
      " vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);",
      " alpha = alpha * alpha;",
      " float limit = ndfType == 0 ? 0.7 : 1.0;",
      " alpha = clamp(alpha, 0.001, limit);",
      " float alpha2 = max(alpha.x * alpha.x, alpha.y * alpha.y);",
      " return vec3(alpha, alpha2);",
      "}",
      "",
      "irradiance nullLight( )",
      "{",
      " irradiance irrad;",
      " irrad.diffuseI = vec3(0.0, 0.0, 0.0);",
      " irrad.specularI = vec3(0.0, 0.0, 0.0);",
      " irrad.L = vec3(0.0, 0.0, 1.0);",
      " irrad.shadowFrac = 1.0 ;",
      " return irrad;",
      "}",
      "",
      "vec3 VwLocal( in vec3 iVwLocal )",
      "{",
      " return normalize( iVwLocal );",
      "}",
      "",
      "vec3 HVector( in vec3 L, in vec3 V )",
      "{",
      " return normalize( L + V );",
      "}",
      "",
      "vec3 Tw( in vec3 iTw )",
      "{",
      " return normalize( iTw );",
      "}",
      "",
      "vec3 Bw( in vec3 iBw )",
      "{",
      " return normalize( iBw );",
      "}",
      "",
      "vec3 Nw( in vec3 iNw )",
      "{",
      " return normalize( iNw );",
      "}",
      "",
      "vec3 faceForwardCond( in vec3 Nw, in vec3 Vw, in bool flag )",
      "{",
      " return flag ? faceforward(Nw, -Vw, Nw) : Nw;",
      "}",
      "",
      "vec4 shaderGeom2( in vec3 N, in vec3 L, in vec3 V, in vec3 H )",
      "{",
      " float NL = dot(N, L);",
      " float NV = dot(N, V);",
      " float NH = dot(N, H);",
      " float VH = dot(V, H);",
      " return vec4( NL, NV, NH, VH );",
      "}",
      "",
      "vec3 HVector_Local(in vec3 H, in vec3 Tw, in vec3 Bw, in vec4 NL_NV_NH_VH)",
      "{",
      " float Hu = dot(H, Tw);",
      " float Hv = dot(H, Bw);",
      " return vec3(Hu, Hv, NL_NV_NH_VH.z);",
      "}",
      "",
      "vec3 Rotate_Z(in vec3 vec, in float value)",
      "{",
      " float s, c;",
      " s = sin(value);",
      " c = cos(value);",
      " return vec3(vec.x * c - vec.y * s, vec.x * s + vec.y * c, vec.z);",
      "}",
      "",
      "float NDF_GGX(in vec3 alpha, in vec3 normal)",
      "{",
      " const float PI = 3.141592654;",
      " float nx2 = normal.x * normal.x;",
      " float ny2 = normal.y * normal.y;",
      " float nz2 = normal.z * normal.z;",
      " float scale = 1.0 / (alpha.x * alpha.y * PI);",
      " float xyz = nx2 / (alpha.x * alpha.x) + ny2 / (alpha.y * alpha.y) + nz2;",
      " return scale / (xyz * xyz);",
      "}",
      "",
      "float xOfFloat4(in vec4 value)",
      "{",
      " return value.x;",
      "}",
      "",
      "float aSqrd(in vec3 alpha, in float cosTheta)",
      "{",
      " float tan2 = 1.0 / (cosTheta * cosTheta) - 1.0;",
      " return alpha.z * tan2;",
      "}",
      "",
      "float G1_GGX(float aSqrd)",
      "{",
      " return 2.0 / (1.0 + sqrt(1.0 + aSqrd));",
      "}",
      "",
      "float yOfFloat4(in vec4 value)",
      "{",
      " return value.y;",
      "}",
      "",
      "float EvaluateG(float g_NL, float g_NV)",
      "{",
      " return g_NL * g_NV;",
      "}",
      "",
      "vec3 f_to_f3(in float f)",
      "{",
      " return vec3(f, f, f);",
      "}",
      "",
      "float wOfFloat4(in vec4 value)",
      "{",
      " return value.w;",
      "}",
      "",
      "vec3 Fresnel_Schlick(in vec3 f0, in float cosAngle)",
      "{",
      " float x = 1.0 - cosAngle;",
      " float x2 = x * x;",
      " vec3 f = f0 + (1.0 - f0) * (x * x2 * x2);",
      " return f;",
      "}",
      "",
      "vec3 MicrofacetLobe(in float D, in float G, in vec3 F, in vec4 NL_NV_NH_VH)",
      "{",
      " return D * G * F / (4.0 * NL_NV_NH_VH.x * NL_NV_NH_VH.y);",
      "}",
      "",
      "vec3 BRDF_Opaque(in vec3 diffuse, in vec3 specular, in vec3 albedo, in vec3 radiance, in vec4 NL_NV_NH_VH)",
      "{",
      " return radiance * NL_NV_NH_VH.x * (diffuse + specular * albedo);",
      "}",
      "",
      "vec3 SampleCubeNormalLogLuv(samplerCube samp, mat4 transform, vec3 normal, bool isLogLuv)",
      "{",
      "if(isLogLuv){",
      " vec4 vLogLuv = textureCube(samp, (transform * vec4(normal,0.0)).xyz);",
      "float Le = vLogLuv.b * 255.0 + vLogLuv.a;",
      "vec3 Xp_Y_XYZp;",
      "Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);",
      "Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.g;",
      "Xp_Y_XYZp.x = vLogLuv.r * Xp_Y_XYZp.z;",
      "vec3 vRGB = InverseM * Xp_Y_XYZp;",
      "return max(vRGB, vec3(0.0));",
      "}",
      "else{",
      " return textureCube(samp, (transform * vec4(normal,0.0)).xyz).xyz;",
      "}",
      "}",
      "",
      "vec3 adjustGain( in vec3 map, in vec3 gain )",
      "{",
      " return map * gain;",
      "}",
      "",
      "vec3 Vw( in vec3 iVw )",
      "{",
      " return normalize( iVw );",
      "}",
      "",
      "vec3 normalPassThrough( vec3 normal )",
      "{",
      " return normal;",
      "}",
      "",
      "vec3 SampleCubeReflectLogLuv( in samplerCube envCube, in mat4 transform, in float kr, in vec3 V, in vec3 N, in bool isLogLuv )",
      "{",
      " if(isLogLuv){",
      " vec3 reflDir = (2.0 * dot(V, N)) * N - V;",
      " reflDir = (transform * vec4(reflDir,0.0)).xyz;",
      " vec4 vLogLuv = textureCube( envCube, reflDir );",
      "float Le = vLogLuv.b * 255.0 + vLogLuv.a;",
      "vec3 Xp_Y_XYZp;",
      "Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);",
      "Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.g;",
      "Xp_Y_XYZp.x = vLogLuv.r * Xp_Y_XYZp.z;",
      "vec3 vRGB = InverseM * Xp_Y_XYZp;",
      "return kr * max(vRGB, vec3(0.0));",
      "}",
      "else{",
      " vec3 reflDir = (2.0 * dot(V, N)) * N - V;",
      " reflDir = (transform * vec4(reflDir,0.0)).xyz;",
      " return kr * textureCube( envCube, reflDir ).xyz;",
      "}",
      "}",
      "",
      "vec3 blendGlossyAndRadianceCubeEnvironment(float gloss, vec3 glossyEnv, vec3 radianceEnv)",
      "{",
      " return lerp(glossyEnv, radianceEnv, gloss);",
      "}",
      "",
      "float PassConstFloat( float value )",
      "{",
      " return value;",
      "}",
      "",
      "vec3 Fresnel_Rough(vec3 f0, float cosAngle, vec3 alpha)",
      "{",
      " float x = 1.0 - cosAngle;",
      " float x2 = x * x;",
      " float x5 = x * x2 * x2;",
      " float temp = min(0.7, alpha.x) / 0.7;",
      " vec3 maxReflectance = lerp(vec3(1.0,1.0,1.0), f0, vec3(temp,temp,temp));",
      " return f0 + (maxReflectance - f0) * x5;",
      "}",
      "",
        "vec3 Environment_Opaque(in vec3 envDiffColor, in vec3 envIrradiance, in vec3 envSpecular, in vec3 F, in vec3 albedo)",
          "{",
          " vec3 diffuse = (1.0 - F) * envDiffColor * envIrradiance;",
          " vec3 specular = F * albedo * envSpecular;",
          " return diffuse + specular;",
          "}",
      "",
      "vec4 PMCombine(in vec3 brdf, in vec4 NL_NV_NH_VH, in vec3 radianceEnv, float cutout, in float opacity)",
      "{",
      " clip(cutout - 0.01);",
      " return vec4(brdf + radianceEnv, cutout*opacity);",
      "}",
      "",
      "vec4 alphaTest(in vec4 value, in int functionSelected, in float reference)",
      "{",
      " const float EPSILON = 1e-4;",
      " if (functionSelected == 1)",
      " {",
      " discard;",
      " }",
      " else if (functionSelected == 2)",
      " {",
      " clip(reference - EPSILON - value.a);",
      " }",
      " else if (functionSelected == 4)",
      " {",
      " clip(reference + EPSILON - value.a);",
      " }",
      " else if (functionSelected == 5)",
      " {",
      " clip(value.a - reference - EPSILON);",
      " }",
      " else if (functionSelected == 7)",
      " {",
      " clip(value.a - reference + EPSILON);",
      " }",
      " else if (functionSelected == 3)",
      " {",
      " clip(EPSILON - abs(value.a - reference));",
      " }",
      " else if (functionSelected == 6)",
      " {",
      " clip(abs(value.a - reference) - EPSILON);",
      " }",
      " return value;",
      "}",
      "",
      "",
      " ",
     "void main()",
      "{",
      " ",
      " float ANISO_ENV=0.000000;",
      "",
      " ",
      " vec3 v_PassFloat31132 = PassFloat3( SurfaceDiffuse_value );",
      " vec3 v_DiffuseLobe1133 = DiffuseLobe( v_PassFloat31132 );",
      " int v_PassInt1131 = PassInt( SurfaceNDF_value );",
      " float v_PassFloat1129 = PassFloat( SurfaceRough_value );",
      " float v_PassFloat1130 = PassFloat( SurfaceAniso_value );",
      " vec3 v_RoughnessToAlpha1138 = RoughnessToAlpha( v_PassInt1131, v_PassFloat1129, v_PassFloat1130 );",
      " irradiance s_irradiance1123;",
      " s_irradiance1123 = nullLight( );",
      " vec3 v_VwLocal1188 = VwLocal( io_1188_VwLocal );",
      " vec3 v_HVector1124 = HVector( s_irradiance1123.L, v_VwLocal1188 );",
      " vec3 v_Tw1189 = normalize(dFdx(vWorldPosition));// Tw( io_1189_Tw );",
      " vec3 v_Bw1190 = normalize(dFdy(vWorldPosition));//Bw( io_1190_Bw );",
      " vec3 v_Nw1191 = Nw( io_1191_Nw );",
      " vec3 v_faceForwardIntrinsicConditional1125 = faceForwardCond( v_Nw1191, v_VwLocal1188, flag );",
      " vec4 v_shaderGeom1126 = shaderGeom2( v_faceForwardIntrinsicConditional1125, s_irradiance1123.L, v_VwLocal1188, v_HVector1124 );",
      " vec3 v_HVector_Local1136 = HVector_Local( v_HVector1124, v_Tw1189, v_Bw1190, v_shaderGeom1126 );",
      " vec3 v_Rotate_Z1137 = Rotate_Z( v_HVector_Local1136, SurfaceRotation_value );",
      " float v_NDF_GGX1139 = NDF_GGX( v_RoughnessToAlpha1138, v_Rotate_Z1137 );",
      " float v_xOfFloat41140 = xOfFloat4( v_shaderGeom1126 );",
      " float v_aSqrd1141 = aSqrd( v_RoughnessToAlpha1138, v_xOfFloat41140 );",
      " float v_G1_GGX1144 = G1_GGX( v_aSqrd1141 );",
      " float v_yOfFloat41142 = yOfFloat4( v_shaderGeom1126 );",
      " float v_aSqrd1143 = aSqrd( v_RoughnessToAlpha1138, v_yOfFloat41142 );",
      " float v_G1_GGX1145 = G1_GGX( v_aSqrd1143 );",
      " float v_Evaluate_G1146 = EvaluateG( v_G1_GGX1144, v_G1_GGX1145 );",
      " float v_PassFloat1134 = PassFloat( SurfaceReflect_value );",
      " vec3 v_f31135 = f_to_f3( v_PassFloat1134 );",
      " float v_wOfFloat41147 = wOfFloat4( v_shaderGeom1126 );",
      " vec3 v_Fresnel_Schlick1148 = Fresnel_Schlick( v_f31135, v_wOfFloat41147 );",
      " vec3 v_MicrofacetLobe1149 = MicrofacetLobe( v_NDF_GGX1139, v_Evaluate_G1146, v_Fresnel_Schlick1148, v_shaderGeom1126 );",
      " vec3 v_PassFloat31128 = PassFloat3( SurfaceAlbedo_value );",
      " vec3 v_BRDF_Opaque1150 = BRDF_Opaque( v_DiffuseLobe1133, v_MicrofacetLobe1149, v_PassFloat31128, s_irradiance1123.diffuseI, v_shaderGeom1126 );",
      " ",
      " vec3 v_sampleCubeNormalLogLuv1064 = SampleCubeNormalLogLuv( irradianceLogLuvCube_0_fiu_samp, irradianceLogLuvCube_0_fiu_transform, v_faceForwardIntrinsicConditional1125, irradianceLogLuvCube_0_fiu_isLogLuv );",
      " vec3 v_adjustGain1063 = adjustGain( v_sampleCubeNormalLogLuv1064, irradianceLogLuvCube_0_fiu_gain );",
      " float v_PassFloat1184 = PassFloat( SurfaceRough_value );",
      " vec3 v_Vw1192 = Vw( io_1192_Vw );",
      " vec3 v_normalPassThrough1083 = normalPassThrough( v_faceForwardIntrinsicConditional1125 );",
      " vec3 v_sampleCubeReflectLogLuv1082 = SampleCubeReflectLogLuv( glossLogLuvCube_samp, glossLogLuvCube_transform, glossLogLuvCube_reflectionCoeff, v_Vw1192, v_normalPassThrough1083, glossLogLuvCube_isLogLuv );",
      " vec3 v_adjustGain1081 = adjustGain( v_sampleCubeReflectLogLuv1082, glossLogLuvCube_gain );",
      " vec3 v_sampleCubeReflectLogLuv1087 = SampleCubeReflectLogLuv( radianceLogLuvCube_samp, radianceLogLuvCube_transform, radianceLogLuvCube_reflectionCoeff, v_Vw1192, v_normalPassThrough1083, radianceLogLuvCube_isLogLuv );",
      " vec3 v_adjustGain1086 = adjustGain( v_sampleCubeReflectLogLuv1087, radianceLogLuvCube_gain );",
      " vec3 v_blendSingleGlossyRadianceEnv1078 = blendGlossyAndRadianceCubeEnvironment( v_PassFloat1184, v_adjustGain1081, v_adjustGain1086 );",
      " float v_yOfFloat41127 = yOfFloat4( v_shaderGeom1126 );",
      " float v_PassConstFloat1152 = PassConstFloat( ANISO_ENV );",
      " vec3 v_RoughnessToAlpha1153 = RoughnessToAlpha( v_PassInt1131, v_PassFloat1129, v_PassConstFloat1152 );",
      " vec3 v_Fresnel_Rough1154 = Fresnel_Rough( v_f31135, v_yOfFloat41127, v_RoughnessToAlpha1153 );",
      " vec3 v_Environment_Opaque1155 = Environment_Opaque( v_PassFloat31132, v_adjustGain1063, v_blendSingleGlossyRadianceEnv1078, v_Fresnel_Rough1154, v_PassFloat31128 );",
      " vec4 v_PMCombiner1156 = PMCombine( v_BRDF_Opaque1150, v_shaderGeom1126, v_Environment_Opaque1155, cutout, opacity );",
      " vec4 v_alphaTest1157 = alphaTest( v_PMCombiner1156, alphaTestFunc, alphaTestRef );",
      "",
      "",
      "gl_FragColor = v_alphaTest1157;",
      "",
      "",
      "",
      "}"].join("\n");

    var attributesValue = {"bitangent":{"type":"v3","value": null}};
    var uniformsValue = {
        DepthPriority: {"type":"f","value":0},
        SurfaceAlbedo_value: {"type":"v3","value":{"x":1,"y":1,"z":1}},
        SurfaceAniso_value: {type: "f", value: 1},
        SurfaceDiffuse_value: {"type":"v3","value":diffuseColor},
        SurfaceNDF_value: {type: "i", value: 1.0},
        SurfaceReflect_value: {type: "f", value: reflectionFactor},
        SurfaceRotation_value: {type: "f", value: 0},
        SurfaceRough_value: {type: "f", value: roughnessFactor},
        World: {"type":"m4","value":{"elements":{"0":1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
        WorldIT: {"type":"m4","value":{"elements":{"0":1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
        alphaTestFunc: {type: "i", value: 8},
        alphaTestRef: {type: "f", value: 0},
        cutout: {type: "f", value: 1},
        environmentRadiance_0_fiu_gain: {"type":null,"value":{"x":1,"y":1,"z":1}},
        environmentRadiance_0_fiu_samp: {"type":null},
        environmentRadiance_0_fiu_transform: {"type":null,"value":{"elements":{"0":-1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
        environmentRadiance_1_fiu_gain: {"type":null,"value":{"x":1,"y":1,"z":1}},
        environmentRadiance_1_fiu_samp: {"type":null},
        environmentRadiance_1_fiu_transform: {"type":null,"value":{"elements":{"0":1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
        flag: {type: "i", value: false},
        glossLogLuvCube_cube: {type: undefined, value: null},
        glossLogLuvCube_gain: {"type":"v3","value":{"x":"1.000000","y":"1.000000","z":"1.000000"}},
        glossLogLuvCube_isLogLuv: {type: "i", value: true},
        glossLogLuvCube_reflectionCoeff: {type: "f", value: "1.000000"},
        glossLogLuvCube_samp: {type:"t", value: this.irradianceMap},
        glossLogLuvCube_transform: {"type":"m4","value":{"elements":{"0":-1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
        irradianceLogLuvCube_0_fiu_cube:  {type: undefined, value: null},
        irradianceLogLuvCube_0_fiu_gain: {"type":"v3","value":{"x":1,"y":1,"z":1}},
        irradianceLogLuvCube_0_fiu_isLogLuv:  {type: "i", value: true},
        irradianceLogLuvCube_0_fiu_samp: {type:"t", value: this.irradianceMap},
        irradianceLogLuvCube_0_fiu_transform: {"type":"m4","value":{"elements":{"0":-1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
        localviewer: {type: "i", value: false},
        opacity: {type:"f", value: 1.0},
        radianceLogLuvCube_cube: {type: undefined, value: null},
        radianceLogLuvCube_gain: {"type":"v3","value":{"x":"1.000000","y":"1.000000","z":"1.000000"}},
        radianceLogLuvCube_isLogLuv: {type: "i", value: true},
        radianceLogLuvCube_reflectionCoeff: {type: "f", value: "1.000000"},
        radianceLogLuvCube_samp: {type:"t", value: this.envMap},
        radianceLogLuvCube_transform: {"type":"m4","value":{"elements":{"0":-1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
        viewDirection: {"type":"v3","value":{"x":1,"y":1,"z":1}}
    };
    
    var uniform;
    for (var u in uniformsValue) {
        uniform = uniformsValue[u];
        if ('m4' === uniform.type) {
            var mat4 = new THREE.Matrix4();
            if (uniform.value != null) {
                mat4.copy(uniform.value);
            }
            uniform.value = mat4;
        }
    }
   
    var res = new THREE.ShaderMaterial({
        uniforms: uniformsValue,
        attributes: attributesValue,
        vertexShader: vertexShaderString,
        fragmentShader: fragmentShaderString
    });
    res.defaultAttributeValues = null;
    return res;
};
    
Prism._prismMetal = function(reflectionFactor, roughnessFactor) {
    var vertexShaderString = "precision highp int;\n\n#define VTX_SHADER\n//=========================================================\n//         OGSFX Copyright (c) 2013 Autodesk, Inc. \n//=========================================================\n\n\n//----------------\n//Global block \n//----------------\n\n#ifdef PIX_SHADER\n\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\n\n precision highp float;\n\n\n//----------------\n//OGS Standard Library Block \n//----------------\n#define lerp mix\n#define atan2 atan\n#ifndef GL_ES\n#define texture2D\ttexture\n#define texture1D\ttexture\n#define textureCube texture\n#define texture3D\ttexture\n#define texture2DLod textureLod\n#define texture1DLod textureLod\n#define textureCubeLod textureLod\n#define texture3DLod textureLod\n#endif\n#define const\nvec4 mul (in vec4 matx[4],in vec4 v)\n{\nmat4 tmpMtx=mat4(matx[0],matx[1],matx[2],matx[3]);\nreturn tmpMtx*v;\n}\nvec4 mul (in mat4 matx,in vec4 v)\n{\nreturn matx*v;\n}\nvec4 mul (in vec4 v,in vec4 matx[4])\n{\nvec4 retVal;\nretVal.x=dot(matx[0],v);\nretVal.y=dot(matx[1],v);\nretVal.z=dot(matx[2],v);\nretVal.w=dot(matx[3],v);\nreturn retVal;\n}\nvec4 mul (in vec4 v,in mat4 matx)\n{\nreturn v*matx;\n}\nvec3 mul (in vec3 matx[3],in vec3 v)\n{\nmat3 tmpMtx=mat3(matx[0],matx[1],matx[2]);\nreturn tmpMtx*v;\n}\nvec3 mul (in mat3 matx,in vec3 v)\n{\nreturn matx*v;\n}\nvec3 mul (in vec3 v,in vec3 matx[3])\n{\nvec3 retVal;\nretVal.x=dot(matx[0],v);\nretVal.y=dot(matx[1],v);\nretVal.z=dot(matx[2],v);\nreturn retVal;\n}\nvec3 mul (in vec3 v,in mat3 matx)\n{\nreturn v*matx;\n}\nvec3 mul (in vec4 matx[4],in vec3 v)\n{\nreturn mul(matx,vec4(v,0.0)).xyz;\n}\nvec3 mul (in vec3 v, in vec4 matx[4])\n{\nreturn mul(vec4(v,0.0),matx).xyz;\n}\nvoid transpose (in vec4 matx[4], out vec4 matOut[4])\n{\nmatOut[0].x=matx[0].x;\nmatOut[0].y=matx[1].x;\nmatOut[0].z=matx[2].x;\nmatOut[0].w=matx[3].x;\nmatOut[1].x=matx[0].y;\nmatOut[1].y=matx[1].y;\nmatOut[1].z=matx[2].y;\nmatOut[1].w=matx[3].y;\nmatOut[2].x=matx[0].z;\nmatOut[2].y=matx[1].z;\nmatOut[2].z=matx[2].z;\nmatOut[2].w=matx[3].z;\nmatOut[3].x=matx[0].w;\nmatOut[3].y=matx[1].w;\nmatOut[3].z=matx[2].w;\nmatOut[3].w=matx[3].w;\n}\nvoid transpose (in vec3 matx[3], out vec3 matOut[3])\n{\nmatOut[0].x=matx[0].x;\nmatOut[0].y=matx[1].x;\nmatOut[0].z=matx[2].x;\nmatOut[1].x=matx[0].y;\nmatOut[1].y=matx[1].y;\nmatOut[1].z=matx[2].y;\nmatOut[2].x=matx[0].z;\nmatOut[2].y=matx[1].z;\nmatOut[2].z=matx[2].z;\n}\nvec4 lit(in float NdotL , in float NdotH , in float m )\n{\nfloat spec = (NdotL > 0.0) ? pow(max(0.0, NdotH), m) : 0.0;\nreturn vec4(1.0, max(0.0, NdotL), spec, 1.0);\n}\nfloat saturate (in float v)\n{\nreturn clamp(v,0.0,1.0);\n}\nvec3 saturate(in vec3 v)\n{\n#ifdef GL_ES\nreturn vec3(saturate(v.x),saturate(v.y), saturate(v.z));\n#else\nreturn clamp(v,0.0,1.0);\n#endif\n}\nfloat fmod(float x, float y)\n{\nreturn x - y * floor(x/y);\n}\nvec4 saturate (in vec4 v)\n{\n#ifdef GL_ES\nreturn vec4(saturate(v.x),saturate(v.y), saturate(v.z),saturate(v.w));\n#else\nreturn clamp(v,0.0,1.0);\n#endif\n}\n#ifdef PIX_SHADER\nvoid clip( in float x )\n{\nif (x < 0.0)\ndiscard;\n}\nvoid clip( in vec2 v )\n{\nbvec2 r=lessThan(v,vec2(0.0,0.0));\nif(any(r)) discard;\n}\nvoid clip( in vec3 v )\n{\nbvec3 r=lessThan(v,vec3(0.0,0.0,0.0));\nif(any(r)) discard;\n}\nvoid clip( in vec4 v )\n{\nbvec4 r=lessThan(v,vec4(0.0,0.0,0.0,0.0));\nif(any(r)) discard;\n}\nconst mat3 InverseM = mat3(6.0014, -2.7008, -1.7996,\n-1.3320,  3.1029, -5.7721,\n0.3008, -1.0882,  5.6268);\n#endif\n\n//----------------\n\n//----------------------------------\n//Autogenerated structure code:\n//----------------------------------\nstruct irradiance {\nvec3 diffuseI;\nvec3 specularI;\nvec3 L;\nfloat shadowFrac;\n};\n\n//----------------------------------\n//Autogenerated uniform code:\n//----------------------------------\nuniform   float gPointSize;\nuniform   mat4 World;\nuniform   vec3 viewDirection;\nuniform  bool localviewer;\nuniform   mat4 WorldIT;\nuniform   float DepthPriority;\nuniform   int SurfaceNDF_value;\nuniform   float SurfaceRough_value;\nuniform   float SurfaceAniso_value;\nuniform  bool flag;\nuniform   float SurfaceRotation_value;\nuniform   vec3 SurfaceReflect_value;\nuniform   vec3 SurfaceAlbedo_value;\nuniform  samplerCube glossLogLuvCube_samp;\nuniform   mat4 glossLogLuvCube_transform;\nuniform   float glossLogLuvCube_reflectionCoeff;\nuniform  bool glossLogLuvCube_isLogLuv;\nuniform   vec3 glossLogLuvCube_gain;\nuniform  samplerCube radianceLogLuvCube_samp;\nuniform   mat4 radianceLogLuvCube_transform;\nuniform   float radianceLogLuvCube_reflectionCoeff;\nuniform  bool radianceLogLuvCube_isLogLuv;\nuniform   vec3 radianceLogLuvCube_gain;\nuniform   float cutout;\nuniform   float opacity;\nuniform   int alphaTestFunc;\nuniform   float alphaTestRef;\n\n//=============================\n//      Vertex In attributes\n//=============================\n//=============================\n//      Vertex Out attributes\n//=============================\nvarying vec3 io_1157_VwLocal;\nvarying vec3 vWorldPosition;\nvarying vec3 io_1160_Nw;\nvarying vec3 io_1161_Vw;\n//======================================\n// FX file :MAINFX\n// FX line :161\n//======================================\n// Vertex shader block:testShaderName_VS\n\n\n\nvec3 iVwLocal(in vec3 position, in vec3 Ew, in mat4 world, in vec3 viewDir, in bool localViewer )\n{\n vec4 Pw = ( world * vec4(position,1.0) );\n return localViewer ? normalize( Ew - Pw.xyz ) : -viewDir;\n}\n\nvec3 iTw( in vec4 tangent, in mat4 world )\n{\n return ( world * tangent ).xyz;\n}\n\nvec3 iBw( in vec3 bitangent, in mat4 world )\n{\n return ( world * vec4(bitangent,0.0) ).xyz;\n}\n\nvec3 iNw(in vec3 nm, in mat4 worldITC)\n{\n return ( worldITC * vec4(nm,0.0) ).xyz;\n}\n\nvec3 iVw( in vec3 position, in vec3 Ew, in mat4 world )\n{\n vec4 Pw = ( world * vec4(position,1.0) );\n return Ew - Pw.xyz;\n}\n\nvec4 iPcPriority(in vec3 pm, in float depthPriority, in mat4 worldViewProjectionC)\n{\n vec4 P = ( worldViewProjectionC * vec4(pm,1.0) );\n P.z -= P.w * 2.0 * depthPriority;\n return P;\n}\n\n\n\n \nvoid main()\n {\n\n \n io_1157_VwLocal = iVwLocal( position, cameraPosition, World, viewDirection, localviewer );\n io_1160_Nw = iNw( normal, WorldIT );\n io_1161_Vw = iVw( position, cameraPosition, World );\n gl_PointSize=gPointSize;\nvec4 mvpPosition = projectionMatrix*(modelViewMatrix*vec4(position,1.0)); mvpPosition.z -= mvpPosition.w * 2.0 * DepthPriority; gl_Position = mvpPosition;vec4 pos = modelViewMatrix * vec4(position, 1.0); vWorldPosition = pos.xyz/pos.w;\n \n }\n\n";
    var fragmentShaderString  = "precision highp int;\n\n#define PIX_SHADER\n//=========================================================\n//         OGSFX Copyright (c) 2013 Autodesk, Inc. \n//=========================================================\n\n\n//----------------\n//Global block \n//----------------\n\n#ifdef PIX_SHADER\n\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\n\n precision highp float;\n\n\n//----------------\n//OGS Standard Library Block \n//----------------\n#define lerp mix\n#define atan2 atan\n#ifndef GL_ES\n#define texture2D\ttexture\n#define texture1D\ttexture\n#define textureCube texture\n#define texture3D\ttexture\n#define texture2DLod textureLod\n#define texture1DLod textureLod\n#define textureCubeLod textureLod\n#define texture3DLod textureLod\n#endif\n#define const\n\nvec4 iPcPriority(in vec3 pm, in float depthPriority, in mat4 worldViewProjectionC)\n{\nvec4 P = worldViewProjectionC * vec4(pm,1.0);\nP.z -= P.w * 2.0 * depthPriority;\nreturn P;\n}\nvec4 mul (in vec4 matx[4],in vec4 v)\n{\nmat4 tmpMtx=mat4(matx[0],matx[1],matx[2],matx[3]);\nreturn tmpMtx*v;\n}\nvec4 mul (in mat4 matx,in vec4 v)\n{\nreturn matx*v;\n}\nvec4 mul (in vec4 v,in vec4 matx[4])\n{\nvec4 retVal;\nretVal.x=dot(matx[0],v);\nretVal.y=dot(matx[1],v);\nretVal.z=dot(matx[2],v);\nretVal.w=dot(matx[3],v);\nreturn retVal;\n}\nvec4 mul (in vec4 v,in mat4 matx)\n{\nreturn v*matx;\n}\nvec3 mul (in vec3 matx[3],in vec3 v)\n{\nmat3 tmpMtx=mat3(matx[0],matx[1],matx[2]);\nreturn tmpMtx*v;\n}\nvec3 mul (in mat3 matx,in vec3 v)\n{\nreturn matx*v;\n}\nvec3 mul (in vec3 v,in vec3 matx[3])\n{\nvec3 retVal;\nretVal.x=dot(matx[0],v);\nretVal.y=dot(matx[1],v);\nretVal.z=dot(matx[2],v);\nreturn retVal;\n}\nvec3 mul (in vec3 v,in mat3 matx)\n{\nreturn v*matx;\n}\nvec3 mul (in vec4 matx[4],in vec3 v)\n{\nreturn mul(matx,vec4(v,0.0)).xyz;\n}\nvec3 mul (in vec3 v, in vec4 matx[4])\n{\nreturn mul(vec4(v,0.0),matx).xyz;\n}\nvoid transpose (in vec4 matx[4], out vec4 matOut[4])\n{\nmatOut[0].x=matx[0].x;\nmatOut[0].y=matx[1].x;\nmatOut[0].z=matx[2].x;\nmatOut[0].w=matx[3].x;\nmatOut[1].x=matx[0].y;\nmatOut[1].y=matx[1].y;\nmatOut[1].z=matx[2].y;\nmatOut[1].w=matx[3].y;\nmatOut[2].x=matx[0].z;\nmatOut[2].y=matx[1].z;\nmatOut[2].z=matx[2].z;\nmatOut[2].w=matx[3].z;\nmatOut[3].x=matx[0].w;\nmatOut[3].y=matx[1].w;\nmatOut[3].z=matx[2].w;\nmatOut[3].w=matx[3].w;\n}\nvoid transpose (in vec3 matx[3], out vec3 matOut[3])\n{\nmatOut[0].x=matx[0].x;\nmatOut[0].y=matx[1].x;\nmatOut[0].z=matx[2].x;\nmatOut[1].x=matx[0].y;\nmatOut[1].y=matx[1].y;\nmatOut[1].z=matx[2].y;\nmatOut[2].x=matx[0].z;\nmatOut[2].y=matx[1].z;\nmatOut[2].z=matx[2].z;\n}\nvec4 lit(in float NdotL , in float NdotH , in float m )\n{\nfloat spec = (NdotL > 0.0) ? pow(max(0.0, NdotH), m) : 0.0;\nreturn vec4(1.0, max(0.0, NdotL), spec, 1.0);\n}\nfloat saturate (in float v)\n{\nreturn clamp(v,0.0,1.0);\n}\nvec3 saturate(in vec3 v)\n{\n#ifdef GL_ES\nreturn vec3(saturate(v.x),saturate(v.y), saturate(v.z));\n#else\nreturn clamp(v,0.0,1.0);\n#endif\n}\nfloat fmod(float x, float y)\n{\nreturn x - y * floor(x/y);\n}\nvec4 saturate (in vec4 v)\n{\n#ifdef GL_ES\nreturn vec4(saturate(v.x),saturate(v.y), saturate(v.z),saturate(v.w));\n#else\nreturn clamp(v,0.0,1.0);\n#endif\n}\n#ifdef PIX_SHADER\nvoid clip( in float x )\n{\nif (x < 0.0)\ndiscard;\n}\nvoid clip( in vec2 v )\n{\nbvec2 r=lessThan(v,vec2(0.0,0.0));\nif(any(r)) discard;\n}\nvoid clip( in vec3 v )\n{\nbvec3 r=lessThan(v,vec3(0.0,0.0,0.0));\nif(any(r)) discard;\n}\nvoid clip( in vec4 v )\n{\nbvec4 r=lessThan(v,vec4(0.0,0.0,0.0,0.0));\nif(any(r)) discard;\n}\nconst mat3 InverseM = mat3(6.0014, -2.7008, -1.7996,\n-1.3320,  3.1029, -5.7721,\n0.3008, -1.0882,  5.6268);\n#endif\n\n//----------------\n\n//----------------------------------\n//Autogenerated structure code:\n//----------------------------------\nstruct irradiance {\nvec3 diffuseI;\nvec3 specularI;\nvec3 L;\nfloat shadowFrac;\n};\n\n//----------------------------------\n//Autogenerated uniform code:\n//----------------------------------\nuniform   float gPointSize;\nuniform   mat4 World;\nuniform   vec3 viewDirection;\nuniform  bool localviewer;\nuniform   mat4 WorldIT;\nuniform   float DepthPriority;\nuniform   int SurfaceNDF_value;\nuniform   float SurfaceRough_value;\nuniform   float SurfaceAniso_value;\nuniform  bool flag;\nuniform   float SurfaceRotation_value;\nuniform   vec3 SurfaceReflect_value;\nuniform   vec3 SurfaceAlbedo_value;\nuniform  samplerCube glossLogLuvCube_samp;\nuniform   mat4 glossLogLuvCube_transform;\nuniform   float glossLogLuvCube_reflectionCoeff;\nuniform  bool glossLogLuvCube_isLogLuv;\nuniform   vec3 glossLogLuvCube_gain;\nuniform  samplerCube radianceLogLuvCube_samp;\nuniform   mat4 radianceLogLuvCube_transform;\nuniform   float radianceLogLuvCube_reflectionCoeff;\nuniform  bool radianceLogLuvCube_isLogLuv;\nuniform   vec3 radianceLogLuvCube_gain;\nuniform   float cutout;\nuniform   float opacity;\nuniform   int alphaTestFunc;\nuniform   float alphaTestRef;\n\n//=============================\n//      Pixel In attributes\n//=============================\nvarying vec3 io_1157_VwLocal;\nvarying vec3 vWorldPosition;\nvarying vec3 io_1160_Nw;\nvarying vec3 io_1161_Vw;\n\n//=============================\n//      Pixel Out attributes\n//=============================\nvarying vec4 ColorOut;\n//======================================\n// FX file :MAINFX\n// FX line :481\n//======================================\n// Pixel shader block:testShaderName\n\n\n\nint PassInt( int value )\n{\n return value;\n}\n\nfloat PassFloat( float value )\n{\n return value;\n}\n\nvec3 RoughnessToAlpha(int ndfType, in float roughness, in float anisotropy)\n{\n vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);\n alpha = alpha * alpha;\n float limit = ndfType == 0 ? 0.7 : 1.0;\n alpha = clamp(alpha, 0.001, limit);\n float alpha2 = max(alpha.x * alpha.x, alpha.y * alpha.y);\n return vec3(alpha, alpha2);\n}\n\nirradiance nullLight( )\n{\n irradiance irrad;\n irrad.diffuseI = vec3(0.0, 0.0, 0.0);\n irrad.specularI = vec3(0.0, 0.0, 0.0);\n irrad.L = vec3(0.0, 0.0, 1.0);\n irrad.shadowFrac = 1.0 ;\n return irrad;\n}\n\nvec3 VwLocal( in vec3 iVwLocal )\n{\n return normalize( iVwLocal );\n}\n\nvec3 HVector( in vec3 L, in vec3 V )\n{\n return normalize( L + V );\n}\n\nvec3 Tw( in vec3 iTw )\n{\n return normalize( iTw );\n}\n\nvec3 Bw( in vec3 iBw )\n{\n return normalize( iBw );\n}\n\nvec3 Nw( in vec3 iNw )\n{\n return normalize( iNw );\n}\n\nvec3 faceForwardCond( in vec3 Nw, in vec3 Vw, in bool flag )\n{\n return flag ? faceforward(Nw, -Vw, Nw) : Nw;\n}\n\nvec4 shaderGeom2( vec3 N, vec3 L, vec3 V, vec3 H )\n{\n float NL = dot(N, L);\n float NV = dot(N, V);\n float NH = dot(N, H);\n float VH = dot(V, H);\n return vec4( NL, NV, NH, VH );\n}\n\nvec3 HVector_Local(in vec3 H, in vec3 Tw, in vec3 Bw, in vec4 NL_NV_NH_VH)\n{\n float Hu = dot(H, Tw);\n float Hv = dot(H, Bw);\n return vec3(Hu, Hv, NL_NV_NH_VH.z);\n}\n\nvec3 Rotate_Z(in vec3 vec, in float value)\n{\n float s, c;\n s = sin(value);\n c = cos(value);\n return vec3(vec.x * c - vec.y * s, vec.x * s + vec.y * c, vec.z);\n}\n\nfloat NDF_GGX(in vec3 alpha, in vec3 normal)\n{\n const float PI = 3.141592654;\n float nx2 = normal.x * normal.x;\n float ny2 = normal.y * normal.y;\n float nz2 = normal.z * normal.z;\n float scale = 1.0 / (alpha.x * alpha.y * PI);\n float xyz = nx2 / (alpha.x * alpha.x) + ny2 / (alpha.y * alpha.y) + nz2;\n return scale / (xyz * xyz);\n}\n\nfloat xOfFloat4(in vec4 value)\n{\n return value.x;\n}\n\nfloat aSqrd(in vec3 alpha, in float cosTheta)\n{\n float tan2 = 1.0 / (cosTheta * cosTheta) - 1.0;\n return alpha.z * tan2;\n}\n\nfloat G1_GGX(float aSqrd)\n{\n return 2.0 / (1.0 + sqrt(1.0 + aSqrd));\n}\n\nfloat yOfFloat4(in vec4 value)\n{\n return value.y;\n}\n\nfloat EvaluateG(float g_NL, float g_NV)\n{\n return g_NL * g_NV;\n}\n\nvec3 PassFloat3( in vec3 value )\n{\n return value;\n}\n\nfloat wOfFloat4(in vec4 value)\n{\n return value.w;\n}\n\nvec3 Fresnel_Schlick(in vec3 f0, in float cosAngle)\n{\n float x = 1.0 - cosAngle;\n float x2 = x * x;\n vec3 f = f0 + (1.0 - f0) * (x * x2 * x2);\n return f;\n}\n\nvec3 MicrofacetLobe(in float D, in float G, in vec3 F, in vec4 NL_NV_NH_VH)\n{\n return D * G * F / (4.0 * NL_NV_NH_VH.x * NL_NV_NH_VH.y);\n}\n\nvec3 BRDF_Metal(in vec3 specular, in vec3 albedo, in vec3 radiance, in vec4 NL_NV_NH_VH)\n{\n if (NL_NV_NH_VH.x <= 0.0 || NL_NV_NH_VH.y <= 0.0)\n return vec3(0.0, 0.0, 0.0);\n return radiance * NL_NV_NH_VH.x * specular * albedo;\n}\n\nvec3 Vw( in vec3 iVw )\n{\n return normalize( iVw );\n}\n\nvec3 normalPassThrough( vec3 normal )\n{\n return normal;\n}\n\nvec3 SampleCubeReflectLogLuv( in samplerCube envCube, in mat4 transform, in float kr, in vec3 V, in vec3 N, in bool isLogLuv )\n{\n if(isLogLuv){\n vec3 reflDir = (2.0 * dot(V, N)) * N - V;\n reflDir = (transform * vec4(reflDir,0.0)).xyz;\n vec4 vLogLuv = textureCube( envCube, reflDir );\nfloat Le = vLogLuv.b * 255.0 + vLogLuv.a;\nvec3 Xp_Y_XYZp;\nXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\nXp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.g;\nXp_Y_XYZp.x = vLogLuv.r * Xp_Y_XYZp.z;\nvec3 vRGB = InverseM * Xp_Y_XYZp;\nreturn kr * max(vRGB, vec3(0.0));\n}\nelse{\n vec3 reflDir = (2.0 * dot(V, N)) * N - V;\n reflDir = (transform * vec4(reflDir,0.0)).xyz;\n return kr * textureCube( envCube, reflDir ).xyz;\n}\n}\n\nvec3 adjustGain( in vec3 map, in vec3 gain )\n{\n return map * gain;\n}\n\nvec3 blendGlossyAndRadianceCubeEnvironment(float gloss, vec3 glossyEnv, vec3 radianceEnv)\n{\n return lerp(glossyEnv, radianceEnv, clamp((1.0-gloss)/0.8,0.0,1.0));\n}\n\nfloat PassConstFloat( float value )\n{\n return value;\n}\n\nvec3 Fresnel_Rough(vec3 f0, float cosAngle, vec3 alpha)\n{\n float x = 1.0 - cosAngle;\n float x2 = x * x;\n float x5 = x * x2 * x2;\n float temp = min(0.7, alpha.x) / 0.7;\n vec3 maxReflectance = lerp(vec3(1.0,1.0,1.0), f0, vec3(temp,temp,temp));\n return f0 + (maxReflectance - f0) * x5;\n}\n\nvec3 Environment_Metal(in vec3 envSpecular, in vec3 F, in vec3 albedo)\n{\n vec3 specular = F * albedo * envSpecular;\n return specular;\n}\n\nvec4 PMCombine(in vec3 brdf, in vec3 radianceEnv, float cutout, in float opacity)\n{\n clip(cutout - 0.01);\n return vec4(brdf + radianceEnv, cutout*opacity);\n}\n\nvec4 alphaTest(in vec4 value, in int functionSelected, in float reference)\n{\n const float EPSILON = 1e-4;\n if (functionSelected == 1)\n {\n discard;\n }\n else if (functionSelected == 2)\n {\n clip(reference - EPSILON - value.a);\n }\n else if (functionSelected == 4)\n {\n clip(reference + EPSILON - value.a);\n }\n else if (functionSelected == 5)\n {\n clip(value.a - reference - EPSILON);\n }\n else if (functionSelected == 7)\n {\n clip(value.a - reference + EPSILON);\n }\n else if (functionSelected == 3)\n {\n clip(EPSILON - abs(value.a - reference));\n }\n else if (functionSelected == 6)\n {\n clip(abs(value.a - reference) - EPSILON);\n }\n return value;\n}\n\n\n \nvoid main()\n{\n \n float ANISO_ENV=0.000000;\n\n \n int v_PassInt1103 = PassInt( SurfaceNDF_value );\n float v_PassFloat1101 = PassFloat( SurfaceRough_value );\n float v_PassFloat1102 = PassFloat( SurfaceAniso_value );\n vec3 v_RoughnessToAlpha1107 = RoughnessToAlpha( v_PassInt1103, v_PassFloat1101, v_PassFloat1102 );\n irradiance s_irradiance1095;\n s_irradiance1095 = nullLight( );\n vec3 v_VwLocal1157 = VwLocal( io_1157_VwLocal );\n vec3 v_HVector1096 = HVector( s_irradiance1095.L, v_VwLocal1157 );\n vec3 v_Tw1158 = normalize(dFdx(vWorldPosition));\n vec3 v_Bw1159 = normalize(dFdy(vWorldPosition));\n vec3 v_Nw1160 = Nw( io_1160_Nw );\n vec3 v_faceForwardIntrinsicConditional1097 = faceForwardCond( v_Nw1160, v_VwLocal1157, flag );\n vec4 v_shaderGeom1098 = shaderGeom2( v_faceForwardIntrinsicConditional1097, s_irradiance1095.L, v_VwLocal1157, v_HVector1096 );\n vec3 v_HVector_Local1105 = HVector_Local( v_HVector1096, v_Tw1158, v_Bw1159, v_shaderGeom1098 );\n vec3 v_Rotate_Z1106 = Rotate_Z( v_HVector_Local1105, SurfaceRotation_value );\n float v_NDF_GGX1108 = NDF_GGX( v_RoughnessToAlpha1107, v_Rotate_Z1106 );\n float v_xOfFloat41109 = xOfFloat4( v_shaderGeom1098 );\n float v_aSqrd1110 = aSqrd( v_RoughnessToAlpha1107, v_xOfFloat41109 );\n float v_G1_GGX1113 = G1_GGX( v_aSqrd1110 );\n float v_yOfFloat41111 = yOfFloat4( v_shaderGeom1098 );\n float v_aSqrd1112 = aSqrd( v_RoughnessToAlpha1107, v_yOfFloat41111 );\n float v_G1_GGX1114 = G1_GGX( v_aSqrd1112 );\n float v_Evaluate_G1115 = EvaluateG( v_G1_GGX1113, v_G1_GGX1114 );\n vec3 v_PassFloat31104 = PassFloat3( SurfaceReflect_value );\n float v_wOfFloat41116 = wOfFloat4( v_shaderGeom1098 );\n vec3 v_Fresnel_Schlick1117 = Fresnel_Schlick( v_PassFloat31104, v_wOfFloat41116 );\n vec3 v_MicrofacetLobe1118 = MicrofacetLobe( v_NDF_GGX1108, v_Evaluate_G1115, v_Fresnel_Schlick1117, v_shaderGeom1098 );\n vec3 v_PassFloat31100 = PassFloat3( SurfaceAlbedo_value );\n vec3 v_BRDF_Matel1119 = BRDF_Metal( v_MicrofacetLobe1118, v_PassFloat31100, s_irradiance1095.diffuseI, v_shaderGeom1098 );\n \n float v_PassFloat1153 = PassFloat( SurfaceRough_value );\n vec3 v_Vw1161 = Vw( io_1161_Vw );\n vec3 v_normalPassThrough1055 = normalPassThrough( v_faceForwardIntrinsicConditional1097 );\n vec3 v_sampleCubeReflectLogLuv1054 = SampleCubeReflectLogLuv( glossLogLuvCube_samp, glossLogLuvCube_transform, glossLogLuvCube_reflectionCoeff, v_Vw1161, v_normalPassThrough1055, glossLogLuvCube_isLogLuv );\n vec3 v_adjustGain1053 = adjustGain( v_sampleCubeReflectLogLuv1054, glossLogLuvCube_gain );\n vec3 v_sampleCubeReflectLogLuv1059 = SampleCubeReflectLogLuv( radianceLogLuvCube_samp, radianceLogLuvCube_transform, radianceLogLuvCube_reflectionCoeff, v_Vw1161, v_normalPassThrough1055, radianceLogLuvCube_isLogLuv );\n vec3 v_adjustGain1058 = adjustGain( v_sampleCubeReflectLogLuv1059, radianceLogLuvCube_gain );\n vec3 v_blendSingleGlossyRadianceEnv1050 = blendGlossyAndRadianceCubeEnvironment( v_PassFloat1153, v_adjustGain1053, v_adjustGain1058 );\n float v_yOfFloat41099 = yOfFloat4( v_shaderGeom1098 );\n float v_PassConstFloat1121 = PassConstFloat( ANISO_ENV );\n vec3 v_RoughnessToAlpha1122 = RoughnessToAlpha( v_PassInt1103, v_PassFloat1101, v_PassConstFloat1121 );\n vec3 v_Fresnel_Rough1123 = Fresnel_Rough( v_PassFloat31104, v_yOfFloat41099, v_RoughnessToAlpha1122 );\n vec3 v_Environment_Metal1124 = Environment_Metal( v_blendSingleGlossyRadianceEnv1050, v_Fresnel_Rough1123, v_PassFloat31100 );\n vec4 v_PMCombiner1125 = PMCombine( v_BRDF_Matel1119, v_Environment_Metal1124, cutout, opacity );\n vec4 v_alphaTest1126 = alphaTest( v_PMCombiner1125, alphaTestFunc, alphaTestRef );\n\n gl_FragColor = v_alphaTest1126;\n}\n\n";
 
    var attributesValue = {"bitangent":{"type":"v3","value": null}};
    var uniformsValue = {
        SurfaceNDF_value: {type: "i", value: 1.0},
        SurfaceAlbedo_value: {"type":"v3","value":{"x":1,"y":1,"z":1}},
        SurfaceRough_value: {type: "f", value: roughnessFactor},
        SurfaceAniso_value: {type: "f", value: 0},
        SurfaceRotation_value: {type: "f", value: 0},
        cutout: {type:"f", value: 1},
        SurfaceReflect_value: {"type":"v3", value:reflectionFactor},
        World: {"type":"m4","value":{"elements":{"0":1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
        WorldIT: {"type":"m4","value":{"elements":{"0":1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
        viewDirection: {"type":"v3","value":{"x":0,"y":0,"z":1}},
        localviewer: {type: "i", value: false},
        DepthPriority: {"type":"f","value":0},

        flag: {type: "i", value: false},
        
        glossLogLuvCube_cube: {type: undefined, value: null},
        glossLogLuvCube_gain: {"type":"v3","value":{"x":"1.000000","y":"1.000000","z":"1.000000"}},
        glossLogLuvCube_isLogLuv: {type: "i", value: true},
        glossLogLuvCube_reflectionCoeff: {type: "f", value: "1.000000"},
        glossLogLuvCube_samp: {type:"t", value: this.irradianceMap},
        glossLogLuvCube_transform: {"type":"m4","value":{"elements":{"0":-1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
    
        radianceLogLuvCube_cube: {type: undefined, value: null},
        radianceLogLuvCube_gain: {"type":"v3","value":{"x":"1.000000","y":"1.000000","z":"1.000000"}},
        radianceLogLuvCube_isLogLuv: {type: "i", value: true},
        radianceLogLuvCube_reflectionCoeff: {type: "f", value: "1.000000"},
        radianceLogLuvCube_samp: {type:"t", value: this.envMap},
        radianceLogLuvCube_transform: {"type":"m4","value":{"elements":{"0":-1,"1":0,"2":0,"3":0,"4":0,"5":1,"6":0,"7":0,"8":0,"9":0,"10":1,"11":0,"12":0,"13":0,"14":0,"15":1}}},
            
        alphaTestFunc: {type: "i", value: 8},
        alphaTestRef: {type: "f", value: 0},
        opacity: {type:"f", value: 1.0}
    };
    
    
    var uniform;
    for (var u in uniformsValue) {
        uniform = uniformsValue[u];
        if ('m4' === uniform.type) {
            var mat4 = new THREE.Matrix4();
            if (uniform.value != null) {
                mat4.copy(uniform.value);
            }
            uniform.value = mat4;
        }
    }
   
    var res = new THREE.ShaderMaterial({
        uniforms: uniformsValue,
        attributes: attributesValue,
        vertexShader: vertexShaderString,
        fragmentShader: fragmentShaderString
    });
    res.defaultAttributeValues = null;

    return res;
};
    
//footer.js
    };

	Host.creativePlatformLibraryc0HjtqUm7Wzrev0 = creativePlatformLibraryc0HjtqUm7Wzrev0;

})(typeof exports === 'undefined' ? window : exports);
//# sourceMappingURL=library.map
//header.js
/**
The player library acts as the controller to coordinate the UI controls, viewer and the shape generator. It accepts user customized paramaters and presents the resulting 3D shapes.
@module 0vW3XxB8WwN
@main
**/
(function(Host){

	"use strict";

	// This list of methods is taken from the following URL
	// https://developer.mozilla.org/en-US/docs/Web/API/console
	var console = {
		dir: function() { },
		error: function() { },
		group: function() { },
		groupCollapsed: function() { },
		groupEnd: function() { },
		info: function() { },
		log: function() { },
		time: function() { },
		timeEnd: function() { },
		trace: function() { },
		warn: function() { }
	};

	var creativePlatformLibrary0vW3XxB8WwNrev0 = function(Environment, Library){

		var CoreLibrary = Environment.libraryExports("1vxKXGNaLtr", 0);
		var UIToolkit = Environment.libraryExports("aZS9YbvfqUX", 0);
		var $ = UIToolkit.jQuery;
//manifest.js
if (Library) {
	Library.name = "Autodesk Creative Platform Player";
	Library.description = "The library to create the 3D customizers";
	Library.resources = [
	];
}
//globals.js
// TODO:
//player.js
/**
The various parameters that can be passed to the constructor of the Player.
@class PlayerParams
@since 1.0.0
@see Player
@unlisted
**/
var PlayerParams = function() {

    /**
    An HTML DIV where the Player should be inserted into.
    @property {HTMLElement} parent
    **/
    this.parent = undefined;

    /**
    If the player is demonstrating a Shape Generator, then this parameter represents the library of the Shape Generator Library obtained when loading the library.
    @default undefined
    @property {Runtime.Library} library
    **/
    this.library = undefined;
};


/**
Internal / Private data for class.  This is not exported so clients can not find it or use it.
@class _Player
@private
**/
var _Player = function(params) {

    /**
    The element that holds the player
    @private
    @property _element
**/
    this._element = $(params.parent);

    /**
    The library that player holds
    @private
    @property _library
    **/
    this._library = params.library;

    /**
    The Shape Generator function if the library is a shape generator
    @private
    @property _library
    **/
    var libExports =  (params.library && params.library.exports) ? params.library.exports : undefined;
    if(libExports){
        if('function' === typeof libExports['shapeGenerator']){
            this._shapeGenerator = libExports['shapeGenerator']();
        }
        else if('function' === typeof libExports['shapeConfigurator']){
            this._shapeGenerator = new ConfiguratorAdaptor(libExports['shapeConfigurator']());
        }
    }

    /**
    An object used to cache the data.
    @private
    @property {Object} _cache
    **/
    this._cache = {};

    /**
    A viewer used to visualize the data.
    @private
    @property {Object} _viewer
    **/
    this._viewer = undefined;


    /**
    A parameter panel used to display the parameter controls
    @private
    @property {Object} _paramManager
    **/
    this._paramManager = undefined;

    /**
    A Layout Manager used to manage the UI layout for Player
    @private
    @property {Object} _layoutManager
    **/
    this._layoutManager = undefined;


    /**
    A flag for indicating if it's shown
    @private
    @property {Object} _shown
    **/
    this._shown = false;

    /**
    The default params to execute
    @private
    @property {Object} _defaultParams
    **/
    this._defaultParams = undefined;


    /**
    A flag for indicating if the player is shown at the first time.
    @private
    @property {Object} _firstShow
    **/
    this._firstShow = true;
    /**
    Save the original panic callback function
    @private
    @property {Function} _originalPanicCallback
    **/
    this._originalPanicCallback = undefined;


    /**
    Save the generated {CoreLibrary.Mesh3D} objects in the most recent evaluation
    @private
    @property {Array[CoreLibrary.Mesh3D]} _generatedMeshes
    **/
    this._generatedMeshes = [];



    /**
    Fires when the player has changes.  The client-received {Event#data} represents this player.  

    In the future {Event#type} may contain some information that allows the client to understand the specific type of change that happened.
    @event change
    @since 1.2.0
    @public
    @type {EventSource}
    **/
    Object.defineProperty(this, '_change', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: new CoreLibrary.EventSource('changed')
    });


};

_Player.prototype = {

    /**
    Execute the shape generator by the given params and update the result to viewer
    @method _executeGenerator
    @async
    @private
    **/
    _executeGenerator: function(generator, evaluator, params, callback) {
        var self = this;

        // Store the current panic callback
        this._originalPanicCallback = Environment.getVariable(['callbacks', 'panic']);

        // Set up the new callback
        var shapeGeneratorEvaluationPanicHandler = (function(playerImpl) {
            return function(str) {
                playerImpl._errorText(str);
                throw new Error(str);
            }
        })(this);
        Environment.setVariable(['callbacks', 'panic'], shapeGeneratorEvaluationPanicHandler);


        var handleResult = function(result) {

            // Recover the original panic callback
            Environment.setVariable(['callbacks', 'panic'], self._originalPanicCallback);

            if (result) {
                // The existence of the result indicates the success evaluation.
                // Hide the error status in this case.
                self._errorText('');
            }
            callback(result);
        }
        try {
            generator[evaluator](params, handleResult);
        } catch (e) {
            // The execption would be thrown by the panic function or the user code.
            handleResult();
        }
    },

    _errorText: function(str) {
        if (this._viewer) {
            if (str !== undefined) {
                this._viewer.errorText = str;
            } else {
                return this._viewer.errorText;
            }
        }
    },

    _statusText: function(str) {
        if (this._viewer) {
            if (str !== undefined) {
                this._viewer.statusText = str;
            } else {
                return this._viewer.statusText;
            }
        }
    },

    _bindViewerEventHandlers: function(meshes) {

        var self = this;
        var lookAts = [];
        for(var i = 0, len = meshes.length; i < len; i++) {
            var mesh = meshes[i];
            if(mesh['attributes']['viewer'] && mesh['attributes']['viewer']['lookAts']) {
                var lookAtsAttrib = mesh['attributes']['viewer']['lookAts'];
                for(var i = 0; i < lookAtsAttrib.length; i++) {
                   lookAts.push(lookAtsAttrib[i]);
                }
            }
        }

        var lookatcount = lookAts.length;
        if(lookatcount > 0) {
            var lookAtHandler = function(type) {
                var handler = function (e) {
                    for(var i = 0; i < lookatcount; i++) {
                       if(lookAts[i].id == e._data.id) {
                            if((e._data.id === 'image' && type === 'endchange') ||
                               (e._data.id !== 'image' && type !== 'endchange')) {
                                self._viewer.lookAt(
                                    lookAts[i].lookAt.point,
                                    lookAts[i].lookAt.normal,
                                    lookAts[i].lookAt.right
                                );
                            }
                        }
                    }
                };
                return handler;
            };

            this._paramManager.beginchange.bind(lookAtHandler('beginchange'));
            this._paramManager.change.bind(lookAtHandler('change'));
            this._paramManager.endchange.bind(lookAtHandler('endchange')); 
        }
    },


    /**
    Execute the shape generator by the given params and update the result to viewer
    @method _updateViewer
    @async
    @private
    **/
    _updateViewer: function(params, callback) {
        callback = callback || function() {};

        // Update mesh.
        var generator = this._shapeGenerator;
        var evaluator = undefined;
        var self = this;
        if (generator && 'function' === typeof generator['preview']) {
            evaluator = 'preview';
            self._executeGenerator(generator, evaluator, params,
                function(result) {
                    if (self._viewer && result) {
                        self._viewer.removeAllMeshes();

                        self._generatedMeshes = [];
                        if (Array.isArray(result)) {
                            for (var i = 0; i < result.length; i++) {
                                var mesh = result[i].mesh;
                                if (mesh.attributes.viewer && mesh.attributes.viewer.transform) {
                                    var viewMesh = mesh.clone().transform(mesh.attributes.viewer.transform);
                                    self._viewer.addMesh(viewMesh);
                                } else {
                                    self._viewer.addMesh(mesh);
                                }                                
                                self._generatedMeshes.push(mesh);
                            };
                        } else {
                            var mesh = result.mesh;
                            if (mesh.attributes.viewer && mesh.attributes.viewer.transform) {
                                var viewMesh = mesh.clone().transform(mesh.attributes.viewer.transform);
                                self._viewer.addMesh(viewMesh);
                            } else {
                                self._viewer.addMesh(mesh);
                            }
                            self._generatedMeshes.push(mesh);
                        }

                        // Unhighlight all the meshes
                        self._highlightMatchedMeshes([]);

                    }
                    callback();
                });
        } else if (generator && 'function' === typeof generator['evaluate']) {
            evaluator = 'evaluate';
            self._executeGenerator(generator, evaluator, params,
                function(result) {
                    if (self._viewer && result) {
                        self._viewer.removeAllMeshes();
                        var mesh = result.mesh;
                        if (mesh.attributes.viewer && mesh.attributes.viewer.transform) {
                            var viewMesh = mesh.clone().transform(mesh.attributes.viewer.transform);
                            self._viewer.addMesh(viewMesh);
                        } else {
                            self._viewer.addMesh(mesh);
                        }

                        self._generatedMeshes = [];
                        self._generatedMeshes.push(mesh);
                    }
                    callback();
                });
        }
        if (!evaluator) {
            callback();
        }
    },


    /**
    Returns the default layout configuration based on the Parameter Definition
    @method _createLayoutFromParamDef
    @private
    @since 1.0.0
    @param {Controls.LayoutManagerParams} params The LayoutManagerParams used to create the object
    @param {CoreLibrary.ParameterJSON} parameterdefinition The parameter definition used to create the layout config.
    @param {Object} [heading] The title/description that can be displayed at the top of the parameters.
        @param {String} [heading.title] The title which will be displayed in large fonts
        @param {String} [heading.description] The description which will be displayed in regular fonts
    @return {Object} layoutconfiguration
    **/
    _createLayoutFromParamDef: function(params, parameterdefinition, heading) {
        var len = parameterdefinition.length;
        var layout = {
            "children": []
        };

        var parametergroup = {
            "dock": "right",
            "type": "group",
            "group": {
                "children": []
            }
        };

        if (heading && heading.title) {
            var title = {
                "type": "label",
                "label": {
                    "text": heading.title,
                    "fontSize": "large"
                },
                "separated": false
            };
            parametergroup.group.children.push(title);
        }

        if (heading && heading.description) {
            var description = {
                "type": "label",
                "label": {
                    "text": heading.description,
                    "fontSize": "small"
                },
                "separated": false
            };
            parametergroup.group.children.push(description);
        }

        for (var i = 0; i < len; i++) {
            var parameter = parameterdefinition[i];
            var controlparam = {
                id: parameter.id,
                type: "parameter"
            };
            parametergroup.group.children.push(controlparam);
        }
        layout.children.push(parametergroup);

        layout.children.push(this._getDefault3DViewerLayout());

        return layout;
    },

    /**
    Returns the default 3d viewer layout configuration
    @method _getDefault3DViewerLayout
    @private
    @since 1.0.0
    @return {Object} layoutconfiguration
    **/
    _getDefault3DViewerLayout: function() {
        return {
            "dock": "fill",
            "id": "threedviewer",
            "type": "group",
            "group": {
                "type": "view3d",
                "view": {
                    "material": {
                        "id": "default"
                    },
                    "environment": "",
                    "modelPosition": [2, -1, -1]
                },
                "background": {
                    "image": ""
                }
            }
        };
    },

    /**
    Handles changes to the parameters or any MapControls on the layout and updates the viewer.
    @method _onChange
    @private
    @since 1.1.0
    **/
    _onChange: function(sender, e) {

        var generator = this._shapeGenerator;
        //Load configuration
        //Pre-compute the result during initialization
        if (generator && 'function' === typeof generator['validate']) {

            var parameters = this._paramManager.value;
            var maps = {};
            var mapcontrols = this._layoutmanager.findContainers({
                type: 'map'
            });
            var mapcontrolcount = mapcontrols.length;
            var changedmapconfig;
            for (var i = 0; i < mapcontrolcount; i++) {
                var mapcontrol = mapcontrols[i];
                maps[mapcontrol.id] = mapcontrol.control.value;
            }

            var args = {
                parameters: parameters,
                maps: maps
            };
            args.changed = {};
            if (sender == 'parametermanager') {
                args.changed.parameters = {};
                args.changed.parameters[e.data.id] = e.data.oldValue;
            } else if (sender === 'map') {
                args.changed.maps = {};
                args.changed.maps[e.data.id] = e.data.oldValue;

                // disable the turntable
                this._viewer.turntable = false;
            }

            var self = this;
            generator['validate'](args, function(params) {
                if (params && params.length > 0) {
                    self._paramManager.updateParams(params);
                    if (self.layoutmanager) {
                        self.layoutmanager.updateDockPanels();
                    }
                }
            });
        }
    },

    /**
    Handles the hover event that occurs when an item of the ImageMap defined within the LayoutConfiguration is hovered over.
    @method _onMapHover
    @private
    @since 1.2.0
    **/
    _onMapHover: function(e) {

        //If nothing is hovered, de-select everything.
        if (e.data.newValue === undefined) {
            this._viewer.highlightSet.clear();
            return;
        }

        var mapcontrols = this._layoutmanager.findContainers({
            type: 'map'
        });
        var mapcontrolcount = mapcontrols.length;
        var changedmapconfig;
        for (var i = 0; i < mapcontrolcount; i++) {
            var mapcontrol = mapcontrols[i];
            if (e.data.id === mapcontrol.id) {
                changedmapconfig = mapcontrol.configuration;
            }
        }

        if (changedmapconfig && changedmapconfig.map && changedmapconfig.map.legend) {
            var legend = changedmapconfig.map.legend;
            var legendlength = legend.length;
            for (var i = 0; i < legendlength; i++) {
                var mapkey = legend[i];
                if (mapkey.color === e.data.newValue) {
                    this._highlightMatchedMeshes(mapkey.meshes);
                    break;
                }
            }
        }
    },

    /**
    Handles randomization by calling the randomize method if implemented by the Shape Generator.
    @method _onRandomize
    @private
    @since 1.2.0
    **/
    _onRandomize: function(config) {
        var generator = this._shapeGenerator;
        //Load configuration
        //Pre-compute the result during initialization
        if (generator && 'function' === typeof generator['randomize']) {

            var parameters = this._paramManager.value;
            var args = {
                config: config,
                parameters: parameters
            };

            var self = this;

            generator['randomize'](args, function(randomValues) {

                if (randomValues) {
                    var keys = Object.keys(randomValues);
                    var keylength = keys.length;
                    var params = [];
                    for (var i = 0; i < keylength; i++) {
                        var key = keys[i];
                        var value = randomValues[key];
                        params.push({
                            id: key,
                            "default": value
                        });
                    }
                    if (params.length) {
                        self._paramManager.updateParams(params);
                        self._updateViewer(self._paramManager.value);
                        if (self.layoutmanager) {
                            self.layoutmanager.updateDockPanels();
                        }
                    }
                }
            });
        }
    },

    /**
    Calls the validate method on the Shape generator by invoking the change event handler. 
    This ensures that all the initial conditions and parameter clamping is in place.
    @method _validate
    @private
    @since 1.2.0
    **/
    _validate: function() {

        var maps = this._layoutmanager.findContainers({
            type: 'map'
        });
        if (maps && maps.length > 0) {
            var mapcount = maps.length;
            for (var i = 0; i < mapcount; i++) {
                var map = maps[i].control;
                var id = maps[i].id;
                var e = {
                    data: {
                        oldValue: undefined,
                        newValue: map.value,
                        id: id
                    }
                };
                this._onChange('map', e);
            }
        }

    },

    /**
    Highlight the id meshes in the canvas.
    @method _highlightMatchedMeshes
    @private
    @since 1.2.0
    **/
    _highlightMatchedMeshes: function(meshIDs) {

        // Unhighlight all first
        this._viewer.highlightSet.clear();

        if (meshIDs && meshIDs.length > 0) {
            var idMap = {};
            for (var i = 0; i < meshIDs.length; i++) {
                idMap[meshIDs[i]] = true;
            }

            for (var j = 0; j < this._generatedMeshes.length; j++) {
                var mesh = this._generatedMeshes[j];
                var meshId = mesh['attributes']['id'];
                if (idMap[meshId] === true) {
                    this._viewer.highlightSet.add(mesh);
                }
            }
        }

    },


    /**
    Creates the parameter panel according to
    @method _createParamPanel
    @private
    @since 1.1.0
    **/
    _createParamPanel: function() {

        if (this._element) {

            this._paramManager = new UIToolkit.Controls.ParameterManager();

            // Bind events for parameter panel
            var self = this;
            var onChange = function(e) {
                if (e.data && e.data.validate) {
                    self._onChange('parametermanager', e);
                }

                // Get paramPanel's current params
                var params = self._paramManager.value;
                self._updateViewer(params);

                // Fire the change
                self._change.fire(self);
            };

            this._paramManager.change.bind(onChange);
            this._paramManager.endchange.bind(onChange);
        }
    },

    /**
    Initialize the player first time.
    @method _init
    @private
    @param {Function()} callback A callback that's invoked when player is successfully initialized.
    @since 1.1.0
    **/
    _init: function(callback) {
        var self = this;
        $(this._element).addClass('hide-layout');
        if (self._element) {

            var generator = self._shapeGenerator;

            var createLayout = function(params, config) {

                var onChange = function(id) {
                    return function(e) {
                        e.data.id = id;
                        self._onChange('map', e);
                    };
                };
                var onMapHover = function(id) {
                    return function(e) {
                        e.data.id = id;
                        self._onMapHover(e);
                    };
                };

                var onRandomize = function(config) {
                    return function() {
                        self._onRandomize(config);
                    };
                };

                var layoutparams = {
                    id: 'layoutManager',
                    parent: self._element
                };
                //add library namespace class on layoutmanager
                $(self._element).addClass('l' + self._library.id + self._library.version);

                var layout;
                if (config && config.layout) {
                    layout = config.layout;
                } else {
                    layout = self._createLayoutFromParamDef(layoutparams, params, {
                        title: self._library.name,
                        description: self._library.description
                    });
                }

                self._layoutmanager = new UIToolkit.Controls.LayoutManager(layoutparams, layout);

                self._viewer = self._layoutmanager.findContainers({
                    type: 'view3d'
                })[0].control;
                self._viewer.showLoading = true;
                var maps = self._layoutmanager.findContainers({
                    type: 'map'
                });
                if (maps && maps.length > 0) {
                    var mapcount = maps.length;
                    for (var i = 0; i < mapcount; i++) {
                        var map = maps[i].control;
                        map.change.bind(onChange(maps[i].id));
                        map.itemhover.bind(onMapHover(maps[i].id));
                    }
                }

                var randomizers = self._layoutmanager.findContainers({
                    type: 'randomizer'
                });
                if (randomizers && randomizers.length > 0) {
                    var randomizerscount = randomizers.length;
                    for (var i = 0; i < randomizerscount; i++) {
                        var randomizer = randomizers[i].control;
                        var randomizerconfig = randomizers[i].configuration;
                        randomizer.click.bind(onRandomize(randomizerconfig.randomizer));
                    }
                }

                self._paramManager.layoutManager = self._layoutmanager;
            };

            var initDone = function(defaultParams) {

                // Evaluate the default result
                self._viewer && self._updateViewer(defaultParams, function() {

                    // Update parameter panel.
                    if (self._paramManager && self._defaultParams) {
                        self._paramManager.updateParams(self._defaultParams);
                        self._validate();
                        delete self._defaultParams;
                    }

                    //Refresh the layout once the 3d view loads
                    if (self._layoutmanager) {
                        self._layoutmanager.updateDockPanels();
                    }

                    self._viewer.home();

                    self._bindViewerEventHandlers(self._generatedMeshes);
                    // Player initialized successfully, invoke the callback .
                    callback();
                });
            };

            //Load configuration
            //Pre-compute the result during initialization
            if (generator && 'function' === typeof generator['parameters']) {

                generator['parameters'](function(params) {
                    params = $.extend(true, [], params);

                    // Get the default params for the first time execution
                    var defaultParams = {};
                    for (var i = 0; i < params.length; i++) {
                        var param = params[i];
                        defaultParams[param['id']] = param['default'];
                        //set library details on each param
                        param.libraryId = self._library.id;
                        param.version = self._library.version;
                    }

                    var setParams = function(params) {
                        if (self._shown) {
                            self._paramManager.updateParams(params);
                            self._validate();
                            if (self.layoutmanager) {
                                self.layoutmanager.updateDockPanels();
                            }
                            delete self._shown;
                        } else {
                            self._defaultParams = params;
                        }
                    };

                    // Load the configuration
                    if ('function' === typeof generator['configuration']) {
                        generator['configuration'](function(config) {
                            createLayout(params, config);
                            setParams(params);
                            initDone(defaultParams);
                        });
                    } else {
                        createLayout(params);
                        setParams(params);
                        initDone(defaultParams);
                    }
                });
            }
        }
    },

    /**
    Show the player
    @method _show
    @private
    @since 1.1.0
    **/
    _show: function() {

        if (this._shown) {
            return;
        }

        this._shown = true;

        if (this._viewer) {
            this._viewer.resume();
            this._viewer.refresh();
        }

        //Force the layout manager to recalculate
        if (this._layoutmanager) {
            this._layoutmanager.updateDockPanels();
        }

        // If the parent div is hidden, width and height will not be applied
        // to the children divs after css file is loaded.
        // Here we need to call "viewer.home" at the first time show with the
        // correct viewer width and height. It makes sure the mesh to be placed
        // to the correct position.
        if (this._firstShow) {
            if (this._viewer) {
                this._viewer.home();
                this._viewer.statusText = "Click and drag object to rotate";
                this._viewer.showLoading = false;
                this._firstShow = false;
            }
        }

        $(this._element).removeClass('hide-layout');

    },

    /**
    Hide the player
    @method _hide
    @private
    @since 1.1.0
    **/
    _hide: function() {
        if (!this._shown) {
            return;
        }

        $(this._element).addClass('hide-layout');

        this._shown = false;

        if (this._viewer) {
            this._viewer.suspend();
        }
    },

    /**
    Reset the player
    @method _reset
    @private
    @since 1.1.0
    **/
    _reset: function() {

        var generator = this._shapeGenerator;
        if (generator && 'function' === typeof generator['parameters']) {

            var self = this;
            generator['parameters'](function(params) {
                params = $.extend(true, [], params);

                self._paramManager.updateParams(params);

                // Update default parameters.
                self._defaultParams = params;

                self._viewer && self._updateViewer(self._paramManager.value, function() {
                    self._viewer.home();
                });

                // fire the change event
                self._change.fire(self);

            });
        }

    }
}

/**
The various parameters that can be passed to the constructor of the Player.
@constructor
@class Player
@extends UIToolkit.Controls.BaseControl
@since 1.0.0
@see PlayerParams
@param {PlayerParams} params Player parameters.
**/
var Player = function(params) {
    
    /**
    Create the IMPL such that clients can't see it. Reference to the internal class.
    @private
    @property {_Player} _impl
    **/
    Object.defineProperty(this, '_impl', {
        writable: false,
        enumerable: false,
        configurable: false,
        value: new _Player(params)
    });

    /**
    Sets the error message and displays in the viewport. It preempts the status message as a more urgent message to user 
    @property {String} errorText
    @since 1.2.0
    **/
    Object.defineProperty(this, 'errorText', {
        enumerable: true,
        get: function() {
            this._impl._errorText();
        },
        set: function(value) {
            this._impl._errorText(value);
        }
    });

    /**
    Sets the status message and displays it in the viewport 
    @property {String} statusText
    @since 1.2.0
    **/
    Object.defineProperty(this, 'statusText', {
        enumerable: true,
        get: function() {
            this._impl._statusText();
        },
        set: function(value) {
            this._impl._statusText(value);
        }
    });

    /**
    Sets the event for player
    @event change
    @since 2.0.1
    @public
    @type {EventSource}
    **/
    Object.defineProperty(this, 'change', {
        writable: false,
        enumerable: true,
        configurable: false,
        value: this._impl._change
    });

    UIToolkit.Controls.BaseControl.extend(this);

};

/**
Callback of initialization.
@private
@method onInitialize
*/
Player.prototype.onInitialize = function() {

    // Create the paramater panel immediately after player is created.
    this._impl._createParamPanel();


    // Bind the change handler
    this.change.bind(viewerUpdateHandler);

};

/**
Initializes player and executes the callback after the initilization is finished.

This is useful in many cases, for example client can start a loading indicator in the window and dismiss it in the callback; or if player needs to be shown right after the initialization, then the show function can be called in the callback. 
@public
@method init
@since 1.2.0
@param {Function()} callback A callback that's invoked only if player is initialized successfully.
@async
@example
   player.init(
        function() {
            player.show();
        }
   )
*/
Player.prototype.init = function(callback) {

    this._impl._init(callback);

};

/**
 OnShow callback of show method of control.
 @private
 @method onShow
**/
Player.prototype.onShow = function() {

    this._impl._show();

};

/**
 OnShow callback of hide method of control.
 @private
 @method onHide
**/
Player.prototype.onHide = function() {

    this._impl._hide();

};

/**
Returns the shape generator result by executing the "evaluate" function with the most recent parameters.
@method shapeGeneratorResult
@since 1.0.0
@param callback {Function(CoreLibrary.Solid3D|undefined)} A callback that receives the resulting solid upon completion or failure.
@async
**/
Player.prototype.shapeGeneratorResult = function(callback) {
    if (typeof callback !== 'function') {
        return;
    }

    var params = this.parameters();
    if (this._impl._shapeGenerator && 'function' === typeof this._impl._shapeGenerator['evaluate'] && params) {
        this._impl._executeGenerator(this._impl._shapeGenerator, "evaluate", params, callback);
    } else {
        callback();
    }
};

/**
Returns a thumbnail image URL by given width and height.
@method imageURL
@since 1.1.0
@param {Number} width The width of the image in pixel
@param {Number} height The height of the image in pixel
@return {String|undefined}
**/
Player.prototype.imageURL = function(width, height) {
    if (this._impl._viewer) {
        return this._impl._viewer.imageURL(width, height);
    }
    return undefined;
};

/**
Returns the parameter key value pairs that user specifies in the parameter panel.
@method parameters
@since 1.1.0
@return {Object}
**/
Player.prototype.parameters = function() {
    if (this._impl._paramManager) {
        return this._impl._paramManager.value || {};
    }
    return {};
};

/**
Resets the player to default state. 
@method reset
@since 1.1.0
**/
Player.prototype.reset = function() {
    this._impl._reset();
};



/**
The ViewGroupHandler class is a default View Handler that handles Controls with type = view.
This handler will create a 3D view with the view configurations passed in the argument.
@class ViewGroupHandler
@since 1.1.0
@constructor
@extends {UIToolkit.Controls.IGroupHandler}
@private
**/
var ViewGroupHandler = function() {
    UIToolkit.Controls.IGroupHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary UI/Interaction if so defined.
@method create
@since 1.1.0
@param {Object} params Parameter JSON 
    @param {String} params.id Id of the element. This needs to be unique for each element.
    @param {UIToolkit.Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.LayoutGroup3DViewJSON} params.config The underlying config part which is required to create the ViewGroupHandler.
@param {UIToolkit.Controls.LayoutManager} layoutmanager The instance of the LayoutManager which is using these handlers.
@private
**/
ViewGroupHandler.prototype.create = function(params, layoutmanager) {
    var thisObj = this.initialize(params, layoutmanager);
    var config = params.config;

    var Viewer = Environment.libraryExports("c0HjtqUm7Wz", 0);
    var _viewer;
    try {
        _viewer = new Viewer.Viewer({
            'parent': thisObj.content.contentArea[0]
        });
    } catch (e) {
        // The try-catch block is used to catch the exception thrown by the panic function called by the constructor of _Viewer class.
        // We don't need to call the panic here.
        return;
    }

    // Make the canvas panel force update when scrolling the window.
    // NOTE: We hooked up this event to fix the issue: on Chrome 34, the canvas can't be updated correctly, will be clipped when resize and scroll the window.
    // You can refer to bug TINK-675 for more information.
    // We have verified that no such bug exists for Chrome 33 and Chrome 36 dev version, so this a Chrome 34 regression bug.
    // After Chrome fixes this issue in the later version, we will remove the fix code here.
    // Since this won't affect performance or have any other side-effects. We don't detect browser and apply this only for Chrome currently.
    window.addEventListener('scroll', function() {
        thisObj.content.contentArea[0].style.webkitTransform = "rotateZ(0deg)";
        thisObj.content.contentArea[0].offsetHeight;
        thisObj.content.contentArea[0].style.webkitTransform = "none";
    }, true);

    var viewParams = config.view;
    var background = config.background;

    if (viewParams) {
        if (viewParams.material && viewParams.material.id) {
            _viewer.globalMaterial = viewParams.material.id;
        }

        if (typeof viewParams.environment === 'string') {
            _viewer.environment = viewParams.environment;
        }

        if (typeof viewParams.ssao === 'boolean') {
            _viewer.ssao = viewParams.ssao;
        }

        if (typeof viewParams.shading === 'string') {
            _viewer.shading = viewParams.shading;
        }
    }

    if (background) {
        if (typeof background.image === 'string') {
            _viewer.background = background.image;
        }

        if (typeof viewParams.camera === 'object') {
            _viewer.camera = viewParams.camera;
        }
    }

    thisObj.content.resize.bind(function() {
        _viewer.refresh();
    });

    layoutmanager.setContainer(params.config, _viewer);

};


/**
The FileParameterHandler class is a default File Parameter Handler that handles Parameters with type = file. 
This handler creates a {UIToolkit.Controls.FileManager} which is responsible for managing the File Input Control and any 
modifiers that it may require.
@class FileParameterHandler
@since 2.0.1
@private
@constructor
@extends {UIToolkit.Controls.IParameterHandler}
**/
var FileParameterHandler = function() {
    UIToolkit.Controls.IParameterHandler.extend(this);
};

/**
Executes the Handler for the input set and creates the necessary controls.
@method create
@param {Object} params Parameter JSON 
    @param {UIToolkit.Controls.Panel} params.parent Parent panel within which the DOM needs to be created.
    @param {CoreLibrary.FileParameterJSON} params.definition The definition which is required to create the File Parameter control.
@param {UIToolkit.Controls.ParameterManager} parametermanager The instance of the ParameterManager which is using these handlers.
**/
FileParameterHandler.prototype.create = function(params, parametermanager) {
    this.initialize(params, parametermanager);
    var param = params.definition;
    var parent = params.parent.contentArea;
    var Runtime = Host.creativePlatformRuntime;
    var editorParent;

    var view3dContainers = parametermanager._layoutmanager.findContainers({
        type: 'view3d'
    });

    if (view3dContainers && view3dContainers.length > 0) {
        var view3dParent = $(view3dContainers[0].control._impl.element).parent();
        editorParent = view3dParent.find('.ui-fileeditor-parent');
        if(editorParent.size() === 0 ) {
            editorParent = $('<div class="ui-fileeditor-parent" style="display:none;position:absolute;left:0;right:0;top:0;bottom:0;margin:auto;background-color:#ffffff;z-index:999"></div>');
            editorParent.appendTo(view3dParent);
        }
        editorParent.empty();
    }

    var fileManager = new UIToolkit.Controls.FileManager({
        id: param.id,
        parent: parent,
        editorParent: editorParent,
        config: param.config,
        accept: param.accept,
        maxSize: param.maxSize
    });
    if (param.default && (param.default.url || param.default.fileURL)) {
        fileManager.value = param.default;
    }
    fileManager.param = function(control) {
        return function() {
            //TODO: Write json comparison code.
            if (!control._file || JSON.stringify(control._file._impl._json) != JSON.stringify(control.value)) {
                if (control.value && (control.value.url || control.value.fileURL)) {
                    delete control.value.url;
                    control._file = Runtime.createFile(control.value);
                }
            }
            return control._file;
        };
    }(fileManager);

    parametermanager.setControl(param, fileManager);
};


UIToolkit.Controls.LayoutHandlers.addGroupHandler('view3d', new ViewGroupHandler(), 'true');
UIToolkit.Controls.ParameterHandlers.addParameterHandler('file', new FileParameterHandler());


/*
The handler for updating parameter to viewer
@method viewerUpdateHandler
*/
function viewerUpdateHandler(event) {
    var _player = event.data;
    if (_player instanceof _Player && _player._paramManager) {
        var params = _player._paramManager.value;
        if (params) {
            var materialID = params['materialAndColor'];

            var materialMapping = Host.creativePlatformRuntime.environment.getVariable(['viewer', 'materialMapping']);
            if (materialMapping && materialMapping[materialID]) {
                materialID = materialMapping[materialID];
            }
            if (materialID) {
                _player._viewer.globalMaterial = materialID;
            }
        }
    }
};

Library.exports.Player = Player;

//topic-introduction.js
/**
Below is an example of how the Autodesk Creative Platform Player can be included in a web page for a Shape Generator:
<pre class="prettyprint lang-html">
{@Tokens:Off}
&lt;!-- Includes the Creative Platform Runtime --&gt;
&lt;script type="text/javascript" src="https://api.tinkercad.com/libraries/1jiw9epElcK/0/library.min.js"&gt;&lt;/script&gt;

&lt;!-- Download Shape Generator and Player --&gt;
&lt;script type="text/javascript"&gt;
creativePlatformRuntime.require(
	// The ID of some Shape Generator and this Player...
	[
		{ id: "0vW3XxB8WwN", version: 0 }, // This Player
		{ id: "aZS9YbvfqUX", version: 0 }, // Any Shape Generator
	],
	// Callback invoked when both libraries and their dependencies are downloaded...
	function(generator, player) {
        var id = "aZS9YbvfqUX";
        var ver = 0;
		var params = {
			"library": creativePlatformRuntime.environment.library(id, ver),
			"parent": document.getElementById("container")
		};
		var player = new player.Player(params);
        player.init(function() {player.show();});
	},
	// Callback invoked if failure occurs....
	function() { }
);
&lt;/script&gt;

&lt;body&gt;
    &lt;div id="container"&gt;&lt;!-- The container for customizer --&gt;&lt;/div&gt;
&lt;/body&gt;
{@Tokens:On}
</pre>

<br> <br>

<div>You can go to <a href='/libraries/tour/generators'>shape generator tour page</a> playing with the customizers built on Player library
</div>

<br> <br>
<div>Shape Generator ID and Version can also be inputted here with ID.Version(e.g. dwEU5AV7TiM.0) format to play with:<input id="shapeGenVersion" type="text" value=""/><button id="btnOK" type="button">go</button></div>
<div id="playercontainer" style="width:920px; height:600px; position:relative"></div>
<script src="/libraries/1jiw9epElcK/0/library.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        var runtime = window.creativePlatformRuntime;
        var env = runtime.environment;
        env.setVariable(['urls', 'api'], window.location.protocol + '//' + window.location.host);

        var getShapeGeneratorVersion = function() {
            var ver = {};
            var str = $('#shapeGenVersion').val();
            var idx = str.indexOf('.');
            if (idx > 0) {
                ver.id = str.slice(0, idx);
                ver.version = parseInt(str.slice(idx+1));
            } else {
                ver.id = str;
                ver.version = 0;
            }
            return ver;
        };

        var playerObj = undefined;

        var playerLib = {
            'id': '0vW3XxB8WwN',
            'version': 0
        };

        var showShapeGenerator = function() {
            var shapeGenLib = getShapeGeneratorVersion();
            runtime.require([shapeGenLib, playerLib], function(sg, player) {               
                    var param = {
                        parent: document.getElementById("playercontainer"),
                        library: env.library(shapeGenLib.id, shapeGenLib.version)
                    };
                    playerObj = new player.Player(param);
                    playerObj.init(function() {
                        playerObj.show();
                    });
            
            }, function() {
                    console.error('Failed to load shape generator library!');
            });
        };

        $('#btnOK').click(function() {
            showShapeGenerator();
        });

        
    });
</script>

@topic Interactive Demonstrations
**/
//documentation.js
/**
This version represents the initial debut of player library in Creative Platform
@version 1.0.0
@released 2014-03-03T00:00:00Z
@markdown
**/


/**
- Added `imageURL` method in {Player} class.
- Added `parameters` method in {Player} class.
- Added `reset` method in {Player} class.
@version 1.1.0
@released 2014-05-13T00:00:00Z
@markdown
**/


/**
- Added `errorText` property in {Player} class.
- Added `statusText` property in {Player} class.
- Added `init` method in {Player} class.
- Added validation/parameter clamping support
- Added randomization support
- The player now listens for hover events on the ImageMaps defined on the Layout and marks the corresponding selection on the model.
@version 1.2.0
@released 2014-06-16T00:00:00Z
@markdown
**/

/**
- Hid `ViewGroupHandler` class for internal use
@version 2.0.0
@released 2014-07-10T00:00:00Z
@markdown
**/

/**
- Moved the CSS loading outside the Player into the new Connector class
- Added the {Player#change} as a event source
@version 2.0.1
@released 2014-08-08T00:00:00Z
@markdown
**/
//configuratoradaptor.js
var ConfiguratorAdaptor = function(configurator){
    this.configurator = configurator;

    var me = this;
    function defaultAdaptor(element){
        if(configurator[element]){
            me[element] = function(){
                configurator[element].apply(configurator, arguments);
            };
        }
    }
    ["parameters", "presets", "validate", "configuration", "randomize"].forEach(defaultAdaptor);
};
ConfiguratorAdaptor.prototype = {
    evaluate: function(params, callback){
        this._generateMesh(params, false, callback);
    },
    preview: function(params, callback){
        this._generateMesh(params, true, callback);
    },

    _generateMesh: function(params, isPreview, callback){
        var me = this;

        var generateMeshForShape=function(shapeJSON, callback){
            if(shapeJSON["isSub"] === true){
                CoreLibrary.Plugin.panic("The substraction shape is not supported.");
            }

            var applyTransform = function(tm, solidArr){
                if(!(tm instanceof CoreLibrary.Matrix3D)){
                    tm = new CoreLibrary.Matrix3D(tm);
                }
                for(var i=0; i < solidArr.length; i++){
                    solidArr[i].transform(tm);
                }
            };

            var anyModifierApplied = function(mods) {
                if(!mods || mods.length < 1) {
                    return false;
                }
                return true;
            };

            var applyModifiers = function(instances, mods, finished) {

                function asyncApplyModifierEach(evaluateModifier, mods) {
                    var l = mods?mods.length:0;
                    var i = -1;
                    function getModifierPayload(modifier, instances){
                        var modLibId = modifier.libraryId;
                        var modLibRev = modifier.libraryRev;
                        var meshParams = modifier.params; 
                        var payload = {
                            "id": modLibId,
                            "version": modLibRev,
                            "executionMethod": "evaluate",
                            "scope": [
                              { "symbol": "shapeModifier", "symbolIsMethod": true}
                            ],
                            "executionAsynchronous": true,
                            "executionParams": {"instances": instances, "params": meshParams}
                        };

                        return payload;
                    };

                    function applyModifier(instances) {  
                        i += 1;  
                        if (i === l) {
                            //All of modifiers are already applied, so go to finish
                            finished(instances);
                            return;
                        } 
                        //evalualte one modifier to all instances
                        var payload = getModifierPayload(mods[i], instances);
                        evaluateModifier(payload, applyModifier);  
                    }; 

                    //Start to apply modifier 
                    applyModifier(instances);  
                };

                function evaluateOneModifier(payload, callback) {
                    Host.creativePlatformRuntime["execute"](payload, function success(result){
                        //This is a key step to make cross window object pass workable
                        result = JSON.parse(JSON.stringify(result));
                        //Apply next modifier to the modified instances
                        callback(result.output);
                    }, function fail(){
                        CoreLibrary.Plugin.panic("Failed to exeucte shape modifier ("+payload.id+","+payload.version+")");
                    });
                };

                //start to apply the modifiers one by one
                asyncApplyModifierEach(evaluateOneModifier, mods);
            };

            var applyTransfromToInstances = function(instanceJSONs, callback){

                var results = [];
                for(var i=0; i< instanceJSONs.length; i++){
                    var meshJSON = instanceJSONs[i]['mesh'];
                    var mesh = new CoreLibrary.Mesh3D();
                    mesh.indexedTriangles(meshJSON['vertices'], meshJSON['triangles']);
                    var solid = CoreLibrary.Solid.make(mesh);
                    // Apply transform
                    applyTransform(instanceJSONs[i]['localToParent'], [solid]);
                    
                    results.push(solid);    
                }
                
                callback(results);
            }

            var children = shapeJSON["children"];
            if(!Array.isArray(children) || children.length===0){
                // Leaf shape
                var pluginType = shapeJSON["geom"] && shapeJSON["geom"]["pluginType"] ? shapeJSON["geom"]["pluginType"] : "";
                if(pluginType && pluginType !== "library"){
                    CoreLibrary.Plugin.panic("The pluginType "+pluginType+" is not supported.");
                }

                // Evaluate the shape generator.
                var libId = shapeJSON["geom"]["pluginId"];
                var libRev = shapeJSON["geom"]["pluginRev"];
                var payload = {
                    "id": libId,
                    "version": libRev,
                    "executionMethod": "evaluate",
                    "scope": [
                      { "symbol": "shapeGenerator", "symbolIsMethod": true}
                    ],
                    "executionAsynchronous": true,
                    "executionParams": shapeJSON["geom"]["params"],
                    "environment": {
                         "execution": { "scale": shapeJSON["geom"]["scale"]}
                    }
                };
                Host.creativePlatformRuntime["execute"](payload, function success(meshJSON){
                    var mesh = new CoreLibrary.Mesh3D();
                    mesh.indexedTriangles(meshJSON['Verts'], meshJSON['Tris']);

                    // Apply scale first then TM
                    var trans = new CoreLibrary.Matrix3D();
                    trans.transform(shapeJSON["TM"]);

                    var modifiers = shapeJSON["mods"];
                    if(!anyModifierApplied(modifiers)) {
                        var solid = CoreLibrary.Solid.make(mesh);
                        applyTransform(trans, [solid]);

                        callback([solid]);
                        return;
                    }
                    //Apply modifiers to each instance one by one
                    var instances = [];
                    instances.push(new CoreLibrary.Instance(trans, mesh));
                    applyModifiers(instances, modifiers, function(modifiedInstanceJSONs) {
                        applyTransfromToInstances(modifiedInstanceJSONs, callback);
                    });
                            
                }, function fail(){
                        CoreLibrary.Plugin.panic("Failed to exeucte shape generator ("+libId+","+libRev+")");
                });
            }

            // Group
            var len = children.length;
            var pending = len;
            var solidMap = {};
            var complete = function(index, solids){
                solidMap[index] = solids;
                pending--;
                if(pending === 0){
                    // All the children are finished.
                    var result;
                    if(isPreview){
                        // apply modifiers to mesh instances if there is any
                        var modifiers = shapeJSON["mods"];
                        if(anyModifierApplied(modifiers)) {        
                            var trans = new CoreLibrary.Matrix3D();
                            trans.transform(shapeJSON["TM"]);
                            var instances = []; 
                            for(var j=0; j< len; j++){
                                for(var k=0;k<solidMap[j].length;k++) {
                                    instances.push(new CoreLibrary.Instance(trans, solidMap[j][k].mesh));
                                }
                            }
                            applyModifiers(instances, modifiers, function(modifiedInstanceJSONs) {
                                applyTransfromToInstances(modifiedInstanceJSONs, callback);
                            });
                        } else {
                            //no modifiers applied
                            result = [];
                            for(var j=0; j< len; j++){
                                result = result.concat(solidMap[j]);
                            }
                            
                            applyTransform(shapeJSON["TM"], result);

                            callback(result);
                        }   
                    } else {
                        var mesh = new CoreLibrary.Mesh3D();
                        for(var j=0; j< len; j++){
                            // Use combine instead of boolean as a temporary solution. 
                            for(var k=0;k<solidMap[j].length;k++) {
                                mesh.combine(solidMap[j][k].mesh);
                            }      
                        }

                        // apply modifiers to mesh instances if there is any
                        var modifiers = shapeJSON["mods"];
                        if(anyModifierApplied(modifiers)) {
                            var trans = new CoreLibrary.Matrix3D();
                            trans.transform(shapeJSON["TM"]);
                            var instances = [];
                            instances.push(new CoreLibrary.Instance(trans, mesh));
                            applyModifiers(instances,  modifiers, function(modifiedInstanceJSONs) {
                                applyTransfromToInstances(modifiedInstanceJSONs, callback);
                            });  
                        } else {
                            result = CoreLibrary.Solid.make(mesh);
                            
                            applyTransform(shapeJSON["TM"], [result]);

                            callback([result]);
                        }                
                    }    
                }
            }

            for(var i=0; i<len; i++){
                generateMeshForShape(children[i], function(index){
                    return function(meshes){
                        complete(index, meshes);
                    }
                }(i));
            }
        };

        var populateContext = function(params, callback){
            me.configurator.shape(function(shape){
                var context = {
                    shape: shape,
                    params: params
                };
                callback(context);
            });
        };

        populateContext(params, function(context){
            me.configurator.evaluate(context, function(shape){
                generateMeshForShape(shape.toJSON(), callback);
            });
        });
    }
};

//footer.js
    };

    Host.creativePlatformLibrary0vW3XxB8WwNrev0 = creativePlatformLibrary0vW3XxB8WwNrev0;

    // Set up the panic callback. The err object is optional
    (function(){

        var env = Host.creativePlatformRuntime.environment;

        // Get current panic callback, for daisy-chaining things
        var currentPanicHandler = env.getVariable(['callbacks', 'panic']);

        // Override ['callbacks', 'panic']
        env.setVariable(['callbacks', 'panic'], function(str, err) {
            // If there is a "failedCallback" provided by Andes then directly use it,
            // else we need to provide our own error message for the non-andes customizers.
            var initArgs = env.getVariable(['andes', 'initArgs']);
            if(initArgs && initArgs.failedCallback){
                initArgs.failedCallback();
            }else{
                // TODO: Pop up message
                console.log(str);
            }

            // Execute original panic...
            if (currentPanicHandler) {
                currentPanicHandler(str);
            }
        });
    })();

})(typeof exports === 'undefined' ? window : exports);

//# sourceMappingURL=library.map
//header.js
/**
Introduction goes here.
@module aLVZT9dTtGG
@main
**/
(function(Host){

	"use strict";

	// This list of methods is taken from the following URL
	// https://developer.mozilla.org/en-US/docs/Web/API/console
	var console = {
		dir: function() { },
		error: function() { },
		group: function() { },
		groupCollapsed: function() { },
		groupEnd: function() { },
		info: function() { },
		log: function() { },
		time: function() { },
		timeEnd: function() { },
		trace: function() { },
		warn: function() { }
	};

	var creativePlatformLibraryaLVZT9dTtGGrev0 = function(Environment, Library){
	var WidgetConnectors = {};
	var UIToolkit = Environment.libraryExports("aZS9YbvfqUX", 0);
	var PlayerLib = Environment.libraryExports("0vW3XxB8WwN", 0);
	var $ = UIToolkit.jQuery;


//manifest.js
if (Library) {
	Library.name = "Autodesk Distribute Connect";
	Library.description = "";
	Library.resources = [
		{ "id": "7xS96PF92q8", "name": "core.css" }
		,{ "id": "5xtHw5PLnit", "name": "openhand.cur" }
		,{ "id": "7Vx01oJYm22", "name": "background.png" }
	];
}
//main.js
/**
This interface specifies the methods and functions that need to be implemented by concrete WidgetConnector classes
@interface IWidgetConnector
@since 1.0.0
**/
var IWidgetConnector = function(){};

IWidgetConnector.prototype = {

    /**
    The initialization method to be called with intialization parameters that will be required by the connector.
    @method init
    @param {Object} [initArgs] The input argument can be any object that contains properties required by the connector.
    **/
    init: function(initArgs) {},

    /**
    The update method can be called to modify the connector or its implementation based on certain input parameters.
    @method update
    @param {Object} [updateArgs] The input argument can be any object that contains properties required by the connector.
    **/
    update: function(updateArgs){},

    /**
    The show method will be responsible for displaying any UI that the Connector creates/manages.
    @method show
    @param {Object} [showArgs] The input argument can be any object that contains properties required by the connector.
    **/
    show: function(showArgs){},

	/**
    The hide method will be responsible for hiding any UI that the Connector creates/manages.
    @method hide
    @param {Object} [hideArgs] The input argument can be any object that contains properties required by the connector.
    **/
    hide: function(hideArgs){},

	/**
    The ready method should be called when all the necessary pre-initialization (if required) is completed.
    @method ready
    @param {Object} [readyArgs] The input argument can be any object that contains properties required by the connector.
    **/
    ready: function (readyArgs) {},

	/**
    The getData method returns some information that is required to be exported in a certain form. This can change based on the input arguments.
    @method getData
    @param {Object} [readyArgs] The input argument can be any object that contains properties required by the connector.
    **/
    getData: function(dataArgs){}
};

Library.exports.Connector = {
    getConnector : function (connectorType, disconnected) {
        return new WidgetConnectors[connectorType]();
    }
};

//FileSaver.js
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2014-07-25
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  // IE 10+ (native saveAs)
  || (typeof navigator !== "undefined" &&
      navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
  // Everyone else
  || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" &&
	    /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = !view.externalHost && "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 for
		// the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 10
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, FileSaver = function(blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && typeof safari !== "undefined") {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				revoke(object_url);
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module !== null) {
  module.exports = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}

//default.js
/**
The Default connector class that creates the basic implementation of the Player.
This implements the {IWidgetConnector} interface
@constructor
@class DefaultConnector
@since 1.0.0
**/
var DefaultConnector = function(){};

DefaultConnector.prototype = new IWidgetConnector();
DefaultConnector.prototype.constructor = DefaultConnector;

/**
The initialization method to be called with intialization parameters that will be required by the connector.
@method init
@param {Object} [initArgs] The input argument can be any object that contains properties required by the connector.
**/
DefaultConnector.prototype.init = function (initArgs) {
	this.args = initArgs;
};

/**
The ready method should be called when all the necessary pre-initialization (if required) is completed.
@method ready
**/
DefaultConnector.prototype.ready = function () {
	$(this.args.parent).addClass('l' + Library.id + Library.version);
	var params = {
		"library": this.args.library,
		"parent": this.args.parent

	};
	var player = new PlayerLib.Player(params);
	var loadingIndicator = document.getElementById("loadingIndicator");

	var css = [];
	css.push(Library.resourceURL('core.css'));
	var resLength = this.args.library.resources.length;
	for(var i=0;i<resLength;i++) {
		var name = this.args.library.resources[i].name;
		if(name === 'default.css')
			css.push(this.args.library.resourceURL(name));
	}

	Utility.loadThemeAndCSS(UIToolkit.Themes.Tinkercad , css, function () {
		player.init(function() {
			player.show();
			if(loadingIndicator) {
				loadingIndicator.style.display = "none";
			}
		});
	});
	return player;
};

WidgetConnectors['default'] = DefaultConnector;

//utility.js
/**
Static utility class. 
This is a collection of utility methods that can be used by the connectors.
@class Utility
@static
@since 1.0.0
**/
var Utility =  (function() {
    
    return {
        /**
        * Loads the theme and css passed in as the argument and calls the callback once all the CSS files have been fetched.
        * @public       
        * @method loadThemeAndCSS
        * @param {UIToolkit.Controls.Themes} themeId Theme resource id.
        * @param {String|Array[String]} css An url of css file or an array containing multiple css urls.
        * @param {Function(boolean)} [callback] A callback function will be called once css loaded in document. Success flag will be passed as an argument of this callback.
        */
        loadThemeAndCSS: function (themeId, css, callback) {
            var flag = 1;
            if(css && css.length > 0) {
                flag++;
            }
            var cssLoadCallback = function () {
                flag--;
                if(flag === 0 && callback) { callback();}
            };

            UIToolkit.Utility.loadTheme(themeId, cssLoadCallback);
            UIToolkit.Utility.loadCSS(css,cssLoadCallback,themeId);
        },

        /**
        * Fetches the information of the model within the Player and calls the callback specified in the input arguments on completion.
        * @public       
        * @method getData
        * @param {Object} dataArgs
            * @param {Object} dataArgs.callback The callback that will be called on completion with the data as the argument
        * @param {PlayerLib.Player} player Instance of the Player whose model needs to be read.
        */
        getData: function (dataArgs, player) {
            player.shapeGeneratorResult(
                function(solid3d) {
                    var thumbnailURL = player.imageURL(385, 500);
                    var streamStart = thumbnailURL.indexOf(',') + 1;
                    var stream = thumbnailURL.substr(streamStart);
                    var typeStart = thumbnailURL.indexOf(':') + 1;
                    var typeEnd = thumbnailURL.indexOf(';');
                    var contentType = thumbnailURL.substring(typeStart, typeEnd);

                    var CoreLibrary = Host.creativePlatformRuntime.environment.libraryExports("1vxKXGNaLtr", 0);
                    var stlArrayBuffer = CoreLibrary.Conversions.toBinarySTLFromMesh3D(solid3d.mesh);
                    var stlStream = CoreLibrary.Conversions.toBase64FromArrayBuffer(stlArrayBuffer);
                    var presets = player.parameters();
                    var attrs = [];
                    for (var key in presets) {
                        var attr = key + " " + presets[key];
                        attrs.push(attr);
                    }
                    var description = attrs.join("-");

                    var metaData = {
                        "materialAndColor" : presets["materialAndColor"],
                        "description" : description,
                        "text" : ""

                    };
                    var data = {
                      "files": [
                        {
                          "name": "3d.stl",
                          "content": stlStream,
                          "content-type": "text/plain",
                          "content-encoding": "base64"
                        }
                      ],
                      "previews": [
                        {
                          "name": "385x500",
                          "content": stream,
                          "content-type": contentType,
                          "content-encoding": "base64"
                        }
                      ],
                      "presets": player.parameters(),
                      "metaData": metaData
                    };
                    dataArgs.callback(data);
                });
        }
    };
})();
//footer.js
        // Expose local runtime instance to global space in disconnected mode
        if (Host.creativePlatformRuntime.environment.getVariable(['disconnected', 'enabled'])) {
            window.creativePlatformRuntime = Host.creativePlatformRuntime;
        }
	};

	Host.creativePlatformLibraryaLVZT9dTtGGrev0 = creativePlatformLibraryaLVZT9dTtGGrev0;

})(typeof exports === 'undefined' ? window : exports);
//# sourceMappingURL=library.map
//header.js
(function(Host) {
	

	// This list of methods is taken from the following URL
	// https://developer.mozilla.org/en-US/docs/Web/API/console
	var console = {
		dir: function() { },
		error: function() { },
		group: function() { },
		groupCollapsed: function() { },
		groupEnd: function() { },
		info: function() { },
		log: function() { },
		time: function() { },
		timeEnd: function() { },
		trace: function() { },
		warn: function() { }
	};

	var creativePlatformLibrarycTLKjc2L7R7rev4 = function(Environment, Library) {

		
			var Core = Environment.libraryExports("1vxKXGNaLtr", 0);
		

		// Reserved Keywords
		var params;
		var process;
		var presets;
		var shapeGeneratorEvaluate;
		var shapeGeneratorDefaults;
		var shapeGenerator;

//manifest.js
if (Library) {
	Library.name = "Type";
	Library.description = "Moveable Type";
	Library.resources = [
		{ "id": "k0MuKhGMkAV", "name": "HussarBoldWeb.svg" }
		,{ "id": "4yjV7zHrBm5", "name": "aver.svg" }
		,{ "id": "eq6NEjoIeFQ", "name": "bebas.svg" }
		,{ "id": "3Z7OEVV8rP9", "name": "majorsnafu.svg" }
		,{ "id": "lRQVk2gfdqw", "name": "techniqu.svg" }
	];
}
//main.js
var Mesh3D = Core.Mesh3D;
var Solid = Core.Solid;
var Debug = Core.Debug;
var Font = Core.Font;
var Creation = Core.Creation;
var Conversions = Core.Conversions;
var Plugin = Core.Plugin;

var TypeGenerator = {
    parameters : function(callback){
        var fontResources = {
            "Hussar Bold": "HussarBoldWeb.svg",
            "Bebas": "bebas.svg",                       // http://www.fontsquirrel.com/fonts/Bebas
            //"Majorsnafu": "majorsnafu.svg",             // http://www.fontsquirrel.com/fonts/Major-Snafu
            //"Techniqu": "techniqu.svg",                 // http://www.fontsquirrel.com/fonts/Technique-BRK
            "Aver": "aver.svg",                         // http://www.fontspace.com/nymphont/aver
            "Canada 1500": "canada1500-rg.svg",         // http://typodermicfonts.com/canada1500/
            //"Foreman Bold": "Foreman-Bold.svg"          // https://medialoot.com/item/foreman-bold-vintage-font/
        };
        var displayNames = Object.keys(fontResources);
        var fontNames = [];
        for (var i = 0; i < displayNames.length; ++i) {
            fontNames.push(fontResources[displayNames[i]]);
        }

        var params = [
            {   "id": "font",
                "displayName": "Font",
                "type": "list",
                "listLabels": displayNames,
                "listValues": fontNames,
                "default": fontNames[0]
            },
            {
                "id": "char",
                "displayName": "Text",
                "type": "string",
                "maxLength": 64,
                "singleLine": "true",
                "default": "G"
            },
            {
                "id": "body",
                "displayName": "Body Size",
                "type": "float",
                "rangeMin": 10,
                "rangeMax": 72,
                "default": 22
            },
            { // 1 Pt = 0.3515 cm
                "id": "point",
                "displayName": "Point Size",
                "type": "float",
                "rangeMin": 10,
                "rangeMax": 72,
                "default": 12
            },
            {
                "id": "margin",
                "displayName": "Letter Spacing",
                "type": "float",
                "rangeMin": 0,
                "rangeMax": 2,
                "default": 0
            },
            {
                "id": "nickHeight",
                "displayName": "Nick Height",
                "type": "float",
                "rangeMin": 3,
                "rangeMax": 8,
                "default": 5
            },
            {
                "id": "mirror",
                "displayName": "Mirror",
                "type": "bool",
                "default": 1
            }
        ];
        callback(params);
    },
    evaluate : function(params, callback) {
        params["point"] = params["point"] * 0.3515;
        params["margin"] = params["point"] * params["margin"];
        var char = params["char"];
        var pointSize = params["point"];
        var bodySize = params["body"];
        var mirror = params["mirror"];
        var depthOfDrive = 1.3172;
        var blankSpace = false;

        if (!char.trim()){
            var charLength = char.length;
            char = "_";
            blankSpace = true;
            for(var i=0; i<charLength-1; i++)
                char += "_";
        }
        console.log(char);

        var mesh = new Mesh3D();
        var vertex = [];

        Library.resourceText(params["font"], function(fontSvg){
            var accuracy = 32;
            var font = new Font(fontSvg, pointSize*accuracy);
            var sketch = Conversions.toSketch2DFromText(char, font);
            if (!sketch)
                Plugin.panic("Type could not be generated with input [" + char + "]");
            // var result = Creation.extrude({geometry: sketch, distance: depthOfDrive});
            var result = Solid.extrude(sketch, depthOfDrive);
            result.transform([
                1/accuracy,0,0,0,
                0,1/accuracy,0,0,
                0,0,1,0,
                0,0,0,1
            ]);

            var sketchBox = result.mesh.bounds();

            result.transform([
                1,0,0,0,
                0,1,0,0,
                0,0,1,0,
                -sketchBox.center().x, 0, bodySize+0.001, 1
            ]);
            params["width"] = sketchBox.length() + 2 * params["margin"];

            TypeGenerator.createBody(params, function(bodyMesh){
                result.mesh.combineByBoundaries(bodyMesh, {ours: result.mesh.boundaries(), theirs: bodyMesh.boundaries()});
                if(mirror)
                    result.transform([
                        -1,0,0,0,
                        0,1,0,0,
                        0,0,1,0,
                        0,0,0,1
                    ]);
                callback((blankSpace) ? Solid.make(bodyMesh) : result);
            });
        });
    },
    createBody : function(params, callback){
        var height = params["point"] * 1000/750;
        var bodySize = params["body"];
        var halfWidth = params["width"] / 2;
        var nickHeight = params["nickHeight"];
        var nickR = .75;
        var nickDivs = 32;

        var bodyMesh = new Mesh3D();
        var bodyVertex = [];
        var leftNick = [];
        var rightNick = [];

        bodyVertex.push([halfWidth, 0, 0]);
        bodyVertex.push([-halfWidth, 0, 0]);
        bodyVertex.push([-halfWidth, -height, 0]);
        bodyVertex.push([halfWidth, -height, 0]);
        bodyVertex.push([halfWidth, 0, bodySize]);
        bodyVertex.push([-halfWidth, 0, bodySize]);
        bodyVertex.push([-halfWidth, -height, bodySize]);
        bodyVertex.push([halfWidth, -height, bodySize]);

        for(var i=0; i<nickDivs; i++){
            var angle = i*Math.PI/(nickDivs-1);
            leftNick.push([-halfWidth, -height + nickR * Math.sin(angle), nickHeight + nickR * Math.cos(angle)]);
            rightNick.push([halfWidth, -height + nickR * Math.sin(angle), nickHeight + nickR * Math.cos(angle)]);
        }

        bodyMesh.quad(bodyVertex[3], bodyVertex[2], bodyVertex[1], bodyVertex[0]);
        //bodyMesh.quad(bodyVertex[7], bodyVertex[6], bodyVertex[2], bodyVertex[3]); // Front
        //bodyMesh.quad(bodyVertex[6], bodyVertex[5], bodyVertex[1], bodyVertex[2]); // Left
        bodyMesh.quad(bodyVertex[5], bodyVertex[4], bodyVertex[0], bodyVertex[1]); // Back
        //bodyMesh.quad(bodyVertex[0], bodyVertex[4], bodyVertex[7], bodyVertex[3]); // Right
        bodyMesh.quad(bodyVertex[4], bodyVertex[5], bodyVertex[6], bodyVertex[7]);

        // Left, right and front faces
        bodyMesh.triangle(rightNick[0], bodyVertex[4], bodyVertex[7]); // Right top triangle
        bodyMesh.triangle(leftNick[0], bodyVertex[6], bodyVertex[5]); // Left top triangle
        bodyMesh.quad(bodyVertex[7], bodyVertex[6], leftNick[0], rightNick[0]); // Front top quad

        bodyMesh.triangle(rightNick[nickDivs - 1], bodyVertex[3], bodyVertex[0]); // Right bot triangle
        bodyMesh.triangle(leftNick[nickDivs - 1], bodyVertex[1], bodyVertex[2]); // Left bot triangle
        bodyMesh.quad(bodyVertex[2], bodyVertex[3], rightNick[nickDivs - 1], leftNick[nickDivs - 1]); // Front bot quad

        var rightAnchor = bodyVertex[4];
        var leftAnchor = bodyVertex[5];
        for(var i=0; i<nickDivs - 1; i++){
            if(i == Math.floor(nickDivs/2) - 1){
                rightAnchor = bodyVertex[0];
                leftAnchor = bodyVertex[1];
                bodyMesh.triangle(rightAnchor, bodyVertex[4], rightNick[i]);
                bodyMesh.triangle(bodyVertex[5], leftAnchor, leftNick[i]);
            }

            // Right Triangles
            bodyMesh.triangle(rightNick[i], rightNick[i+1], rightAnchor);
            // Left Triangles
            bodyMesh.triangle(leftNick[i+1], leftNick[i], leftAnchor);
            // Front Quads
            bodyMesh.quad(rightNick[i], leftNick[i], leftNick[i+1], rightNick[i+1]);
        }

        callback(bodyMesh);
    },
    drawAxis : function(){
        Debug.color([255/255, 192/255, 203/255, 0.8]);
        Debug.point([0,0,0]);
        Debug.line([-20, 0, 0], [20, 0, 0]);
        Debug.line([0, -20, 0], [0, 20, 0]);
        Debug.line([0, 0, -20], [0, 0, 20]);
    }
};

function shapeGenerator(){
    return TypeGenerator;
}
//footer.js

		if ("function" === typeof shapeGenerator) {
			Library.exports.shapeGenerator = shapeGenerator;
		} else {

			var evaluate;
			var parameters;

			if ("function" === typeof shapeGeneratorEvaluate) {
				evaluate = (function(shapeGeneratorEvaluate) { return function(params, callback) {
					shapeGeneratorEvaluate(params, callback);
				}})(shapeGeneratorEvaluate);
			} else if ("function" === typeof process) {
				evaluate = (function(process) { return function(params, callback) {
					callback(process(params));
				}})(process);
			}

			if ("function" === typeof shapeGeneratorDefaults) {
				parameters = (function(shapeGeneratorDefaults) { return function(callback) {
					shapeGeneratorDefaults(callback);
				}})(shapeGeneratorDefaults);
			} else if ("object" === typeof params) {
				parameters = (function(params) { return function(callback) {
					callback(params);
				}})(params);
			}

			if (evaluate) {
				var generator = {};
				if (parameters) { generator["parameters"] = parameters; }
				if (evaluate) { generator["evaluate"] = evaluate; }
				if (presets) {
					generator["presets"] = (function(presets) { return function(callback) {
						callback(presets);
					}})(presets);
				}
				Library.exports.shapeGenerator = (function(generator) {
					return function() { return generator; }
				})(generator);
			}
		}
	};
	Host.creativePlatformLibrarycTLKjc2L7R7rev4 = creativePlatformLibrarycTLKjc2L7R7rev4;
})(typeof exports === 'undefined' ? window : exports);
//# sourceMappingURL=library.map

   /** <-- BEGIN SEQUENCING CODE **/
    // When running outside of Andes, this will cause the disconnected player to load
    // When running inside of Andes, the library list will get cleared and this will be a no-op
    var libraries = exports.creativePlatformRuntime.environment.getVariable(['runtime', 'libraries']);
    if (libraries instanceof Array) {
        for (var i = 0; i < libraries.length; i++) {
            exports.creativePlatformRuntime.loadLibrary(libraries[i]);
        }
    }
    /** END SEQUENCING CODE --> **/
})([],easyXDM,Tess2,jQuery,Handlebars,THREE,UAParser,CSG,$,TWEEN);